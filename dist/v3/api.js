"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Identity Security Cloud V3 API
 * Use these APIs to interact with the Identity Security Cloud platform to achieve repeatable, automated processes with greater scalability. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.
 *
 * The version of the OpenAPI document: 3.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CampaignAllOfSearchCampaignInfoTypeEnum = exports.CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum = exports.CampaignAllOfFilterTypeEnum = exports.CampaignAllOfMandatoryCommentRequirementEnum = exports.CampaignAllOfCorrelatedStatusEnum = exports.CampaignAlertLevelEnum = exports.CampaignMandatoryCommentRequirementEnum = exports.CampaignCorrelatedStatusEnum = exports.CampaignStatusEnum = exports.CampaignTypeEnum = exports.BulkAddTaggedObjectOperationEnum = exports.BucketType = exports.BeforeProvisioningRuleDtoTypeEnum = exports.BaseAccessAllOfOwnerTypeEnum = exports.AuthUserCapabilitiesEnum = exports.AttributeDefinitionType = exports.AttributeDefinitionSchemaTypeEnum = exports.ApprovalStatusDtoOriginalOwnerTypeEnum = exports.ApprovalStatusDtoCurrentOwnerTypeEnum = exports.ApprovalStatus = exports.ApprovalSchemeForRoleApproverTypeEnum = exports.ApprovalScheme = exports.AggregationType = exports.AdminReviewReassignReassignToTypeEnum = exports.ActivityInsightsUsageDaysStateEnum = exports.AccountAllOfSourceOwnerTypeEnum = exports.AccountAllOfOwnerIdentityTypeEnum = exports.AccountAllOfOwnerGroupTypeEnum = exports.AccountAllOfOriginEnum = exports.AccountActivityItemOperation = exports.AccountActivityApprovalStatus = exports.AccountActionActionEnum = exports.AccountOriginEnum = exports.AccessType = exports.AccessRequestType = exports.AccessRequestPhasesResultEnum = exports.AccessRequestPhasesStateEnum = exports.AccessRequestItemTypeEnum = exports.AccessProfileUsageUsedByInnerTypeEnum = exports.AccessProfileSourceRefTypeEnum = exports.AccessProfileRefTypeEnum = exports.AccessProfileDocumentAllOfTypeEnum = exports.AccessProfileDocumentTypeEnum = exports.AccessProfileApprovalSchemeApproverTypeEnum = exports.AccessItemReviewedByTypeEnum = exports.AccessItemRequesterTypeEnum = exports.AccessItemRequestedForTypeEnum = exports.AccessCriteriaCriteriaListInnerTypeEnum = exports.AccessConstraintOperatorEnum = exports.AccessConstraintTypeEnum = void 0;
exports.LocaleOrigin = exports.LifecyclestateDeletedTypeEnum = exports.KbaAuthResponseStatusEnum = exports.JsonPatchOperationOpEnum = exports.Index = exports.ImportObjectTypeEnum = exports.IdpDetailsAllOfRoleEnum = exports.IdpDetailsRoleEnum = exports.IdentityWithNewAccessAccessRefsInnerTypeEnum = exports.IdentityWithNewAccess1AccessRefsInnerTypeEnum = exports.IdentityProfileExportedObjectSelfTypeEnum = exports.IdentityProfileAllOfOwnerTypeEnum = exports.IdentityProfileAllOfAuthoritativeSourceTypeEnum = exports.IdentityPreviewResponseIdentityTypeEnum = exports.GrantType = exports.FilterType = exports.FederationProtocolDetailsRoleEnum = exports.ExpressionChildrenInnerOperatorEnum = exports.ExpressionOperatorEnum = exports.ExecutionStatus = exports.ExceptionCriteriaCriteriaListInnerTypeEnum = exports.EntitlementRef1TypeEnum = exports.EntitlementRefTypeEnum = exports.DtoType = exports.DocumentType = exports.DeleteSource202ResponseTypeEnum = exports.DateCompareOperatorEnum = exports.CriteriaType = exports.ConnectorDetailStatusEnum = exports.CompletionStatus = exports.CompletedApprovalState = exports.CommentDtoAuthorTypeEnum = exports.ClientType = exports.CertificationTaskStatusEnum = exports.CertificationTaskTargetTypeEnum = exports.CertificationTaskTypeEnum = exports.CertificationReferenceTypeEnum = exports.CertificationPhase = exports.CertificationDecision = exports.CampaignTemplateOwnerRefTypeEnum = exports.CampaignReportStatusEnum = exports.CampaignReportTypeEnum = exports.CampaignReferenceMandatoryCommentRequirementEnum = exports.CampaignReferenceCorrelatedStatusEnum = exports.CampaignReferenceCampaignTypeEnum = exports.CampaignReferenceTypeEnum = exports.CampaignFilterDetailsModeEnum = exports.CampaignCompleteOptionsAutoCompleteActionEnum = exports.CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum = exports.CampaignAllOfSearchCampaignInfoReviewerTypeEnum = void 0;
exports.RequestedItemStatusPreApprovalTriggerDetailsDecisionEnum = exports.RequestedItemStatusTypeEnum = exports.RequestableObjectType = exports.RequestableObjectRequestStatus = exports.RequestableObjectReferenceTypeEnum = exports.ReportType = exports.ReportResultsAvailableFormatsEnum = exports.ReportResultsStatusEnum = exports.ReportResultsReportTypeEnum = exports.ReportResultReferenceAllOfStatusEnum = exports.ReportResultReferenceStatusEnum = exports.ReportResultReferenceTypeEnum = exports.ReportDetailsReportTypeEnum = exports.ReassignmentType = exports.ReassignmentReferenceTypeEnum = exports.ReassignReferenceTypeEnum = exports.QueryType = exports.PublicIdentityIdentityStateEnum = exports.ProvisioningState = exports.ProvisioningCriteriaOperation = exports.ProvisioningConfigManagedResourceRefsInnerTypeEnum = exports.PreApprovalTriggerDetailsDecisionEnum = exports.PendingApprovalOwnerTypeEnum = exports.PendingApprovalAction = exports.PatOwnerTypeEnum = exports.PasswordStatusStateEnum = exports.PasswordChangeResponseStateEnum = exports.OwnerReferenceSegmentsTypeEnum = exports.OwnerReferenceTypeEnum = exports.OwnerDtoTypeEnum = exports.OrphanUncorrelatedReportArgumentsSelectedFormatsEnum = exports.Operation = exports.ObjectMappingResponseObjectTypeEnum = exports.ObjectMappingRequestObjectTypeEnum = exports.NonEmployeeSchemaAttributeType = exports.NonEmployeeIdentityDtoType = exports.NonEmployeeBulkUploadStatusStatusEnum = exports.NonEmployeeBulkUploadJobStatusEnum = exports.NamedConstructs = exports.MfaConfigTestResponseStateEnum = exports.MetricType = exports.ManualWorkItemState = exports.ManualWorkItemDetailsOriginalOwnerTypeEnum = exports.ManualWorkItemDetailsCurrentOwnerTypeEnum = exports.ManagedClusterTypes = exports.ManagedClientType = exports.ManagedClientStatusCode = exports.ManagedClientProvisionStatusEnum = exports.ManagedClientClusterTypeEnum = exports.ManagedClientStatusEnum = void 0;
exports.TaggedObjectDtoTypeEnum = exports.StandardLevel = exports.SpDetailsAllOfRoleEnum = exports.SpDetailsRoleEnum = exports.SourceUsageStatusStatusEnum = exports.SourceSchemasInnerTypeEnum = exports.SourcePasswordPoliciesInnerTypeEnum = exports.SourceOwnerTypeEnum = exports.SourceManagerCorrelationRuleTypeEnum = exports.SourceManagementWorkgroupTypeEnum = exports.SourceHealthDtoStatusEnum = exports.SourceClusterDtoTypeEnum = exports.SourceClusterTypeEnum = exports.SourceBeforeProvisioningRuleTypeEnum = exports.SourceAccountCorrelationRuleTypeEnum = exports.SourceAccountCorrelationConfigTypeEnum = exports.SourceStatusEnum = exports.SourceFeaturesEnum = exports.SodViolationContextCheckCompletedStateEnum = exports.SodReportResultDtoTypeEnum = exports.SodRecipientTypeEnum = exports.SodPolicyOwnerRefTypeEnum = exports.SodPolicyDtoTypeEnum = exports.SodPolicyTypeEnum = exports.SodPolicyStateEnum = exports.SlimCampaignCorrelatedStatusEnum = exports.SlimCampaignStatusEnum = exports.SlimCampaignTypeEnum = exports.ServiceDeskSourceTypeEnum = exports.SendTokenResponseStatusEnum = exports.SendTokenRequestDeliveryTypeEnum = exports.SelectorType = exports.SearchScheduleRecipientsInnerTypeEnum = exports.SearchFilterType = exports.SchemaFeaturesEnum = exports.ScheduledSearchAllOfOwnerTypeEnum = exports.ScheduledAttributesFrequencyEnum = exports.ScheduleType = exports.ScheduleMonthsTypeEnum = exports.ScheduleHoursTypeEnum = exports.ScheduleDaysTypeEnum = exports.ScheduleTypeEnum = exports.RoleMembershipSelectorType = exports.RoleCriteriaOperation = exports.RoleCriteriaKeyType = exports.RoleAssignmentSourceType = exports.ReviewerTypeEnum = exports.RequestedItemStatusSodViolationContextStateEnum = exports.RequestedItemStatusRequestedForTypeEnum = exports.RequestedItemStatusRequestState = void 0;
exports.AccountActivitiesApiAxiosParamCreator = exports.AccessRequestsApi = exports.AccessRequestsApiFactory = exports.AccessRequestsApiFp = exports.AccessRequestsApiAxiosParamCreator = exports.AccessRequestApprovalsApi = exports.AccessRequestApprovalsApiFactory = exports.AccessRequestApprovalsApiFp = exports.AccessRequestApprovalsApiAxiosParamCreator = exports.AccessProfilesApi = exports.AccessProfilesApiFactory = exports.AccessProfilesApiFp = exports.AccessProfilesApiAxiosParamCreator = exports.WorkflowTriggerTypeEnum = exports.WorkflowModifiedByTypeEnum = exports.WorkflowLibraryTriggerTypeEnum = exports.WorkflowLibraryFormFieldsTypeEnum = exports.WorkflowExecutionEventTypeEnum = exports.WorkflowExecutionStatusEnum = exports.WorkflowBodyOwnerTypeEnum = exports.WorkflowAllOfCreatorTypeEnum = exports.WorkItemTypeManualWorkItems = exports.WorkItemStateManualWorkItems = exports.WorkItemState = exports.ViolationOwnerAssignmentConfigOwnerRefTypeEnum = exports.ViolationOwnerAssignmentConfigAssignmentRuleEnum = exports.ViolationContextPolicyTypeEnum = exports.VerificationResponseStatusEnum = exports.V3CreateConnectorDtoStatusEnum = exports.V3ConnectorDtoStatusEnum = exports.UsageType = exports.UploadsResponseHydrationStatusEnum = exports.UploadsResponseBackupTypeEnum = exports.UploadsResponseTypeEnum = exports.UploadsResponseStatusEnum = exports.UploadsRequestHydrationStatusEnum = exports.UploadsRequestBackupTypeEnum = exports.UploadsRequestTypeEnum = exports.UploadsRequestStatusEnum = exports.UpdateDetailStatusEnum = exports.TransformReadTypeEnum = exports.TransformTypeEnum = exports.TokenAuthResponseStatusEnum = exports.TokenAuthRequestDeliveryTypeEnum = exports.TaskResultSimplifiedCompletionStatusEnum = exports.TaskResultDtoTypeEnum = exports.TaskResultDetailsMessagesInnerTypeEnum = exports.TaskResultDetailsCompletionStatusEnum = exports.TaskResultDetailsReportTypeEnum = exports.TaskResultDetailsTypeEnum = void 0;
exports.GlobalTenantSecuritySettingsApiFactory = exports.GlobalTenantSecuritySettingsApiFp = exports.GlobalTenantSecuritySettingsApiAxiosParamCreator = exports.ConnectorsApi = exports.ConnectorsApiFactory = exports.ConnectorsApiFp = exports.ConnectorsApiAxiosParamCreator = exports.ConfigurationHubApi = exports.ConfigurationHubApiFactory = exports.ConfigurationHubApiFp = exports.ConfigurationHubApiAxiosParamCreator = exports.CertificationsApi = exports.CertificationsApiFactory = exports.CertificationsApiFp = exports.CertificationsApiAxiosParamCreator = exports.CertificationSummariesApi = exports.CertificationSummariesApiFactory = exports.CertificationSummariesApiFp = exports.CertificationSummariesApiAxiosParamCreator = exports.CertificationCampaignsApi = exports.CertificationCampaignsApiFactory = exports.CertificationCampaignsApiFp = exports.CertificationCampaignsApiAxiosParamCreator = exports.CertificationCampaignFiltersApi = exports.CertificationCampaignFiltersApiFactory = exports.CertificationCampaignFiltersApiFp = exports.CertificationCampaignFiltersApiAxiosParamCreator = exports.BrandingApi = exports.BrandingApiFactory = exports.BrandingApiFp = exports.BrandingApiAxiosParamCreator = exports.AuthUsersApi = exports.AuthUsersApiFactory = exports.AuthUsersApiFp = exports.AuthUsersApiAxiosParamCreator = exports.ApplicationDiscoveryApi = exports.ApplicationDiscoveryApiFactory = exports.ApplicationDiscoveryApiFp = exports.ApplicationDiscoveryApiAxiosParamCreator = exports.AccountsApi = exports.AccountsApiFactory = exports.AccountsApiFp = exports.AccountsApiAxiosParamCreator = exports.AccountUsagesApi = exports.AccountUsagesApiFactory = exports.AccountUsagesApiFp = exports.AccountUsagesApiAxiosParamCreator = exports.AccountActivitiesApi = exports.AccountActivitiesApiFactory = exports.AccountActivitiesApiFp = void 0;
exports.PasswordSyncGroupsApiAxiosParamCreator = exports.PasswordPoliciesApi = exports.PasswordPoliciesApiFactory = exports.PasswordPoliciesApiFp = exports.PasswordPoliciesApiAxiosParamCreator = exports.PasswordManagementApi = exports.PasswordManagementApiFactory = exports.PasswordManagementApiFp = exports.PasswordManagementApiAxiosParamCreator = exports.PasswordDictionaryApi = exports.PasswordDictionaryApiFactory = exports.PasswordDictionaryApiFp = exports.PasswordDictionaryApiAxiosParamCreator = exports.PasswordConfigurationApi = exports.PasswordConfigurationApiFactory = exports.PasswordConfigurationApiFp = exports.PasswordConfigurationApiAxiosParamCreator = exports.OAuthClientsApi = exports.OAuthClientsApiFactory = exports.OAuthClientsApiFp = exports.OAuthClientsApiAxiosParamCreator = exports.NonEmployeeLifecycleManagementApi = exports.NonEmployeeLifecycleManagementApiFactory = exports.NonEmployeeLifecycleManagementApiFp = exports.NonEmployeeLifecycleManagementApiAxiosParamCreator = exports.ManagedClustersApi = exports.ManagedClustersApiFactory = exports.ManagedClustersApiFp = exports.ManagedClustersApiAxiosParamCreator = exports.ManagedClientsApi = exports.ManagedClientsApiFactory = exports.ManagedClientsApiFp = exports.ManagedClientsApiAxiosParamCreator = exports.MFAControllerApi = exports.MFAControllerApiFactory = exports.MFAControllerApiFp = exports.MFAControllerApiAxiosParamCreator = exports.MFAConfigurationApi = exports.MFAConfigurationApiFactory = exports.MFAConfigurationApiFp = exports.MFAConfigurationApiAxiosParamCreator = exports.LifecycleStatesApi = exports.LifecycleStatesApiFactory = exports.LifecycleStatesApiFp = exports.LifecycleStatesApiAxiosParamCreator = exports.IdentityProfilesApi = exports.IdentityProfilesApiFactory = exports.IdentityProfilesApiFp = exports.IdentityProfilesApiAxiosParamCreator = exports.GlobalTenantSecuritySettingsApi = void 0;
exports.SearchAttributeConfigurationApiFactory = exports.SearchAttributeConfigurationApiFp = exports.SearchAttributeConfigurationApiAxiosParamCreator = exports.SearchApi = exports.SearchApiFactory = exports.SearchApiFp = exports.SearchApiAxiosParamCreator = exports.ScheduledSearchApi = exports.ScheduledSearchApiFactory = exports.ScheduledSearchApiFp = exports.ScheduledSearchApiAxiosParamCreator = exports.SavedSearchApi = exports.SavedSearchApiFactory = exports.SavedSearchApiFp = exports.SavedSearchApiAxiosParamCreator = exports.SODViolationsApi = exports.SODViolationsApiFactory = exports.SODViolationsApiFp = exports.SODViolationsApiAxiosParamCreator = exports.SODPoliciesApi = exports.SODPoliciesApiFactory = exports.SODPoliciesApiFp = exports.SODPoliciesApiAxiosParamCreator = exports.RolesApi = exports.RolesApiFactory = exports.RolesApiFp = exports.RolesApiAxiosParamCreator = exports.RequestableObjectsApi = exports.RequestableObjectsApiFactory = exports.RequestableObjectsApiFp = exports.RequestableObjectsApiAxiosParamCreator = exports.ReportsDataExtractionApi = exports.ReportsDataExtractionApiFactory = exports.ReportsDataExtractionApiFp = exports.ReportsDataExtractionApiAxiosParamCreator = exports.PublicIdentitiesConfigApi = exports.PublicIdentitiesConfigApiFactory = exports.PublicIdentitiesConfigApiFp = exports.PublicIdentitiesConfigApiAxiosParamCreator = exports.PublicIdentitiesApi = exports.PublicIdentitiesApiFactory = exports.PublicIdentitiesApiFp = exports.PublicIdentitiesApiAxiosParamCreator = exports.PersonalAccessTokensApi = exports.PersonalAccessTokensApiFactory = exports.PersonalAccessTokensApiFp = exports.PersonalAccessTokensApiAxiosParamCreator = exports.PasswordSyncGroupsApi = exports.PasswordSyncGroupsApiFactory = exports.PasswordSyncGroupsApiFp = void 0;
exports.WorkflowsApi = exports.WorkflowsApiFactory = exports.WorkflowsApiFp = exports.WorkflowsApiAxiosParamCreator = exports.WorkItemsApi = exports.WorkItemsApiFactory = exports.WorkItemsApiFp = exports.WorkItemsApiAxiosParamCreator = exports.VendorConnectorMappingsApi = exports.VendorConnectorMappingsApiFactory = exports.VendorConnectorMappingsApiFp = exports.VendorConnectorMappingsApiAxiosParamCreator = exports.TransformsApi = exports.TransformsApiFactory = exports.TransformsApiFp = exports.TransformsApiAxiosParamCreator = exports.TaggedObjectsApi = exports.TaggedObjectsApiFactory = exports.TaggedObjectsApiFp = exports.TaggedObjectsApiAxiosParamCreator = exports.SourcesApi = exports.SourcesApiFactory = exports.SourcesApiFp = exports.SourcesApiAxiosParamCreator = exports.SourceUsagesApi = exports.SourceUsagesApiFactory = exports.SourceUsagesApiFp = exports.SourceUsagesApiAxiosParamCreator = exports.ServiceDeskIntegrationApi = exports.ServiceDeskIntegrationApiFactory = exports.ServiceDeskIntegrationApiFp = exports.ServiceDeskIntegrationApiAxiosParamCreator = exports.SegmentsApi = exports.SegmentsApiFactory = exports.SegmentsApiFp = exports.SegmentsApiAxiosParamCreator = exports.SearchAttributeConfigurationApi = void 0;
var axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("./common");
// @ts-ignore
var base_1 = require("./base");
exports.AccessConstraintTypeEnum = {
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE'
};
exports.AccessConstraintOperatorEnum = {
    All: 'ALL',
    Selected: 'SELECTED'
};
exports.AccessCriteriaCriteriaListInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
};
exports.AccessItemRequestedForTypeEnum = {
    Identity: 'IDENTITY'
};
exports.AccessItemRequesterTypeEnum = {
    Identity: 'IDENTITY'
};
exports.AccessItemReviewedByTypeEnum = {
    Identity: 'IDENTITY'
};
exports.AccessProfileApprovalSchemeApproverTypeEnum = {
    AppOwner: 'APP_OWNER',
    Owner: 'OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
};
exports.AccessProfileDocumentTypeEnum = {
    Accessprofile: 'accessprofile',
    Accountactivity: 'accountactivity',
    Account: 'account',
    Aggregation: 'aggregation',
    Entitlement: 'entitlement',
    Event: 'event',
    Identity: 'identity',
    Role: 'role'
};
exports.AccessProfileDocumentAllOfTypeEnum = {
    Accessprofile: 'accessprofile',
    Accountactivity: 'accountactivity',
    Account: 'account',
    Aggregation: 'aggregation',
    Entitlement: 'entitlement',
    Event: 'event',
    Identity: 'identity',
    Role: 'role'
};
exports.AccessProfileRefTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE'
};
exports.AccessProfileSourceRefTypeEnum = {
    Source: 'SOURCE'
};
exports.AccessProfileUsageUsedByInnerTypeEnum = {
    Role: 'ROLE'
};
exports.AccessRequestItemTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
};
exports.AccessRequestPhasesStateEnum = {
    Pending: 'PENDING',
    Executing: 'EXECUTING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    NotExecuted: 'NOT_EXECUTED'
};
exports.AccessRequestPhasesResultEnum = {
    Successful: 'SUCCESSFUL',
    Failed: 'FAILED',
    Null: 'null'
};
/**
 * Access request type. Defaults to GRANT_ACCESS. REVOKE_ACCESS type can only have a single Identity ID in the requestedFor field.
 * @export
 * @enum {string}
 */
exports.AccessRequestType = {
    GrantAccess: 'GRANT_ACCESS',
    RevokeAccess: 'REVOKE_ACCESS',
    Null: 'null'
};
/**
 * Access type of API Client indicating online or offline use
 * @export
 * @enum {string}
 */
exports.AccessType = {
    Online: 'ONLINE',
    Offline: 'OFFLINE'
};
exports.AccountOriginEnum = {
    Aggregated: 'AGGREGATED',
    Provisioned: 'PROVISIONED',
    Null: 'null'
};
exports.AccountActionActionEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
};
/**
 * The state of an approval status
 * @export
 * @enum {string}
 */
exports.AccountActivityApprovalStatus = {
    Finished: 'FINISHED',
    Rejected: 'REJECTED',
    Returned: 'RETURNED',
    Expired: 'EXPIRED',
    Pending: 'PENDING',
    Canceled: 'CANCELED',
    Null: 'null'
};
/**
 * Represents an operation in an account activity item
 * @export
 * @enum {string}
 */
exports.AccountActivityItemOperation = {
    Add: 'ADD',
    Create: 'CREATE',
    Modify: 'MODIFY',
    Delete: 'DELETE',
    Disable: 'DISABLE',
    Enable: 'ENABLE',
    Unlock: 'UNLOCK',
    Lock: 'LOCK',
    Remove: 'REMOVE',
    Set: 'SET',
    Null: 'null'
};
exports.AccountAllOfOriginEnum = {
    Aggregated: 'AGGREGATED',
    Provisioned: 'PROVISIONED',
    Null: 'null'
};
exports.AccountAllOfOwnerGroupTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP'
};
exports.AccountAllOfOwnerIdentityTypeEnum = {
    Identity: 'IDENTITY'
};
exports.AccountAllOfSourceOwnerTypeEnum = {
    Identity: 'IDENTITY'
};
exports.ActivityInsightsUsageDaysStateEnum = {
    Complete: 'COMPLETE',
    Unknown: 'UNKNOWN'
};
exports.AdminReviewReassignReassignToTypeEnum = {
    Identity: 'IDENTITY'
};
/**
 * Enum representing the currently available query languages for aggregations, which are used to perform calculations or groupings on search results.  Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.AggregationType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT'
};
/**
 * Describes the individual or group that is responsible for an approval step.
 * @export
 * @enum {string}
 */
exports.ApprovalScheme = {
    AppOwner: 'APP_OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    RoleOwner: 'ROLE_OWNER',
    AccessProfileOwner: 'ACCESS_PROFILE_OWNER',
    EntitlementOwner: 'ENTITLEMENT_OWNER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
};
exports.ApprovalSchemeForRoleApproverTypeEnum = {
    Owner: 'OWNER',
    Manager: 'MANAGER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
};
/**
 * Enum representing the non-employee request approval status
 * @export
 * @enum {string}
 */
exports.ApprovalStatus = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Pending: 'PENDING',
    NotReady: 'NOT_READY',
    Cancelled: 'CANCELLED'
};
exports.ApprovalStatusDtoCurrentOwnerTypeEnum = {
    Identity: 'IDENTITY'
};
exports.ApprovalStatusDtoOriginalOwnerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
};
exports.AttributeDefinitionSchemaTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
};
/**
 * The underlying type of the value which an AttributeDefinition represents.
 * @export
 * @enum {string}
 */
exports.AttributeDefinitionType = {
    String: 'STRING',
    Long: 'LONG',
    Int: 'INT',
    Boolean: 'BOOLEAN'
};
exports.AuthUserCapabilitiesEnum = {
    CertAdmin: 'CERT_ADMIN',
    CloudGovAdmin: 'CLOUD_GOV_ADMIN',
    CloudGovUser: 'CLOUD_GOV_USER',
    Helpdesk: 'HELPDESK',
    OrgAdmin: 'ORG_ADMIN',
    ReportAdmin: 'REPORT_ADMIN',
    RoleAdmin: 'ROLE_ADMIN',
    RoleSubadmin: 'ROLE_SUBADMIN',
    SaasManagementAdmin: 'SAAS_MANAGEMENT_ADMIN',
    SaasManagementReader: 'SAAS_MANAGEMENT_READER',
    SourceAdmin: 'SOURCE_ADMIN',
    SourceSubadmin: 'SOURCE_SUBADMIN',
    DasuiAdministrator: 'das:ui-administrator',
    DasuiComplianceManager: 'das:ui-compliance_manager',
    DasuiAuditor: 'das:ui-auditor',
    DasuiDataScope: 'das:ui-data-scope',
    SpaicDashboardRead: 'sp:aic-dashboard-read',
    SpaicDashboardWrite: 'sp:aic-dashboard-write',
    SpuiConfigHubAdmin: 'sp:ui-config-hub-admin',
    SpuiConfigHubBackupAdmin: 'sp:ui-config-hub-backup-admin',
    SpuiConfigHubRead: 'sp:ui-config-hub-read'
};
exports.BaseAccessAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
};
exports.BeforeProvisioningRuleDtoTypeEnum = {
    Rule: 'RULE'
};
/**
 * Enum representing the currently supported bucket aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.BucketType = {
    Terms: 'TERMS'
};
exports.BulkAddTaggedObjectOperationEnum = {
    Append: 'APPEND',
    Merge: 'MERGE'
};
exports.CampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
};
exports.CampaignStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
};
exports.CampaignCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
};
exports.CampaignMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
};
exports.CampaignAlertLevelEnum = {
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO'
};
exports.CampaignAllOfCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
};
exports.CampaignAllOfMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
};
exports.CampaignAllOfFilterTypeEnum = {
    CampaignFilter: 'CAMPAIGN_FILTER',
    Rule: 'RULE'
};
exports.CampaignAllOfRoleCompositionCampaignInfoRemediatorRefTypeEnum = {
    Identity: 'IDENTITY'
};
exports.CampaignAllOfSearchCampaignInfoTypeEnum = {
    Identity: 'IDENTITY',
    Access: 'ACCESS'
};
exports.CampaignAllOfSearchCampaignInfoReviewerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
};
exports.CampaignAllOfSourcesWithOrphanEntitlementsTypeEnum = {
    Source: 'SOURCE'
};
exports.CampaignCompleteOptionsAutoCompleteActionEnum = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
};
exports.CampaignFilterDetailsModeEnum = {
    Inclusion: 'INCLUSION',
    Exclusion: 'EXCLUSION'
};
exports.CampaignReferenceTypeEnum = {
    Campaign: 'CAMPAIGN'
};
exports.CampaignReferenceCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH'
};
exports.CampaignReferenceCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
};
exports.CampaignReferenceMandatoryCommentRequirementEnum = {
    AllDecisions: 'ALL_DECISIONS',
    RevokeOnlyDecisions: 'REVOKE_ONLY_DECISIONS',
    NoDecisions: 'NO_DECISIONS'
};
exports.CampaignReportTypeEnum = {
    ReportResult: 'REPORT_RESULT'
};
exports.CampaignReportStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
};
exports.CampaignTemplateOwnerRefTypeEnum = {
    Identity: 'IDENTITY'
};
/**
 * The decision to approve or revoke the review item
 * @export
 * @enum {string}
 */
exports.CertificationDecision = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
};
/**
 * The current phase of the campaign. * `STAGED`: The campaign is waiting to be activated. * `ACTIVE`: The campaign is active. * `SIGNED`: The reviewer has signed off on the campaign, and it is considered complete.
 * @export
 * @enum {string}
 */
exports.CertificationPhase = {
    Staged: 'STAGED',
    Active: 'ACTIVE',
    Signed: 'SIGNED'
};
exports.CertificationReferenceTypeEnum = {
    Certification: 'CERTIFICATION'
};
exports.CertificationTaskTypeEnum = {
    Reassign: 'REASSIGN',
    AdminReassign: 'ADMIN_REASSIGN',
    CompleteCertification: 'COMPLETE_CERTIFICATION',
    FinishCertification: 'FINISH_CERTIFICATION',
    CompleteCampaign: 'COMPLETE_CAMPAIGN',
    ActivateCampaign: 'ACTIVATE_CAMPAIGN',
    CampaignCreate: 'CAMPAIGN_CREATE',
    CampaignDelete: 'CAMPAIGN_DELETE'
};
exports.CertificationTaskTargetTypeEnum = {
    Certification: 'CERTIFICATION',
    Campaign: 'CAMPAIGN'
};
exports.CertificationTaskStatusEnum = {
    Queued: 'QUEUED',
    InProgress: 'IN_PROGRESS',
    Success: 'SUCCESS',
    Error: 'ERROR'
};
/**
 * Type of an API Client indicating public or confidentials use
 * @export
 * @enum {string}
 */
exports.ClientType = {
    Confidential: 'CONFIDENTIAL',
    Public: 'PUBLIC'
};
exports.CommentDtoAuthorTypeEnum = {
    Identity: 'IDENTITY'
};
/**
 * Enum represents completed approval object\'s state.
 * @export
 * @enum {string}
 */
exports.CompletedApprovalState = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
};
/**
 * The status after completion.
 * @export
 * @enum {string}
 */
exports.CompletionStatus = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Incomplete: 'INCOMPLETE',
    Pending: 'PENDING',
    Null: 'null'
};
exports.ConnectorDetailStatusEnum = {
    Deprecated: 'DEPRECATED',
    Development: 'DEVELOPMENT',
    Demo: 'DEMO',
    Released: 'RELEASED'
};
/**
 * Type of the criteria in the filter. The `COMPOSITE` filter can contain multiple filters in an AND/OR relationship.
 * @export
 * @enum {string}
 */
exports.CriteriaType = {
    Composite: 'COMPOSITE',
    Role: 'ROLE',
    Identity: 'IDENTITY',
    IdentityAttribute: 'IDENTITY_ATTRIBUTE',
    Entitlement: 'ENTITLEMENT',
    AccessProfile: 'ACCESS_PROFILE',
    Source: 'SOURCE',
    Account: 'ACCOUNT',
    AggregatedEntitlement: 'AGGREGATED_ENTITLEMENT',
    InvalidCertifiableEntity: 'INVALID_CERTIFIABLE_ENTITY'
};
exports.DateCompareOperatorEnum = {
    Lt: 'LT',
    Lte: 'LTE',
    Gt: 'GT',
    Gte: 'GTE'
};
exports.DeleteSource202ResponseTypeEnum = {
    TaskResult: 'TASK_RESULT'
};
/**
 * Enum representing the currently supported document types.  Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.DocumentType = {
    Accessprofile: 'accessprofile',
    Accountactivity: 'accountactivity',
    Account: 'account',
    Aggregation: 'aggregation',
    Entitlement: 'entitlement',
    Event: 'event',
    Identity: 'identity',
    Role: 'role'
};
/**
 * An enumeration of the types of DTOs supported within the IdentityNow infrastructure.
 * @export
 * @enum {string}
 */
exports.DtoType = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG',
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestApproval: 'ACCESS_REQUEST_APPROVAL',
    Account: 'ACCOUNT',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Certification: 'CERTIFICATION',
    Cluster: 'CLUSTER',
    ConnectorSchema: 'CONNECTOR_SCHEMA',
    Entitlement: 'ENTITLEMENT',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityProfile: 'IDENTITY_PROFILE',
    IdentityRequest: 'IDENTITY_REQUEST',
    LifecycleState: 'LIFECYCLE_STATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    Role: 'ROLE',
    Rule: 'RULE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    TagCategory: 'TAG_CATEGORY',
    TaskResult: 'TASK_RESULT',
    ReportResult: 'REPORT_RESULT',
    SodViolation: 'SOD_VIOLATION',
    AccountActivity: 'ACCOUNT_ACTIVITY',
    Workgroup: 'WORKGROUP'
};
exports.EntitlementRefTypeEnum = {
    Entitlement: 'ENTITLEMENT'
};
exports.EntitlementRef1TypeEnum = {
    Entitlement: 'ENTITLEMENT'
};
exports.ExceptionCriteriaCriteriaListInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
};
/**
 * The current state of execution.
 * @export
 * @enum {string}
 */
exports.ExecutionStatus = {
    Executing: 'EXECUTING',
    Verifying: 'VERIFYING',
    Terminated: 'TERMINATED',
    Completed: 'COMPLETED'
};
exports.ExpressionOperatorEnum = {
    And: 'AND',
    Equals: 'EQUALS'
};
exports.ExpressionChildrenInnerOperatorEnum = {
    And: 'AND',
    Equals: 'EQUALS'
};
exports.FederationProtocolDetailsRoleEnum = {
    Idp: 'SAML_IDP',
    Sp: 'SAML_SP'
};
/**
 * Enum representing the currently supported filter types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.FilterType = {
    Exists: 'EXISTS',
    Range: 'RANGE',
    Terms: 'TERMS'
};
/**
 * OAuth2 Grant Type
 * @export
 * @enum {string}
 */
exports.GrantType = {
    ClientCredentials: 'CLIENT_CREDENTIALS',
    AuthorizationCode: 'AUTHORIZATION_CODE',
    RefreshToken: 'REFRESH_TOKEN'
};
exports.IdentityPreviewResponseIdentityTypeEnum = {
    Identity: 'IDENTITY'
};
exports.IdentityProfileAllOfAuthoritativeSourceTypeEnum = {
    Source: 'SOURCE'
};
exports.IdentityProfileAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
};
exports.IdentityProfileExportedObjectSelfTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
};
exports.IdentityWithNewAccess1AccessRefsInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
};
exports.IdentityWithNewAccessAccessRefsInnerTypeEnum = {
    Entitlement: 'ENTITLEMENT'
};
exports.IdpDetailsRoleEnum = {
    SamlIdp: 'SAML_IDP'
};
exports.IdpDetailsAllOfRoleEnum = {
    SamlIdp: 'SAML_IDP'
};
exports.ImportObjectTypeEnum = {
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    Rule: 'RULE',
    Source: 'SOURCE',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION'
};
/**
 * Enum representing the currently supported indices. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.Index = {
    Accessprofiles: 'accessprofiles',
    Accountactivities: 'accountactivities',
    Entitlements: 'entitlements',
    Events: 'events',
    Identities: 'identities',
    Roles: 'roles',
    Star: '*'
};
exports.JsonPatchOperationOpEnum = {
    Add: 'add',
    Remove: 'remove',
    Replace: 'replace',
    Move: 'move',
    Copy: 'copy',
    Test: 'test'
};
exports.KbaAuthResponseStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Lockout: 'LOCKOUT',
    NotEnoughData: 'NOT_ENOUGH_DATA'
};
exports.LifecyclestateDeletedTypeEnum = {
    LifecycleState: 'LIFECYCLE_STATE'
};
/**
 * An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.LocaleOrigin = {
    Default: 'DEFAULT',
    Request: 'REQUEST',
    Null: 'null'
};
exports.ManagedClientStatusEnum = {
    Normal: 'NORMAL',
    Undefined: 'UNDEFINED',
    NotConfigured: 'NOT_CONFIGURED',
    Configuring: 'CONFIGURING',
    Warning: 'WARNING',
    Error: 'ERROR',
    Failed: 'FAILED',
    Null: 'null'
};
exports.ManagedClientClusterTypeEnum = {
    Null: 'null',
    Idn: 'idn',
    Iai: 'iai',
    SpConnectCluster: 'spConnectCluster',
    SqsCluster: 'sqsCluster',
    DasRc: 'das-rc',
    DasPc: 'das-pc',
    DasDc: 'das-dc'
};
exports.ManagedClientProvisionStatusEnum = {
    Null: 'null',
    Provisioned: 'PROVISIONED',
    Draft: 'DRAFT'
};
/**
 * Status of a Managed Client
 * @export
 * @enum {string}
 */
exports.ManagedClientStatusCode = {
    Normal: 'NORMAL',
    Undefined: 'UNDEFINED',
    NotConfigured: 'NOT_CONFIGURED',
    Configuring: 'CONFIGURING',
    Warning: 'WARNING',
    Error: 'ERROR',
    Failed: 'FAILED'
};
/**
 * Managed Client type
 * @export
 * @enum {string}
 */
exports.ManagedClientType = {
    Ccg: 'CCG',
    Va: 'VA',
    Internal: 'INTERNAL',
    IiqHarvester: 'IIQ_HARVESTER',
    Null: 'null'
};
/**
 * The Type of Cluster
 * @export
 * @enum {string}
 */
exports.ManagedClusterTypes = {
    Idn: 'idn',
    Iai: 'iai'
};
exports.ManualWorkItemDetailsCurrentOwnerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
};
exports.ManualWorkItemDetailsOriginalOwnerTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
};
/**
 * Indicates the state of the request processing for this item: * PENDING: The request for this item is awaiting processing. * APPROVED: The request for this item has been approved. * REJECTED: The request for this item was rejected. * EXPIRED: The request for this item expired with no action taken. * CANCELLED: The request for this item was cancelled with no user action. * ARCHIVED: The request for this item has been archived after completion.
 * @export
 * @enum {string}
 */
exports.ManualWorkItemState = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED',
    Archived: 'ARCHIVED'
};
/**
 * Enum representing the currently supported metric aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.MetricType = {
    Count: 'COUNT',
    UniqueCount: 'UNIQUE_COUNT',
    Avg: 'AVG',
    Sum: 'SUM',
    Median: 'MEDIAN',
    Min: 'MIN',
    Max: 'MAX'
};
exports.MfaConfigTestResponseStateEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
};
/**
 * | Construct       | Date Time Pattern | Description | | ---------       | ----------------- | ----------- | | ISO8601         | `yyyy-MM-dd\'T\'HH:mm:ss.SSSX` | The ISO8601 standard. |           | LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    | | PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. | | EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. | | EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |
 * @export
 * @enum {string}
 */
exports.NamedConstructs = {
    Iso8601: 'ISO8601',
    Ldap: 'LDAP',
    PeopleSoft: 'PEOPLE_SOFT',
    EpochTimeJava: 'EPOCH_TIME_JAVA',
    EpochTimeWin32: 'EPOCH_TIME_WIN32'
};
exports.NonEmployeeBulkUploadJobStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
};
exports.NonEmployeeBulkUploadStatusStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
};
/**
 * Identifies if the identity is a normal identity or a governance group
 * @export
 * @enum {string}
 */
exports.NonEmployeeIdentityDtoType = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
};
/**
 * Enum representing the type of data a schema attribute accepts.
 * @export
 * @enum {string}
 */
exports.NonEmployeeSchemaAttributeType = {
    Text: 'TEXT',
    Date: 'DATE',
    Identity: 'IDENTITY'
};
exports.ObjectMappingRequestObjectTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Entitlement: 'ENTITLEMENT',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
};
exports.ObjectMappingResponseObjectTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestConfig: 'ACCESS_REQUEST_CONFIG',
    AttrSyncSourceConfig: 'ATTR_SYNC_SOURCE_CONFIG',
    AuthOrg: 'AUTH_ORG',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Entitlement: 'ENTITLEMENT',
    FormDefinition: 'FORM_DEFINITION',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityObjectConfig: 'IDENTITY_OBJECT_CONFIG',
    IdentityProfile: 'IDENTITY_PROFILE',
    LifecycleState: 'LIFECYCLE_STATE',
    NotificationTemplate: 'NOTIFICATION_TEMPLATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    PasswordSyncGroup: 'PASSWORD_SYNC_GROUP',
    PublicIdentitiesConfig: 'PUBLIC_IDENTITIES_CONFIG',
    Role: 'ROLE',
    Rule: 'RULE',
    Segment: 'SEGMENT',
    ServiceDeskIntegration: 'SERVICE_DESK_INTEGRATION',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    Tag: 'TAG',
    Transform: 'TRANSFORM',
    TriggerSubscription: 'TRIGGER_SUBSCRIPTION',
    Workflow: 'WORKFLOW'
};
/**
 * Operation on a specific criteria
 * @export
 * @enum {string}
 */
exports.Operation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    And: 'AND',
    Or: 'OR',
    Null: 'null'
};
exports.OrphanUncorrelatedReportArgumentsSelectedFormatsEnum = {
    Csv: 'CSV',
    Pdf: 'PDF'
};
exports.OwnerDtoTypeEnum = {
    Identity: 'IDENTITY'
};
exports.OwnerReferenceTypeEnum = {
    Identity: 'IDENTITY'
};
exports.OwnerReferenceSegmentsTypeEnum = {
    Identity: 'IDENTITY'
};
exports.PasswordChangeResponseStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
};
exports.PasswordStatusStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
};
exports.PatOwnerTypeEnum = {
    Identity: 'IDENTITY'
};
/**
 * Enum represents action that is being processed on an approval.
 * @export
 * @enum {string}
 */
exports.PendingApprovalAction = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Forwarded: 'FORWARDED'
};
exports.PendingApprovalOwnerTypeEnum = {
    Identity: 'IDENTITY'
};
exports.PreApprovalTriggerDetailsDecisionEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
};
exports.ProvisioningConfigManagedResourceRefsInnerTypeEnum = {
    Source: 'SOURCE'
};
/**
 * Supported operations on ProvisioningCriteria
 * @export
 * @enum {string}
 */
exports.ProvisioningCriteriaOperation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    Has: 'HAS',
    And: 'AND',
    Or: 'OR'
};
/**
 * Provisioning state of an account activity item
 * @export
 * @enum {string}
 */
exports.ProvisioningState = {
    Pending: 'PENDING',
    Finished: 'FINISHED',
    Unverifiable: 'UNVERIFIABLE',
    Commited: 'COMMITED',
    Failed: 'FAILED',
    Retry: 'RETRY'
};
exports.PublicIdentityIdentityStateEnum = {
    Active: 'ACTIVE',
    InactiveShortTerm: 'INACTIVE_SHORT_TERM',
    InactiveLongTerm: 'INACTIVE_LONG_TERM',
    Null: 'null'
};
/**
 * The type of query to use.  By default, the `SAILPOINT` query type is used, which requires the `query` object to be defined in the request body. To use the `queryDsl` or `typeAheadQuery` objects in the request, you must set the type to `DSL` or `TYPEAHEAD` accordingly. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.QueryType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT',
    Text: 'TEXT',
    Typeahead: 'TYPEAHEAD'
};
exports.ReassignReferenceTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
};
exports.ReassignmentReferenceTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
};
/**
 * The approval reassignment type.  * MANUAL_REASSIGNMENT: An approval with this reassignment type has been specifically reassigned by the approval task\'s owner, from their queue to someone else\'s.  * AUTOMATIC_REASSIGNMENT: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to that approver\'s reassignment configuration. The approver\'s reassignment configuration may be set up to automatically reassign approval tasks for a defined (or possibly open-ended) period of time. * AUTO_ESCALATION: An approval with this reassignment type has been automatically reassigned from another approver\'s queue, according to the request\'s escalation configuration. For more information about escalation configuration, refer to [Setting Global Reminders and Escalation Policies](https://documentation.sailpoint.com/saas/help/requests/config_emails.html). * SELF_REVIEW_DELEGATION: An approval with this reassignment type has been automatically reassigned by the system to prevent self-review. This helps prevent situations like a requester being tasked with approving their own request. For more information about preventing self-review, refer to [Self-review Prevention](https://documentation.sailpoint.com/saas/help/users/work_reassignment.html#self-review-prevention) and [Preventing Self-approval](https://documentation.sailpoint.com/saas/help/requests/config_ap_roles.html#preventing-self-approval).
 * @export
 * @enum {string}
 */
exports.ReassignmentType = {
    ManualReassignment: 'MANUAL_REASSIGNMENT',
    AutomaticReassignment: 'AUTOMATIC_REASSIGNMENT',
    AutoEscalation: 'AUTO_ESCALATION',
    SelfReviewDelegation: 'SELF_REVIEW_DELEGATION'
};
exports.ReportDetailsReportTypeEnum = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
};
exports.ReportResultReferenceTypeEnum = {
    ReportResult: 'REPORT_RESULT'
};
exports.ReportResultReferenceStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
};
exports.ReportResultReferenceAllOfStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR',
    Pending: 'PENDING'
};
exports.ReportResultsReportTypeEnum = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
};
exports.ReportResultsStatusEnum = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Warning: 'WARNING',
    Terminated: 'TERMINATED'
};
exports.ReportResultsAvailableFormatsEnum = {
    Csv: 'CSV',
    Pdf: 'PDF'
};
/**
 * type of a Report
 * @export
 * @enum {string}
 */
exports.ReportType = {
    CampaignCompositionReport: 'CAMPAIGN_COMPOSITION_REPORT',
    CampaignRemediationStatusReport: 'CAMPAIGN_REMEDIATION_STATUS_REPORT',
    CampaignStatusReport: 'CAMPAIGN_STATUS_REPORT',
    CertificationSignoffReport: 'CERTIFICATION_SIGNOFF_REPORT'
};
exports.RequestableObjectReferenceTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
};
/**
 * Status indicating the ability of an access request for the object to be made by or on behalf of the identity specified by *identity-id*. *AVAILABLE* indicates the object is available to request. *PENDING* indicates the object is unavailable because the identity has a pending request in flight. *ASSIGNED* indicates the object is unavailable because the identity already has the indicated role or access profile. If *identity-id* is not specified (allowed only for admin users), then status will be *AVAILABLE* for all results.
 * @export
 * @enum {string}
 */
exports.RequestableObjectRequestStatus = {
    Available: 'AVAILABLE',
    Pending: 'PENDING',
    Assigned: 'ASSIGNED',
    Null: 'null'
};
/**
 * The currently supported requestable object types.
 * @export
 * @enum {string}
 */
exports.RequestableObjectType = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
};
exports.RequestedItemStatusTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT',
    Null: 'null'
};
exports.RequestedItemStatusPreApprovalTriggerDetailsDecisionEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
};
/**
 * Indicates the state of an access request: * EXECUTING: The request is executing, which indicates the system is doing some processing. * REQUEST_COMPLETED: Indicates the request  has been completed. * CANCELLED: The request was cancelled with no user input. * TERMINATED: The request has been terminated before it was able to complete. * PROVISIONING_VERIFICATION_PENDING: The request has finished any approval steps and provisioning is waiting to be verified. * REJECTED: The request was rejected. * PROVISIONING_FAILED: The request has failed to complete. * NOT_ALL_ITEMS_PROVISIONED: One or more of the requested items failed to complete, but there were one or more  successes. * ERROR: An error occurred during request processing.
 * @export
 * @enum {string}
 */
exports.RequestedItemStatusRequestState = {
    Executing: 'EXECUTING',
    RequestCompleted: 'REQUEST_COMPLETED',
    Cancelled: 'CANCELLED',
    Terminated: 'TERMINATED',
    ProvisioningVerificationPending: 'PROVISIONING_VERIFICATION_PENDING',
    Rejected: 'REJECTED',
    ProvisioningFailed: 'PROVISIONING_FAILED',
    NotAllItemsProvisioned: 'NOT_ALL_ITEMS_PROVISIONED',
    Error: 'ERROR'
};
exports.RequestedItemStatusRequestedForTypeEnum = {
    Identity: 'IDENTITY'
};
exports.RequestedItemStatusSodViolationContextStateEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR',
    Null: 'null'
};
exports.ReviewerTypeEnum = {
    Identity: 'IDENTITY'
};
/**
 * Type which indicates how a particular Identity obtained a particular Role
 * @export
 * @enum {string}
 */
exports.RoleAssignmentSourceType = {
    AccessRequest: 'ACCESS_REQUEST',
    RoleMembership: 'ROLE_MEMBERSHIP'
};
/**
 * Indicates whether the associated criteria represents an expression on identity attributes, account attributes, or entitlements, respectively.
 * @export
 * @enum {string}
 */
exports.RoleCriteriaKeyType = {
    Identity: 'IDENTITY',
    Account: 'ACCOUNT',
    Entitlement: 'ENTITLEMENT'
};
/**
 * An operation
 * @export
 * @enum {string}
 */
exports.RoleCriteriaOperation = {
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS',
    Contains: 'CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    And: 'AND',
    Or: 'OR'
};
/**
 * This enum characterizes the type of a Role\'s membership selector. Only the following two are fully supported:  STANDARD: Indicates that Role membership is defined in terms of a criteria expression  IDENTITY_LIST: Indicates that Role membership is conferred on the specific identities listed
 * @export
 * @enum {string}
 */
exports.RoleMembershipSelectorType = {
    Standard: 'STANDARD',
    IdentityList: 'IDENTITY_LIST'
};
exports.ScheduleTypeEnum = {
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Annually: 'ANNUALLY',
    Calendar: 'CALENDAR'
};
exports.ScheduleDaysTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
};
exports.ScheduleHoursTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
};
exports.ScheduleMonthsTypeEnum = {
    List: 'LIST',
    Range: 'RANGE'
};
/**
 * Enum representing the currently supported schedule types.  Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.ScheduleType = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Calendar: 'CALENDAR',
    Annually: 'ANNUALLY'
};
exports.ScheduledAttributesFrequencyEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Yearly: 'yearly',
    CronSchedule: 'cronSchedule'
};
exports.ScheduledSearchAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
};
exports.SchemaFeaturesEnum = {
    Authenticate: 'AUTHENTICATE',
    Composite: 'COMPOSITE',
    DirectPermissions: 'DIRECT_PERMISSIONS',
    DiscoverSchema: 'DISCOVER_SCHEMA',
    Enable: 'ENABLE',
    ManagerLookup: 'MANAGER_LOOKUP',
    NoRandomAccess: 'NO_RANDOM_ACCESS',
    Proxy: 'PROXY',
    Search: 'SEARCH',
    Template: 'TEMPLATE',
    Unlock: 'UNLOCK',
    UnstructuredTargets: 'UNSTRUCTURED_TARGETS',
    SharepointTarget: 'SHAREPOINT_TARGET',
    Provisioning: 'PROVISIONING',
    GroupProvisioning: 'GROUP_PROVISIONING',
    SyncProvisioning: 'SYNC_PROVISIONING',
    Password: 'PASSWORD',
    CurrentPassword: 'CURRENT_PASSWORD',
    AccountOnlyRequest: 'ACCOUNT_ONLY_REQUEST',
    AdditionalAccountRequest: 'ADDITIONAL_ACCOUNT_REQUEST',
    NoAggregation: 'NO_AGGREGATION',
    GroupsHaveMembers: 'GROUPS_HAVE_MEMBERS',
    NoPermissionsProvisioning: 'NO_PERMISSIONS_PROVISIONING',
    NoGroupPermissionsProvisioning: 'NO_GROUP_PERMISSIONS_PROVISIONING',
    NoUnstructuredTargetsProvisioning: 'NO_UNSTRUCTURED_TARGETS_PROVISIONING',
    NoDirectPermissionsProvisioning: 'NO_DIRECT_PERMISSIONS_PROVISIONING',
    PreferUuid: 'PREFER_UUID',
    ArmSecurityExtract: 'ARM_SECURITY_EXTRACT',
    ArmUtilizationExtract: 'ARM_UTILIZATION_EXTRACT',
    ArmChangelogExtract: 'ARM_CHANGELOG_EXTRACT',
    UsesUuid: 'USES_UUID'
};
/**
 * Enum representing the currently supported filter aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.SearchFilterType = {
    Term: 'TERM'
};
exports.SearchScheduleRecipientsInnerTypeEnum = {
    Identity: 'IDENTITY'
};
/**
 * Enum representing the currently supported selector types.  LIST - the *values* array contains one or more distinct values.  RANGE - the *values* array contains two values: the start and end of the range, inclusive.  Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */
exports.SelectorType = {
    List: 'LIST',
    Range: 'RANGE'
};
exports.SendTokenRequestDeliveryTypeEnum = {
    SmsPersonal: 'SMS_PERSONAL',
    VoicePersonal: 'VOICE_PERSONAL',
    SmsWork: 'SMS_WORK',
    VoiceWork: 'VOICE_WORK',
    EmailWork: 'EMAIL_WORK',
    EmailPersonal: 'EMAIL_PERSONAL'
};
exports.SendTokenResponseStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
};
exports.ServiceDeskSourceTypeEnum = {
    Source: 'SOURCE'
};
exports.SlimCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH',
    RoleComposition: 'ROLE_COMPOSITION'
};
exports.SlimCampaignStatusEnum = {
    Pending: 'PENDING',
    Staged: 'STAGED',
    Canceling: 'CANCELING',
    Activating: 'ACTIVATING',
    Active: 'ACTIVE',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Archived: 'ARCHIVED'
};
exports.SlimCampaignCorrelatedStatusEnum = {
    Correlated: 'CORRELATED',
    Uncorrelated: 'UNCORRELATED'
};
exports.SodPolicyStateEnum = {
    Enforced: 'ENFORCED',
    NotEnforced: 'NOT_ENFORCED'
};
exports.SodPolicyTypeEnum = {
    General: 'GENERAL',
    ConflictingAccessBased: 'CONFLICTING_ACCESS_BASED'
};
exports.SodPolicyDtoTypeEnum = {
    SodPolicy: 'SOD_POLICY'
};
exports.SodPolicyOwnerRefTypeEnum = {
    Identity: 'IDENTITY',
    GovernanceGroup: 'GOVERNANCE_GROUP'
};
exports.SodRecipientTypeEnum = {
    Identity: 'IDENTITY'
};
exports.SodReportResultDtoTypeEnum = {
    ReportResult: 'REPORT_RESULT'
};
exports.SodViolationContextCheckCompletedStateEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR',
    Null: 'null'
};
exports.SourceFeaturesEnum = {
    Authenticate: 'AUTHENTICATE',
    Composite: 'COMPOSITE',
    DirectPermissions: 'DIRECT_PERMISSIONS',
    DiscoverSchema: 'DISCOVER_SCHEMA',
    Enable: 'ENABLE',
    ManagerLookup: 'MANAGER_LOOKUP',
    NoRandomAccess: 'NO_RANDOM_ACCESS',
    Proxy: 'PROXY',
    Search: 'SEARCH',
    Template: 'TEMPLATE',
    Unlock: 'UNLOCK',
    UnstructuredTargets: 'UNSTRUCTURED_TARGETS',
    SharepointTarget: 'SHAREPOINT_TARGET',
    Provisioning: 'PROVISIONING',
    GroupProvisioning: 'GROUP_PROVISIONING',
    SyncProvisioning: 'SYNC_PROVISIONING',
    Password: 'PASSWORD',
    CurrentPassword: 'CURRENT_PASSWORD',
    AccountOnlyRequest: 'ACCOUNT_ONLY_REQUEST',
    AdditionalAccountRequest: 'ADDITIONAL_ACCOUNT_REQUEST',
    NoAggregation: 'NO_AGGREGATION',
    GroupsHaveMembers: 'GROUPS_HAVE_MEMBERS',
    NoPermissionsProvisioning: 'NO_PERMISSIONS_PROVISIONING',
    NoGroupPermissionsProvisioning: 'NO_GROUP_PERMISSIONS_PROVISIONING',
    NoUnstructuredTargetsProvisioning: 'NO_UNSTRUCTURED_TARGETS_PROVISIONING',
    NoDirectPermissionsProvisioning: 'NO_DIRECT_PERMISSIONS_PROVISIONING',
    PreferUuid: 'PREFER_UUID',
    ArmSecurityExtract: 'ARM_SECURITY_EXTRACT',
    ArmUtilizationExtract: 'ARM_UTILIZATION_EXTRACT',
    ArmChangelogExtract: 'ARM_CHANGELOG_EXTRACT',
    UsesUuid: 'USES_UUID'
};
exports.SourceStatusEnum = {
    ErrorAccountFileImport: 'SOURCE_STATE_ERROR_ACCOUNT_FILE_IMPORT',
    ErrorCluster: 'SOURCE_STATE_ERROR_CLUSTER',
    ErrorSource: 'SOURCE_STATE_ERROR_SOURCE',
    ErrorVa: 'SOURCE_STATE_ERROR_VA',
    FailureCluster: 'SOURCE_STATE_FAILURE_CLUSTER',
    FailureSource: 'SOURCE_STATE_FAILURE_SOURCE',
    Healthy: 'SOURCE_STATE_HEALTHY',
    UncheckedCluster: 'SOURCE_STATE_UNCHECKED_CLUSTER',
    UncheckedClusterNoSources: 'SOURCE_STATE_UNCHECKED_CLUSTER_NO_SOURCES',
    UncheckedSource: 'SOURCE_STATE_UNCHECKED_SOURCE',
    UncheckedSourceNoAccounts: 'SOURCE_STATE_UNCHECKED_SOURCE_NO_ACCOUNTS'
};
exports.SourceAccountCorrelationConfigTypeEnum = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG'
};
exports.SourceAccountCorrelationRuleTypeEnum = {
    Rule: 'RULE'
};
exports.SourceBeforeProvisioningRuleTypeEnum = {
    Rule: 'RULE'
};
exports.SourceClusterTypeEnum = {
    Cluster: 'CLUSTER'
};
exports.SourceClusterDtoTypeEnum = {
    Cluster: 'CLUSTER'
};
exports.SourceHealthDtoStatusEnum = {
    ErrorCluster: 'SOURCE_STATE_ERROR_CLUSTER',
    ErrorSource: 'SOURCE_STATE_ERROR_SOURCE',
    ErrorVa: 'SOURCE_STATE_ERROR_VA',
    FailureCluster: 'SOURCE_STATE_FAILURE_CLUSTER',
    FailureSource: 'SOURCE_STATE_FAILURE_SOURCE',
    Healthy: 'SOURCE_STATE_HEALTHY',
    UncheckedCluster: 'SOURCE_STATE_UNCHECKED_CLUSTER',
    UncheckedClusterNoSources: 'SOURCE_STATE_UNCHECKED_CLUSTER_NO_SOURCES',
    UncheckedSource: 'SOURCE_STATE_UNCHECKED_SOURCE',
    UncheckedSourceNoAccounts: 'SOURCE_STATE_UNCHECKED_SOURCE_NO_ACCOUNTS'
};
exports.SourceManagementWorkgroupTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP'
};
exports.SourceManagerCorrelationRuleTypeEnum = {
    Rule: 'RULE'
};
exports.SourceOwnerTypeEnum = {
    Identity: 'IDENTITY'
};
exports.SourcePasswordPoliciesInnerTypeEnum = {
    PasswordPolicy: 'PASSWORD_POLICY'
};
exports.SourceSchemasInnerTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
};
exports.SourceUsageStatusStatusEnum = {
    Complete: 'COMPLETE',
    Incomplete: 'INCOMPLETE'
};
exports.SpDetailsRoleEnum = {
    SamlSp: 'SAML_SP'
};
exports.SpDetailsAllOfRoleEnum = {
    SamlSp: 'SAML_SP'
};
/**
 * Standard Log4j log level
 * @export
 * @enum {string}
 */
exports.StandardLevel = {
    False: 'false',
    Fatal: 'FATAL',
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO',
    Debug: 'DEBUG',
    Trace: 'TRACE'
};
exports.TaggedObjectDtoTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    Entitlement: 'ENTITLEMENT',
    Identity: 'IDENTITY',
    Role: 'ROLE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE'
};
exports.TaskResultDetailsTypeEnum = {
    Quartz: 'QUARTZ',
    Qpoc: 'QPOC',
    Mentos: 'MENTOS',
    QueuedTask: 'QUEUED_TASK'
};
exports.TaskResultDetailsReportTypeEnum = {
    Accounts: 'ACCOUNTS',
    IdentitiesDetails: 'IDENTITIES_DETAILS',
    Identities: 'IDENTITIES',
    IdentityProfileIdentityError: 'IDENTITY_PROFILE_IDENTITY_ERROR',
    OrphanIdentities: 'ORPHAN_IDENTITIES',
    SearchExport: 'SEARCH_EXPORT',
    UncorrelatedAccounts: 'UNCORRELATED_ACCOUNTS'
};
exports.TaskResultDetailsCompletionStatusEnum = {
    Success: 'SUCCESS',
    Warning: 'WARNING',
    Error: 'ERROR',
    Terminated: 'TERMINATED',
    TempError: 'TEMP_ERROR'
};
exports.TaskResultDetailsMessagesInnerTypeEnum = {
    Info: 'INFO',
    Warn: 'WARN',
    Error: 'ERROR'
};
exports.TaskResultDtoTypeEnum = {
    TaskResult: 'TASK_RESULT'
};
exports.TaskResultSimplifiedCompletionStatusEnum = {
    Success: 'Success',
    Warning: 'Warning',
    Error: 'Error',
    Terminated: 'Terminated',
    TempError: 'TempError'
};
exports.TokenAuthRequestDeliveryTypeEnum = {
    SmsPersonal: 'SMS_PERSONAL',
    VoicePersonal: 'VOICE_PERSONAL',
    SmsWork: 'SMS_WORK',
    VoiceWork: 'VOICE_WORK',
    EmailWork: 'EMAIL_WORK',
    EmailPersonal: 'EMAIL_PERSONAL'
};
exports.TokenAuthResponseStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Lockout: 'LOCKOUT',
    NotEnoughData: 'NOT_ENOUGH_DATA'
};
exports.TransformTypeEnum = {
    AccountAttribute: 'accountAttribute',
    Base64Decode: 'base64Decode',
    Base64Encode: 'base64Encode',
    Concat: 'concat',
    Conditional: 'conditional',
    DateCompare: 'dateCompare',
    DateFormat: 'dateFormat',
    DateMath: 'dateMath',
    DecomposeDiacriticalMarks: 'decomposeDiacriticalMarks',
    E164phone: 'e164phone',
    FirstValid: 'firstValid',
    Rule: 'rule',
    IdentityAttribute: 'identityAttribute',
    IndexOf: 'indexOf',
    Iso3166: 'iso3166',
    LastIndexOf: 'lastIndexOf',
    LeftPad: 'leftPad',
    Lookup: 'lookup',
    Lower: 'lower',
    NormalizeNames: 'normalizeNames',
    RandomAlphaNumeric: 'randomAlphaNumeric',
    RandomNumeric: 'randomNumeric',
    Reference: 'reference',
    ReplaceAll: 'replaceAll',
    Replace: 'replace',
    RightPad: 'rightPad',
    Split: 'split',
    Static: 'static',
    Substring: 'substring',
    Trim: 'trim',
    Upper: 'upper',
    UsernameGenerator: 'usernameGenerator',
    Uuid: 'uuid',
    DisplayName: 'displayName',
    Rfc5646: 'rfc5646'
};
exports.TransformReadTypeEnum = {
    AccountAttribute: 'accountAttribute',
    Base64Decode: 'base64Decode',
    Base64Encode: 'base64Encode',
    Concat: 'concat',
    Conditional: 'conditional',
    DateCompare: 'dateCompare',
    DateFormat: 'dateFormat',
    DateMath: 'dateMath',
    DecomposeDiacriticalMarks: 'decomposeDiacriticalMarks',
    E164phone: 'e164phone',
    FirstValid: 'firstValid',
    Rule: 'rule',
    IdentityAttribute: 'identityAttribute',
    IndexOf: 'indexOf',
    Iso3166: 'iso3166',
    LastIndexOf: 'lastIndexOf',
    LeftPad: 'leftPad',
    Lookup: 'lookup',
    Lower: 'lower',
    NormalizeNames: 'normalizeNames',
    RandomAlphaNumeric: 'randomAlphaNumeric',
    RandomNumeric: 'randomNumeric',
    Reference: 'reference',
    ReplaceAll: 'replaceAll',
    Replace: 'replace',
    RightPad: 'rightPad',
    Split: 'split',
    Static: 'static',
    Substring: 'substring',
    Trim: 'trim',
    Upper: 'upper',
    UsernameGenerator: 'usernameGenerator',
    Uuid: 'uuid',
    DisplayName: 'displayName',
    Rfc5646: 'rfc5646'
};
exports.UpdateDetailStatusEnum = {
    Error: 'ERROR',
    Updated: 'UPDATED',
    Unchanged: 'UNCHANGED',
    Skipped: 'SKIPPED'
};
exports.UploadsRequestStatusEnum = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Complete: 'COMPLETE',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED'
};
exports.UploadsRequestTypeEnum = {
    Backup: 'BACKUP',
    Draft: 'DRAFT'
};
exports.UploadsRequestBackupTypeEnum = {
    Uploaded: 'UPLOADED',
    Automated: 'AUTOMATED',
    Manual: 'MANUAL'
};
exports.UploadsRequestHydrationStatusEnum = {
    Hydrated: 'HYDRATED',
    NotHydrated: 'NOT_HYDRATED'
};
exports.UploadsResponseStatusEnum = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Complete: 'COMPLETE',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED'
};
exports.UploadsResponseTypeEnum = {
    Backup: 'BACKUP',
    Draft: 'DRAFT'
};
exports.UploadsResponseBackupTypeEnum = {
    Uploaded: 'UPLOADED',
    Automated: 'AUTOMATED',
    Manual: 'MANUAL'
};
exports.UploadsResponseHydrationStatusEnum = {
    Hydrated: 'HYDRATED',
    NotHydrated: 'NOT_HYDRATED'
};
/**
 * The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \'Create Account Profile\', the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \'Update Account Profile\', the provisioning template for the \'Update\' connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \'Enable Account Profile\', the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\'s account is created.  DISABLE - This usage type relates to \'Disable Account Profile\', the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
 * @export
 * @enum {string}
 */
exports.UsageType = {
    Create: 'CREATE',
    Update: 'UPDATE',
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    Delete: 'DELETE',
    Assign: 'ASSIGN',
    Unassign: 'UNASSIGN',
    CreateGroup: 'CREATE_GROUP',
    UpdateGroup: 'UPDATE_GROUP',
    DeleteGroup: 'DELETE_GROUP',
    Register: 'REGISTER',
    CreateIdentity: 'CREATE_IDENTITY',
    UpdateIdentity: 'UPDATE_IDENTITY',
    EditGroup: 'EDIT_GROUP',
    Unlock: 'UNLOCK',
    ChangePassword: 'CHANGE_PASSWORD'
};
exports.V3ConnectorDtoStatusEnum = {
    Deprecated: 'DEPRECATED',
    Development: 'DEVELOPMENT',
    Demo: 'DEMO',
    Released: 'RELEASED'
};
exports.V3CreateConnectorDtoStatusEnum = {
    Development: 'DEVELOPMENT',
    Demo: 'DEMO',
    Released: 'RELEASED'
};
exports.VerificationResponseStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Lockout: 'LOCKOUT',
    NotEnoughData: 'NOT_ENOUGH_DATA'
};
exports.ViolationContextPolicyTypeEnum = {
    Entitlement: 'ENTITLEMENT'
};
exports.ViolationOwnerAssignmentConfigAssignmentRuleEnum = {
    Manager: 'MANAGER',
    Static: 'STATIC',
    Null: 'null'
};
exports.ViolationOwnerAssignmentConfigOwnerRefTypeEnum = {
    Identity: 'IDENTITY',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Manager: 'MANAGER',
    Null: 'null'
};
/**
 * The state of a work item
 * @export
 * @enum {string}
 */
exports.WorkItemState = {
    Finished: 'Finished',
    Rejected: 'Rejected',
    Returned: 'Returned',
    Expired: 'Expired',
    Pending: 'Pending',
    Canceled: 'Canceled',
    Null: 'null'
};
/**
 * The state of a work item
 * @export
 * @enum {string}
 */
exports.WorkItemStateManualWorkItems = {
    Finished: 'Finished',
    Rejected: 'Rejected',
    Returned: 'Returned',
    Expired: 'Expired',
    Pending: 'Pending',
    Canceled: 'Canceled'
};
/**
 * The type of the work item
 * @export
 * @enum {string}
 */
exports.WorkItemTypeManualWorkItems = {
    Generic: 'Generic',
    Certification: 'Certification',
    Remediation: 'Remediation',
    Delegation: 'Delegation',
    Approval: 'Approval',
    ViolationReview: 'ViolationReview',
    Form: 'Form',
    PolicyVioloation: 'PolicyVioloation',
    Challenge: 'Challenge',
    ImpactAnalysis: 'ImpactAnalysis',
    Signoff: 'Signoff',
    Event: 'Event',
    ManualAction: 'ManualAction',
    Test: 'Test'
};
exports.WorkflowAllOfCreatorTypeEnum = {
    Identity: 'IDENTITY'
};
exports.WorkflowBodyOwnerTypeEnum = {
    Identity: 'IDENTITY'
};
exports.WorkflowExecutionStatusEnum = {
    Completed: 'Completed',
    Failed: 'Failed',
    Canceled: 'Canceled',
    Executing: 'Executing'
};
exports.WorkflowExecutionEventTypeEnum = {
    WorkflowExecutionScheduled: 'WorkflowExecutionScheduled',
    WorkflowExecutionStarted: 'WorkflowExecutionStarted',
    WorkflowExecutionCompleted: 'WorkflowExecutionCompleted',
    WorkflowExecutionFailed: 'WorkflowExecutionFailed',
    WorkflowTaskScheduled: 'WorkflowTaskScheduled',
    WorkflowTaskStarted: 'WorkflowTaskStarted',
    WorkflowTaskCompleted: 'WorkflowTaskCompleted',
    WorkflowTaskFailed: 'WorkflowTaskFailed',
    ActivityTaskScheduled: 'ActivityTaskScheduled',
    ActivityTaskStarted: 'ActivityTaskStarted',
    ActivityTaskCompleted: 'ActivityTaskCompleted',
    ActivityTaskFailed: 'ActivityTaskFailed'
};
exports.WorkflowLibraryFormFieldsTypeEnum = {
    Text: 'text',
    Textarea: 'textarea',
    Boolean: 'boolean',
    Email: 'email',
    Url: 'url',
    Number: 'number',
    Json: 'json',
    Checkbox: 'checkbox',
    Jsonpath: 'jsonpath',
    Select: 'select',
    MultiType: 'multiType',
    Duration: 'duration',
    Toggle: 'toggle',
    FormPicker: 'formPicker',
    IdentityPicker: 'identityPicker',
    GovernanceGroupPicker: 'governanceGroupPicker',
    String: 'string',
    Object: 'object',
    Array: 'array',
    Secret: 'secret',
    KeyValuePairs: 'keyValuePairs',
    EmailPicker: 'emailPicker',
    AdvancedToggle: 'advancedToggle',
    VariableCreator: 'variableCreator',
    HtmlEditor: 'htmlEditor'
};
exports.WorkflowLibraryTriggerTypeEnum = {
    Event: 'EVENT',
    Scheduled: 'SCHEDULED',
    External: 'EXTERNAL'
};
exports.WorkflowModifiedByTypeEnum = {
    Identity: 'IDENTITY'
};
exports.WorkflowTriggerTypeEnum = {
    Event: 'EVENT',
    External: 'EXTERNAL',
    Scheduled: 'SCHEDULED'
};
/**
 * AccessProfilesApi - axios parameter creator
 * @export
 */
var AccessProfilesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Use this API to create an access profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
         * @summary Create Access Profile
         * @param {AccessProfile} accessProfile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile: function (accessProfile, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'accessProfile' is not null or undefined
                            (0, common_1.assertParamExists)('createAccessProfile', 'accessProfile', accessProfile);
                            localVarPath = "/access-profiles";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accessProfile, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfile: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteAccessProfile', 'id', id);
                            localVarPath = "/access-profiles/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this endpoint. In addition, a SOURCE_SUBADMIN can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk: function (accessProfileBulkDeleteRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'accessProfileBulkDeleteRequest' is not null or undefined
                            (0, common_1.assertParamExists)('deleteAccessProfilesInBulk', 'accessProfileBulkDeleteRequest', accessProfileBulkDeleteRequest);
                            localVarPath = "/access-profiles/bulk-delete";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accessProfileBulkDeleteRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getAccessProfile', 'id', id);
                            localVarPath = "/access-profiles/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to get a list of an access profile\'s entitlements.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the source associated with the specified access profile. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank.
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the access profile containing the entitlements.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getAccessProfileEntitlements', 'id', id);
                            localVarPath = "/access-profiles/{id}/entitlements"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to get a list of access profiles. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN identity. The value of the parameter is either an identity ID, or the special value **me**, which is shorthand for the calling identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters access profiles to those which are assigned to the segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Indicates whether the response list should contain unsegmented access profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles: function (forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/access-profiles";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (forSubadmin !== undefined) {
                                localVarQueryParameter['for-subadmin'] = forSubadmin;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            if (forSegmentIds !== undefined) {
                                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
                            }
                            if (includeUnsegmented !== undefined) {
                                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchAccessProfile', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchAccessProfile', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/access-profiles/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.AccessProfilesApiAxiosParamCreator = AccessProfilesApiAxiosParamCreator;
/**
 * AccessProfilesApi - functional programming interface
 * @export
 */
var AccessProfilesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AccessProfilesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Use this API to create an access profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
         * @summary Create Access Profile
         * @param {AccessProfile} accessProfile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile: function (accessProfile, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createAccessProfile(accessProfile, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfile: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteAccessProfile(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this endpoint. In addition, a SOURCE_SUBADMIN can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk: function (accessProfileBulkDeleteRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAccessProfile(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to get a list of an access profile\'s entitlements.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the source associated with the specified access profile. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank.
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the access profile containing the entitlements.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAccessProfileEntitlements(id, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to get a list of access profiles. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN identity. The value of the parameter is either an identity ID, or the special value **me**, which is shorthand for the calling identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters access profiles to those which are assigned to the segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Indicates whether the response list should contain unsegmented access profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles: function (forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listAccessProfiles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchAccessProfile(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AccessProfilesApiFp = AccessProfilesApiFp;
/**
 * AccessProfilesApi - factory interface
 * @export
 */
var AccessProfilesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AccessProfilesApiFp)(configuration);
    return {
        /**
         * Use this API to create an access profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
         * @summary Create Access Profile
         * @param {AccessProfile} accessProfile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessProfile: function (accessProfile, axiosOptions) {
            return localVarFp.createAccessProfile(accessProfile, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
         * @summary Delete the specified Access Profile
         * @param {string} id ID of the Access Profile to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfile: function (id, axiosOptions) {
            return localVarFp.deleteAccessProfile(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this endpoint. In addition, a SOURCE_SUBADMIN can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
         * @summary Delete Access Profile(s)
         * @param {AccessProfileBulkDeleteRequest} accessProfileBulkDeleteRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessProfilesInBulk: function (accessProfileBulkDeleteRequest, axiosOptions) {
            return localVarFp.deleteAccessProfilesInBulk(accessProfileBulkDeleteRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get an Access Profile
         * @param {string} id ID of the Access Profile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfile: function (id, axiosOptions) {
            return localVarFp.getAccessProfile(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to get a list of an access profile\'s entitlements.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the source associated with the specified access profile. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank.
         * @summary List Access Profile\'s Entitlements
         * @param {string} id ID of the access profile containing the entitlements.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **attribute**: *eq, sw*  **value**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **source.id**: *eq, in*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, attribute, value, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessProfileEntitlements: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.getAccessProfileEntitlements(id, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to get a list of access profiles. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank.
         * @summary List Access Profiles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN or SOURCE_SUBADMIN identity. The value of the parameter is either an identity ID, or the special value **me**, which is shorthand for the calling identity\&#39;s ID.  A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*  **source.id**: *eq, in*  Composite operators supported: *and, or*  Filtering is not supported for access profiles and entitlements that have the \&#39;+\&#39; symbol in their names.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters access profiles to those which are assigned to the segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Indicates whether the response list should contain unsegmented access profiles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessProfiles: function (forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions) {
            return localVarFp.listAccessProfiles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
         * @summary Patch a specified Access Profile
         * @param {string} id ID of the Access Profile to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessProfile: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchAccessProfile(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AccessProfilesApiFactory = AccessProfilesApiFactory;
/**
 * AccessProfilesApi - object-oriented interface
 * @export
 * @class AccessProfilesApi
 * @extends {BaseAPI}
 */
var AccessProfilesApi = /** @class */ (function (_super) {
    __extends(AccessProfilesApi, _super);
    function AccessProfilesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this API to create an access profile. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with only ROLE_SUBADMIN or SOURCE_SUBADMIN authority must be associated with the access profile\'s Source. The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles. However, any new access profiles as well as any updates to existing descriptions are limited to 2000 characters.
     * @summary Create Access Profile
     * @param {AccessProfilesApiCreateAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    AccessProfilesApi.prototype.createAccessProfile = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessProfilesApiFp)(this.configuration).createAccessProfile(requestParameters.accessProfile, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API deletes an existing Access Profile.  The Access Profile must not be in use, for example, Access Profile can not be deleted if they belong to an Application, Life Cycle State or a Role. If it is, a 400 error is returned.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to invoke this API. In addition, a SOURCE_SUBADMIN token must be able to administer the Source associated with the Access Profile.
     * @summary Delete the specified Access Profile
     * @param {AccessProfilesApiDeleteAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    AccessProfilesApi.prototype.deleteAccessProfile = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessProfilesApiFp)(this.configuration).deleteAccessProfile(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint initiates a bulk deletion of one or more access profiles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 access profiles per request.  By default, if any of the indicated access profiles are in use, no deletions will be performed and the **inUse** field of the response indicates the usages that must be removed first. If the request field **bestEffortOnly** is **true**, however, usages are reported in the **inUse** response field but all other indicated access profiles will be deleted. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this endpoint. In addition, a SOURCE_SUBADMIN can only use this endpoint to delete access profiles associated with sources they\'re able to administer.
     * @summary Delete Access Profile(s)
     * @param {AccessProfilesApiDeleteAccessProfilesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    AccessProfilesApi.prototype.deleteAccessProfilesInBulk = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessProfilesApiFp)(this.configuration).deleteAccessProfilesInBulk(requestParameters.accessProfileBulkDeleteRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns an Access Profile by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get an Access Profile
     * @param {AccessProfilesApiGetAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    AccessProfilesApi.prototype.getAccessProfile = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessProfilesApiFp)(this.configuration).getAccessProfile(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to get a list of an access profile\'s entitlements.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a token with SOURCE_SUBADMIN authority must have access to the source associated with the specified access profile. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank.
     * @summary List Access Profile\'s Entitlements
     * @param {AccessProfilesApiGetAccessProfileEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    AccessProfilesApi.prototype.getAccessProfileEntitlements = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessProfilesApiFp)(this.configuration).getAccessProfileEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to get a list of access profiles. A token with API, ORG_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**Note:** When you filter for access profiles that have the \'+\' symbol in their names, the response is blank.
     * @summary List Access Profiles
     * @param {AccessProfilesApiListAccessProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    AccessProfilesApi.prototype.listAccessProfiles = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.AccessProfilesApiFp)(this.configuration).listAccessProfiles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API updates an existing Access Profile. The following fields are patchable:  **name**  **description**  **enabled**  **owner**  **requestable**  **accessRequestConfig**  **revokeRequestConfig**  **segments**  **entitlements**  **provisioningCriteria**  **source** (must be updated with entitlements belonging to new source in the same API call)  If you need to change the `source` of the access profile, you can do so only if you update the `entitlements` in the same API call.  The new entitlements can only come from the target source that you want to change to.  Look for the example \"Replace Source\" in the examples dropdown.  A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. In addition, a SOURCE_SUBADMIN may only use this API to patch Access Profiles which are associated with Sources they are able to administer. >  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing access profiles, however, any new access profiles as well as any updates to existing descriptions will be limited to 2000 characters.  > You can only add or replace **entitlements** that exist on the source that the access profile is attached to. You can use the **list entitlements** endpoint with the **filters** query parameter to get a list of available entitlements on the access profile\'s source.
     * @summary Patch a specified Access Profile
     * @param {AccessProfilesApiPatchAccessProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessProfilesApi
     */
    AccessProfilesApi.prototype.patchAccessProfile = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessProfilesApiFp)(this.configuration).patchAccessProfile(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AccessProfilesApi;
}(base_1.BaseAPI));
exports.AccessProfilesApi = AccessProfilesApi;
/**
 * AccessRequestApprovalsApi - axios parameter creator
 * @export
 */
var AccessRequestApprovalsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approve Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest: function (approvalId, commentDto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'approvalId' is not null or undefined
                            (0, common_1.assertParamExists)('approveAccessRequest', 'approvalId', approvalId);
                            // verify required parameter 'commentDto' is not null or undefined
                            (0, common_1.assertParamExists)('approveAccessRequest', 'commentDto', commentDto);
                            localVarPath = "/access-request-approvals/{approvalId}/approve"
                                .replace("{".concat("approvalId", "}"), encodeURIComponent(String(approvalId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(commentDto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forward Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest: function (approvalId, forwardApprovalDto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'approvalId' is not null or undefined
                            (0, common_1.assertParamExists)('forwardAccessRequest', 'approvalId', approvalId);
                            // verify required parameter 'forwardApprovalDto' is not null or undefined
                            (0, common_1.assertParamExists)('forwardAccessRequest', 'forwardApprovalDto', forwardApprovalDto);
                            localVarPath = "/access-request-approvals/{approvalId}/forward"
                                .replace("{".concat("approvalId", "}"), encodeURIComponent(String(approvalId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(forwardApprovalDto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
         * @summary Get Access Requests Approvals Number
         * @param {string} [ownerId] The ID of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] This is the date and time the results will be shown from. It must be in a valid ISO-8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary: function (ownerId, fromDate, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/access-request-approvals/approval-summary";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (ownerId !== undefined) {
                                localVarQueryParameter['owner-id'] = ownerId;
                            }
                            if (fromDate !== undefined) {
                                localVarQueryParameter['from-date'] = fromDate;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals: function (ownerId, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/access-request-approvals/completed";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (ownerId !== undefined) {
                                localVarQueryParameter['owner-id'] = ownerId;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals: function (ownerId, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/access-request-approvals/pending";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (ownerId !== undefined) {
                                localVarQueryParameter['owner-id'] = ownerId;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Reject Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest: function (approvalId, commentDto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'approvalId' is not null or undefined
                            (0, common_1.assertParamExists)('rejectAccessRequest', 'approvalId', approvalId);
                            // verify required parameter 'commentDto' is not null or undefined
                            (0, common_1.assertParamExists)('rejectAccessRequest', 'commentDto', commentDto);
                            localVarPath = "/access-request-approvals/{approvalId}/reject"
                                .replace("{".concat("approvalId", "}"), encodeURIComponent(String(approvalId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(commentDto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.AccessRequestApprovalsApiAxiosParamCreator = AccessRequestApprovalsApiAxiosParamCreator;
/**
 * AccessRequestApprovalsApi - functional programming interface
 * @export
 */
var AccessRequestApprovalsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AccessRequestApprovalsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approve Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest: function (approvalId, commentDto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.approveAccessRequest(approvalId, commentDto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forward Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest: function (approvalId, forwardApprovalDto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.forwardAccessRequest(approvalId, forwardApprovalDto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
         * @summary Get Access Requests Approvals Number
         * @param {string} [ownerId] The ID of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] This is the date and time the results will be shown from. It must be in a valid ISO-8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary: function (ownerId, fromDate, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAccessRequestApprovalSummary(ownerId, fromDate, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals: function (ownerId, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals: function (ownerId, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Reject Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest: function (approvalId, commentDto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.rejectAccessRequest(approvalId, commentDto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AccessRequestApprovalsApiFp = AccessRequestApprovalsApiFp;
/**
 * AccessRequestApprovalsApi - factory interface
 * @export
 */
var AccessRequestApprovalsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AccessRequestApprovalsApiFp)(configuration);
    return {
        /**
         * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approve Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveAccessRequest: function (approvalId, commentDto, axiosOptions) {
            return localVarFp.approveAccessRequest(approvalId, commentDto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forward Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardAccessRequest: function (approvalId, forwardApprovalDto, axiosOptions) {
            return localVarFp.forwardAccessRequest(approvalId, forwardApprovalDto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
         * @summary Get Access Requests Approvals Number
         * @param {string} [ownerId] The ID of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] This is the date and time the results will be shown from. It must be in a valid ISO-8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestApprovalSummary: function (ownerId, fromDate, axiosOptions) {
            return localVarFp.getAccessRequestApprovalSummary(ownerId, fromDate, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **requestedFor.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals: function (ownerId, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le, eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals: function (ownerId, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Reject Access Request Approval
         * @param {string} approvalId Approval ID.
         * @param {CommentDto} commentDto Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectAccessRequest: function (approvalId, commentDto, axiosOptions) {
            return localVarFp.rejectAccessRequest(approvalId, commentDto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AccessRequestApprovalsApiFactory = AccessRequestApprovalsApiFactory;
/**
 * AccessRequestApprovalsApi - object-oriented interface
 * @export
 * @class AccessRequestApprovalsApi
 * @extends {BaseAPI}
 */
var AccessRequestApprovalsApi = /** @class */ (function (_super) {
    __extends(AccessRequestApprovalsApi, _super);
    function AccessRequestApprovalsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this endpoint to approve an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Approve Access Request Approval
     * @param {AccessRequestApprovalsApiApproveAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    AccessRequestApprovalsApi.prototype.approveAccessRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessRequestApprovalsApiFp)(this.configuration).approveAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to forward an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Forward Access Request Approval
     * @param {AccessRequestApprovalsApiForwardAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    AccessRequestApprovalsApi.prototype.forwardAccessRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessRequestApprovalsApiFp)(this.configuration).forwardAccessRequest(requestParameters.approvalId, requestParameters.forwardApprovalDto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to return the number of pending, approved and rejected access requests approvals. See the \"owner-id\" query parameter for authorization information. info.
     * @summary Get Access Requests Approvals Number
     * @param {AccessRequestApprovalsApiGetAccessRequestApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    AccessRequestApprovalsApi.prototype.getAccessRequestApprovalSummary = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.AccessRequestApprovalsApiFp)(this.configuration).getAccessRequestApprovalSummary(requestParameters.ownerId, requestParameters.fromDate, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
     * @summary Completed Access Request Approvals List
     * @param {AccessRequestApprovalsApiListCompletedApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    AccessRequestApprovalsApi.prototype.listCompletedApprovals = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.AccessRequestApprovalsApiFp)(this.configuration).listCompletedApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Pending Access Request Approvals List
     * @param {AccessRequestApprovalsApiListPendingApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    AccessRequestApprovalsApi.prototype.listPendingApprovals = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.AccessRequestApprovalsApiFp)(this.configuration).listPendingApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to reject an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
     * @summary Reject Access Request Approval
     * @param {AccessRequestApprovalsApiRejectAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    AccessRequestApprovalsApi.prototype.rejectAccessRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessRequestApprovalsApiFp)(this.configuration).rejectAccessRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AccessRequestApprovalsApi;
}(base_1.BaseAPI));
exports.AccessRequestApprovalsApi = AccessRequestApprovalsApi;
/**
 * AccessRequestsApi - axios parameter creator
 * @export
 */
var AccessRequestsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest: function (cancelAccessRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'cancelAccessRequest' is not null or undefined
                            (0, common_1.assertParamExists)('cancelAccessRequest', 'cancelAccessRequest', cancelAccessRequest);
                            localVarPath = "/access-requests/cancel";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(cancelAccessRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  A token with API authority cannot be used to call this endpoint.
         * @summary Submit Access Request
         * @param {AccessRequest} accessRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest: function (accessRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'accessRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createAccessRequest', 'accessRequest', accessRequest);
                            localVarPath = "/access-requests";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accessRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/access-request-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity the requests were made for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity twho made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity who is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [assignedTo] Filter the results by the specified identity who is the owner of the Identity Request Work Item. *me* indicates the current user.
         * @param {boolean} [count] If this is true, the *X-Total-Count* response header populates with the number of results that would be returned if limit and offset were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus: function (requestedFor, requestedBy, regardingIdentity, assignedTo, count, limit, offset, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/access-request-status";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (requestedFor !== undefined) {
                                localVarQueryParameter['requested-for'] = requestedFor;
                            }
                            if (requestedBy !== undefined) {
                                localVarQueryParameter['requested-by'] = requestedBy;
                            }
                            if (regardingIdentity !== undefined) {
                                localVarQueryParameter['regarding-identity'] = regardingIdentity;
                            }
                            if (assignedTo !== undefined) {
                                localVarQueryParameter['assigned-to'] = assignedTo;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setAccessRequestConfig: function (accessRequestConfig, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'accessRequestConfig' is not null or undefined
                            (0, common_1.assertParamExists)('setAccessRequestConfig', 'accessRequestConfig', accessRequestConfig);
                            localVarPath = "/access-request-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accessRequestConfig, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.AccessRequestsApiAxiosParamCreator = AccessRequestsApiAxiosParamCreator;
/**
 * AccessRequestsApi - functional programming interface
 * @export
 */
var AccessRequestsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AccessRequestsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest: function (cancelAccessRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.cancelAccessRequest(cancelAccessRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  A token with API authority cannot be used to call this endpoint.
         * @summary Submit Access Request
         * @param {AccessRequest} accessRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest: function (accessRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createAccessRequest(accessRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAccessRequestConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity the requests were made for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity twho made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity who is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [assignedTo] Filter the results by the specified identity who is the owner of the Identity Request Work Item. *me* indicates the current user.
         * @param {boolean} [count] If this is true, the *X-Total-Count* response header populates with the number of results that would be returned if limit and offset were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus: function (requestedFor, requestedBy, regardingIdentity, assignedTo, count, limit, offset, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, assignedTo, count, limit, offset, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setAccessRequestConfig: function (accessRequestConfig, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setAccessRequestConfig(accessRequestConfig, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AccessRequestsApiFp = AccessRequestsApiFp;
/**
 * AccessRequestsApi - factory interface
 * @export
 */
var AccessRequestsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AccessRequestsApiFp)(configuration);
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest: function (cancelAccessRequest, axiosOptions) {
            return localVarFp.cancelAccessRequest(cancelAccessRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  A token with API authority cannot be used to call this endpoint.
         * @summary Submit Access Request
         * @param {AccessRequest} accessRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest: function (accessRequest, axiosOptions) {
            return localVarFp.createAccessRequest(accessRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig: function (axiosOptions) {
            return localVarFp.getAccessRequestConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity the requests were made for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity twho made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity who is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {string} [assignedTo] Filter the results by the specified identity who is the owner of the Identity Request Work Item. *me* indicates the current user.
         * @param {boolean} [count] If this is true, the *X-Total-Count* response header populates with the number of results that would be returned if limit and offset were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in, ge, gt, le, lt, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId, name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus: function (requestedFor, requestedBy, regardingIdentity, assignedTo, count, limit, offset, filters, sorters, axiosOptions) {
            return localVarFp.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, assignedTo, count, limit, offset, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setAccessRequestConfig: function (accessRequestConfig, axiosOptions) {
            return localVarFp.setAccessRequestConfig(accessRequestConfig, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AccessRequestsApiFactory = AccessRequestsApiFactory;
/**
 * AccessRequestsApi - object-oriented interface
 * @export
 * @class AccessRequestsApi
 * @extends {BaseAPI}
 */
var AccessRequestsApi = /** @class */ (function (_super) {
    __extends(AccessRequestsApi, _super);
    function AccessRequestsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
     * @summary Cancel Access Request
     * @param {AccessRequestsApiCancelAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    AccessRequestsApi.prototype.cancelAccessRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessRequestsApiFp)(this.configuration).cancelAccessRequest(requestParameters.cancelAccessRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to submit an access request in Identity Security Cloud (ISC), where it follows any ISC approval processes.  Access requests are processed asynchronously by ISC. A successful response from this endpoint means that the request has been submitted to ISC and is queued for processing. Because this endpoint is asynchronous, it doesn\'t return an error if you submit duplicate access requests in quick succession or submit an access request for access that is already in progress, approved, or rejected.  It\'s best practice to check for any existing access requests that reference the same access items before submitting a new access request. This can be accomplished by using the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [Pending Access Request Approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) APIs. You can also use the [Search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items an identity has before submitting an access request to ensure that you aren\'t requesting access that is already granted. If you use this API to request access that an identity already has, the API will ignore the request.  These ignored requests do not display when you use the [List Access Request Status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) API.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users. Refer to the [Get Access Request Configuration](https://developer.sailpoint.com/idn/api/v3/get-access-request-config) endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, access profiles and entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * You cannot use an access request to revoke access from an identity if that access has been granted by role membership or by birthright provisioning.  * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If a `removeDate` is specified, then the access will be removed on that date and time only for roles, access profiles and entitlements. * Roles, access profiles, and entitlements can be requested for revocation. * Revoke requests for entitlements are limited to 1 entitlement per access request currently. * You can specify a `removeDate` if the access doesn\'t already have a sunset date. The `removeDate` must be a future date, in the UTC timezone.  * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone.  A token with API authority cannot be used to call this endpoint.
     * @summary Submit Access Request
     * @param {AccessRequestsApiCreateAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    AccessRequestsApi.prototype.createAccessRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessRequestsApiFp)(this.configuration).createAccessRequest(requestParameters.accessRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint returns the current access-request configuration.
     * @summary Get Access Request Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    AccessRequestsApi.prototype.getAccessRequestConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.AccessRequestsApiFp)(this.configuration).getAccessRequestConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to return a list of access request statuses based on the specified query parameters. If an access request was made for access that an identity already has, the API ignores the access request.  These ignored requests do not display in the list of access request statuses. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
     * @summary Access Request Status
     * @param {AccessRequestsApiListAccessRequestStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    AccessRequestsApi.prototype.listAccessRequestStatus = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.AccessRequestsApiFp)(this.configuration).listAccessRequestStatus(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.assignedTo, requestParameters.count, requestParameters.limit, requestParameters.offset, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Access Request Configuration
     * @param {AccessRequestsApiSetAccessRequestConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    AccessRequestsApi.prototype.setAccessRequestConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccessRequestsApiFp)(this.configuration).setAccessRequestConfig(requestParameters.accessRequestConfig, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AccessRequestsApi;
}(base_1.BaseAPI));
exports.AccessRequestsApi = AccessRequestsApi;
/**
 * AccountActivitiesApi - axios parameter creator
 * @export
 */
var AccountActivitiesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getAccountActivity', 'id', id);
                            localVarPath = "/account-activities/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities: function (requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/account-activities";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (requestedFor !== undefined) {
                                localVarQueryParameter['requested-for'] = requestedFor;
                            }
                            if (requestedBy !== undefined) {
                                localVarQueryParameter['requested-by'] = requestedBy;
                            }
                            if (regardingIdentity !== undefined) {
                                localVarQueryParameter['regarding-identity'] = regardingIdentity;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.AccountActivitiesApiAxiosParamCreator = AccountActivitiesApiAxiosParamCreator;
/**
 * AccountActivitiesApi - functional programming interface
 * @export
 */
var AccountActivitiesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AccountActivitiesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAccountActivity(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities: function (requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listAccountActivities(requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AccountActivitiesApiFp = AccountActivitiesApiFp;
/**
 * AccountActivitiesApi - factory interface
 * @export
 */
var AccountActivitiesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AccountActivitiesApiFp)(configuration);
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity: function (id, axiosOptions) {
            return localVarFp.getAccountActivity(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **type**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **created**: *gt, lt, ge, le, eq, in, ne, isnull, sw*  **modified**: *gt, lt, ge, le, eq, in, ne, isnull, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities: function (requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.listAccountActivities(requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AccountActivitiesApiFactory = AccountActivitiesApiFactory;
/**
 * AccountActivitiesApi - object-oriented interface
 * @export
 * @class AccountActivitiesApi
 * @extends {BaseAPI}
 */
var AccountActivitiesApi = /** @class */ (function (_super) {
    __extends(AccountActivitiesApi, _super);
    function AccountActivitiesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This gets a single account activity by its id.
     * @summary Get an Account Activity
     * @param {AccountActivitiesApiGetAccountActivityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    AccountActivitiesApi.prototype.getAccountActivity = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountActivitiesApiFp)(this.configuration).getAccountActivity(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a collection of account activities that satisfy the given query parameters.
     * @summary List Account Activities
     * @param {AccountActivitiesApiListAccountActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    AccountActivitiesApi.prototype.listAccountActivities = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.AccountActivitiesApiFp)(this.configuration).listAccountActivities(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AccountActivitiesApi;
}(base_1.BaseAPI));
exports.AccountActivitiesApi = AccountActivitiesApi;
/**
 * AccountUsagesApi - axios parameter creator
 * @export
 */
var AccountUsagesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {string} accountId ID of IDN account
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesByAccountId: function (accountId, limit, offset, count, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'accountId' is not null or undefined
                            (0, common_1.assertParamExists)('getUsagesByAccountId', 'accountId', accountId);
                            localVarPath = "/account-usages/{accountId}/summaries"
                                .replace("{".concat("accountId", "}"), encodeURIComponent(String(accountId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.AccountUsagesApiAxiosParamCreator = AccountUsagesApiAxiosParamCreator;
/**
 * AccountUsagesApi - functional programming interface
 * @export
 */
var AccountUsagesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AccountUsagesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {string} accountId ID of IDN account
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesByAccountId: function (accountId, limit, offset, count, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUsagesByAccountId(accountId, limit, offset, count, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AccountUsagesApiFp = AccountUsagesApiFp;
/**
 * AccountUsagesApi - factory interface
 * @export
 */
var AccountUsagesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AccountUsagesApiFp)(configuration);
    return {
        /**
         * This API returns a summary of account usage insights for past 12 months.
         * @summary Returns account usage insights
         * @param {string} accountId ID of IDN account
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesByAccountId: function (accountId, limit, offset, count, sorters, axiosOptions) {
            return localVarFp.getUsagesByAccountId(accountId, limit, offset, count, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AccountUsagesApiFactory = AccountUsagesApiFactory;
/**
 * AccountUsagesApi - object-oriented interface
 * @export
 * @class AccountUsagesApi
 * @extends {BaseAPI}
 */
var AccountUsagesApi = /** @class */ (function (_super) {
    __extends(AccountUsagesApi, _super);
    function AccountUsagesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API returns a summary of account usage insights for past 12 months.
     * @summary Returns account usage insights
     * @param {AccountUsagesApiGetUsagesByAccountIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountUsagesApi
     */
    AccountUsagesApi.prototype.getUsagesByAccountId = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountUsagesApiFp)(this.configuration).getUsagesByAccountId(requestParameters.accountId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AccountUsagesApi;
}(base_1.BaseAPI));
exports.AccountUsagesApi = AccountUsagesApi;
/**
 * AccountsApi - axios parameter creator
 * @export
 */
var AccountsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API submits an account creation task and returns the task ID.   You must include the `sourceId` where the account will be created in the `attributes` object. This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.  However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: function (accountAttributesCreate, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'accountAttributesCreate' is not null or undefined
                            (0, common_1.assertParamExists)('createAccount', 'accountAttributesCreate', accountAttributesCreate);
                            localVarPath = "/accounts";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountAttributesCreate, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
         * @summary Delete Account
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteAccount', 'id', id);
                            localVarPath = "/accounts/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: function (id, accountToggleRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('disableAccount', 'id', id);
                            // verify required parameter 'accountToggleRequest' is not null or undefined
                            (0, common_1.assertParamExists)('disableAccount', 'accountToggleRequest', accountToggleRequest);
                            localVarPath = "/accounts/{id}/disable"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountToggleRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount: function (id, accountToggleRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('enableAccount', 'id', id);
                            // verify required parameter 'accountToggleRequest' is not null or undefined
                            (0, common_1.assertParamExists)('enableAccount', 'accountToggleRequest', accountToggleRequest);
                            localVarPath = "/accounts/{id}/enable"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountToggleRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to return the details for a single account by its ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Details
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getAccount', 'id', id);
                            localVarPath = "/accounts/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements: function (id, limit, offset, count, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getAccountEntitlements', 'id', id);
                            localVarPath = "/accounts/{id}/entitlements"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, sw*  **identityId**: *eq, in, sw*  **name**: *eq, in, sw*  **nativeIdentity**: *eq, in, sw*  **sourceId**: *eq, in, sw*  **uncorrelated**: *eq*  **entitlements**: *eq*  **origin**: *eq, in*  **manuallyCorrelated**: *eq*  **identity.name**: *eq, in, sw*  **identity.correlated**: *eq*  **identity.identityState**: *eq, in*  **source.displayableName**: *eq, in*  **source.authoritative**: *eq*  **source.connectionType**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, identity.id, nativeIdentity, uuid, manuallyCorrelated, entitlements, origin, identity.name, identity.identityState, identity.correlated, source.displayableName, source.authoritative, source.connectionType**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: function (limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/accounts";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to update an account with a PUT request.   This endpoint submits an account update task and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.  >**Note: You can only use this PUT endpoint to update accounts from flat file sources.**
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {AccountAttributes} accountAttributes
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount: function (id, accountAttributes, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('putAccount', 'id', id);
                            // verify required parameter 'accountAttributes' is not null or undefined
                            (0, common_1.assertParamExists)('putAccount', 'accountAttributes', accountAttributes);
                            localVarPath = "/accounts/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountAttributes, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReloadAccount: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('submitReloadAccount', 'id', id);
                            localVarPath = "/accounts/{id}/reload"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account ID.
         * @param {AccountUnlockRequest} accountUnlockRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount: function (id, accountUnlockRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('unlockAccount', 'id', id);
                            // verify required parameter 'accountUnlockRequest' is not null or undefined
                            (0, common_1.assertParamExists)('unlockAccount', 'accountUnlockRequest', accountUnlockRequest);
                            localVarPath = "/accounts/{id}/unlock"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(accountUnlockRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to update account details.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.  This API supports updating an account\'s correlation by modifying the `identityId` and `manuallyCorrelated` fields.  To reassign an account from one identity to another, replace the current `identityId` with a new value.  If the account you\'re assigning was provisioned by Identity Security Cloud (ISC), it\'s possible for ISC to create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this causes the previous identity to become uncorrelated and can even result in its deletion. All accounts that are reassigned will be set to `manuallyCorrelated: true` unless you specify otherwise.  >**Note:** The `attributes` field can only be modified for flat file accounts.
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {Array<object>} requestBody A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: function (id, requestBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('updateAccount', 'id', id);
                            // verify required parameter 'requestBody' is not null or undefined
                            (0, common_1.assertParamExists)('updateAccount', 'requestBody', requestBody);
                            localVarPath = "/accounts/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(requestBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.AccountsApiAxiosParamCreator = AccountsApiAxiosParamCreator;
/**
 * AccountsApi - functional programming interface
 * @export
 */
var AccountsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AccountsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API submits an account creation task and returns the task ID.   You must include the `sourceId` where the account will be created in the `attributes` object. This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.  However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: function (accountAttributesCreate, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createAccount(accountAttributesCreate, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
         * @summary Delete Account
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteAccount(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: function (id, accountToggleRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.disableAccount(id, accountToggleRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount: function (id, accountToggleRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.enableAccount(id, accountToggleRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to return the details for a single account by its ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Details
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAccount(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements: function (id, limit, offset, count, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAccountEntitlements(id, limit, offset, count, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, sw*  **identityId**: *eq, in, sw*  **name**: *eq, in, sw*  **nativeIdentity**: *eq, in, sw*  **sourceId**: *eq, in, sw*  **uncorrelated**: *eq*  **entitlements**: *eq*  **origin**: *eq, in*  **manuallyCorrelated**: *eq*  **identity.name**: *eq, in, sw*  **identity.correlated**: *eq*  **identity.identityState**: *eq, in*  **source.displayableName**: *eq, in*  **source.authoritative**: *eq*  **source.connectionType**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, identity.id, nativeIdentity, uuid, manuallyCorrelated, entitlements, origin, identity.name, identity.identityState, identity.correlated, source.displayableName, source.authoritative, source.connectionType**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: function (limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listAccounts(limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to update an account with a PUT request.   This endpoint submits an account update task and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.  >**Note: You can only use this PUT endpoint to update accounts from flat file sources.**
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {AccountAttributes} accountAttributes
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount: function (id, accountAttributes, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putAccount(id, accountAttributes, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReloadAccount: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.submitReloadAccount(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account ID.
         * @param {AccountUnlockRequest} accountUnlockRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount: function (id, accountUnlockRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlockAccount(id, accountUnlockRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to update account details.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.  This API supports updating an account\'s correlation by modifying the `identityId` and `manuallyCorrelated` fields.  To reassign an account from one identity to another, replace the current `identityId` with a new value.  If the account you\'re assigning was provisioned by Identity Security Cloud (ISC), it\'s possible for ISC to create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this causes the previous identity to become uncorrelated and can even result in its deletion. All accounts that are reassigned will be set to `manuallyCorrelated: true` unless you specify otherwise.  >**Note:** The `attributes` field can only be modified for flat file accounts.
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {Array<object>} requestBody A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: function (id, requestBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateAccount(id, requestBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AccountsApiFp = AccountsApiFp;
/**
 * AccountsApi - factory interface
 * @export
 */
var AccountsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AccountsApiFp)(configuration);
    return {
        /**
         * This API submits an account creation task and returns the task ID.   You must include the `sourceId` where the account will be created in the `attributes` object. This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.  However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: function (accountAttributesCreate, axiosOptions) {
            return localVarFp.createAccount(accountAttributesCreate, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
         * @summary Delete Account
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: function (id, axiosOptions) {
            return localVarFp.deleteAccount(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: function (id, accountToggleRequest, axiosOptions) {
            return localVarFp.disableAccount(id, accountToggleRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount: function (id, accountToggleRequest, axiosOptions) {
            return localVarFp.enableAccount(id, accountToggleRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to return the details for a single account by its ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Details
         * @param {string} id Account ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: function (id, axiosOptions) {
            return localVarFp.getAccount(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements: function (id, limit, offset, count, axiosOptions) {
            return localVarFp.getAccountEntitlements(id, limit, offset, count, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, sw*  **identityId**: *eq, in, sw*  **name**: *eq, in, sw*  **nativeIdentity**: *eq, in, sw*  **sourceId**: *eq, in, sw*  **uncorrelated**: *eq*  **entitlements**: *eq*  **origin**: *eq, in*  **manuallyCorrelated**: *eq*  **identity.name**: *eq, in, sw*  **identity.correlated**: *eq*  **identity.identityState**: *eq, in*  **source.displayableName**: *eq, in*  **source.authoritative**: *eq*  **source.connectionType**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, sourceId, identityId, identity.id, nativeIdentity, uuid, manuallyCorrelated, entitlements, origin, identity.name, identity.identityState, identity.correlated, source.displayableName, source.authoritative, source.connectionType**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: function (limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.listAccounts(limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to update an account with a PUT request.   This endpoint submits an account update task and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.  >**Note: You can only use this PUT endpoint to update accounts from flat file sources.**
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {AccountAttributes} accountAttributes
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount: function (id, accountAttributes, axiosOptions) {
            return localVarFp.putAccount(id, accountAttributes, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReloadAccount: function (id, axiosOptions) {
            return localVarFp.submitReloadAccount(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account ID.
         * @param {AccountUnlockRequest} accountUnlockRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount: function (id, accountUnlockRequest, axiosOptions) {
            return localVarFp.unlockAccount(id, accountUnlockRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to update account details.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.  This API supports updating an account\'s correlation by modifying the `identityId` and `manuallyCorrelated` fields.  To reassign an account from one identity to another, replace the current `identityId` with a new value.  If the account you\'re assigning was provisioned by Identity Security Cloud (ISC), it\'s possible for ISC to create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this causes the previous identity to become uncorrelated and can even result in its deletion. All accounts that are reassigned will be set to `manuallyCorrelated: true` unless you specify otherwise.  >**Note:** The `attributes` field can only be modified for flat file accounts.
         * @summary Update Account
         * @param {string} id Account ID.
         * @param {Array<object>} requestBody A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: function (id, requestBody, axiosOptions) {
            return localVarFp.updateAccount(id, requestBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AccountsApiFactory = AccountsApiFactory;
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
var AccountsApi = /** @class */ (function (_super) {
    __extends(AccountsApi, _super);
    function AccountsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API submits an account creation task and returns the task ID.   You must include the `sourceId` where the account will be created in the `attributes` object. This endpoint creates an account on the source record in your ISC tenant. This is useful for Flat File (`DelimitedFile`) type sources because it allows you to aggregate new accounts without needing to import a new CSV file every time.  However, if you use this endpoint to create an account for a Direct Connection type source, you must ensure that the account also exists on the target source.  The endpoint doesn\'t actually provision the account on the target source, which means that if the account doesn\'t also exist on the target source, an aggregation between the source and your tenant will remove it from your tenant.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Create Account
     * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.createAccount = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountsApiFp)(this.configuration).createAccount(requestParameters.accountAttributesCreate, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to delete an account.  This endpoint submits an account delete task and returns the task ID.  This endpoint only deletes the account from IdentityNow, not the source itself, which can result in the account\'s returning with the next aggregation between the source and IdentityNow.  To avoid this scenario, it is recommended that you [disable accounts](https://developer.sailpoint.com/idn/api/v3/disable-account) rather than delete them. This will also allow you to reenable the accounts in the future.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. >**NOTE: You can only delete accounts from sources of the \"DelimitedFile\" type.**
     * @summary Delete Account
     * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.deleteAccount = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountsApiFp)(this.configuration).deleteAccount(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Disable Account
     * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.disableAccount = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountsApiFp)(this.configuration).disableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Enable Account
     * @param {AccountsApiEnableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.enableAccount = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountsApiFp)(this.configuration).enableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to return the details for a single account by its ID.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Account Details
     * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.getAccount = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountsApiFp)(this.configuration).getAccount(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns entitlements of the account.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Account Entitlements
     * @param {AccountsApiGetAccountEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.getAccountEntitlements = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountsApiFp)(this.configuration).getAccountEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This returns a list of accounts.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Accounts List
     * @param {AccountsApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.listAccounts = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.AccountsApiFp)(this.configuration).listAccounts(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to update an account with a PUT request.   This endpoint submits an account update task and returns the task ID.   A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.  >**Note: You can only use this PUT endpoint to update accounts from flat file sources.**
     * @summary Update Account
     * @param {AccountsApiPutAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.putAccount = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountsApiFp)(this.configuration).putAccount(requestParameters.id, requestParameters.accountAttributes, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Reload Account
     * @param {AccountsApiSubmitReloadAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.submitReloadAccount = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountsApiFp)(this.configuration).submitReloadAccount(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API submits a task to unlock an account and returns the task ID.   To use this endpoint to unlock an account that has the `forceProvisioning` option set to true, the `idn:accounts-provisioning:manage` scope is required.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or HELPDESK authority is required to call this API.
     * @summary Unlock Account
     * @param {AccountsApiUnlockAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.unlockAccount = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountsApiFp)(this.configuration).unlockAccount(requestParameters.id, requestParameters.accountUnlockRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to update account details.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.  This API supports updating an account\'s correlation by modifying the `identityId` and `manuallyCorrelated` fields.  To reassign an account from one identity to another, replace the current `identityId` with a new value.  If the account you\'re assigning was provisioned by Identity Security Cloud (ISC), it\'s possible for ISC to create a new account  for the previous identity as soon as the account is moved. If the account you\'re assigning is authoritative,  this causes the previous identity to become uncorrelated and can even result in its deletion. All accounts that are reassigned will be set to `manuallyCorrelated: true` unless you specify otherwise.  >**Note:** The `attributes` field can only be modified for flat file accounts.
     * @summary Update Account
     * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    AccountsApi.prototype.updateAccount = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AccountsApiFp)(this.configuration).updateAccount(requestParameters.id, requestParameters.requestBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AccountsApi;
}(base_1.BaseAPI));
exports.AccountsApi = AccountsApi;
/**
 * ApplicationDiscoveryApi - axios parameter creator
 * @export
 */
var ApplicationDiscoveryApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Fetches a list of applications that have been identified within the environment. This includes details such as application names, discovery dates, potential correlated saas_vendors and related suggested connectors.
         * @summary Retrieve discovered applications for tenant
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filter] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)       Filtering is supported for the following fields and operators:  **name**: *eq, sw, co*  **description**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, description, discoveredAt, discoverySource**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDiscoveredApplications: function (limit, offset, filter, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/discovered-applications";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (filter !== undefined) {
                                localVarQueryParameter['filter'] = filter;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint allows the user to download an example CSV file with two columns `application_name` and `description`.  The CSV file contains a single row with the values \'Example Application\' and \'Example Description\'.  The downloaded template is specifically designed for use with the `/manual-discover-applications` endpoint.
         * @summary CSV template download for discovery
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManualDiscoverApplicationsCsvTemplate: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/manual-discover-applications-template";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieves a list of mappings between SaaS vendors and IDN connectors, detailing the connections established for correlation.
         * @summary List vendor connector mappings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getVendorConnectorMappings: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/vendor-connector-mappings";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint supports uploading a CSV file with application data for manual correlation to specific IDN connectors.  If a suitable IDN connector is unavailable, the system will recommend generic connectors instead.
         * @summary CSV Upload to discover applications
         * @param {any} file The CSV file to upload containing &#x60;application_name&#x60; and &#x60;description&#x60; columns. Each row represents an application to be discovered.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendManualDiscoverApplicationsCsvTemplate: function (file, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'file' is not null or undefined
                            (0, common_1.assertParamExists)('sendManualDiscoverApplicationsCsvTemplate', 'file', file);
                            localVarPath = "/manual-discover-applications";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (file !== undefined) {
                                localVarFormParams.append('file', file);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ApplicationDiscoveryApiAxiosParamCreator = ApplicationDiscoveryApiAxiosParamCreator;
/**
 * ApplicationDiscoveryApi - functional programming interface
 * @export
 */
var ApplicationDiscoveryApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ApplicationDiscoveryApiAxiosParamCreator)(configuration);
    return {
        /**
         * Fetches a list of applications that have been identified within the environment. This includes details such as application names, discovery dates, potential correlated saas_vendors and related suggested connectors.
         * @summary Retrieve discovered applications for tenant
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filter] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)       Filtering is supported for the following fields and operators:  **name**: *eq, sw, co*  **description**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, description, discoveredAt, discoverySource**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDiscoveredApplications: function (limit, offset, filter, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDiscoveredApplications(limit, offset, filter, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint allows the user to download an example CSV file with two columns `application_name` and `description`.  The CSV file contains a single row with the values \'Example Application\' and \'Example Description\'.  The downloaded template is specifically designed for use with the `/manual-discover-applications` endpoint.
         * @summary CSV template download for discovery
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManualDiscoverApplicationsCsvTemplate: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getManualDiscoverApplicationsCsvTemplate(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieves a list of mappings between SaaS vendors and IDN connectors, detailing the connections established for correlation.
         * @summary List vendor connector mappings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getVendorConnectorMappings: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getVendorConnectorMappings(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint supports uploading a CSV file with application data for manual correlation to specific IDN connectors.  If a suitable IDN connector is unavailable, the system will recommend generic connectors instead.
         * @summary CSV Upload to discover applications
         * @param {any} file The CSV file to upload containing &#x60;application_name&#x60; and &#x60;description&#x60; columns. Each row represents an application to be discovered.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendManualDiscoverApplicationsCsvTemplate: function (file, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.sendManualDiscoverApplicationsCsvTemplate(file, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ApplicationDiscoveryApiFp = ApplicationDiscoveryApiFp;
/**
 * ApplicationDiscoveryApi - factory interface
 * @export
 */
var ApplicationDiscoveryApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ApplicationDiscoveryApiFp)(configuration);
    return {
        /**
         * Fetches a list of applications that have been identified within the environment. This includes details such as application names, discovery dates, potential correlated saas_vendors and related suggested connectors.
         * @summary Retrieve discovered applications for tenant
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filter] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)       Filtering is supported for the following fields and operators:  **name**: *eq, sw, co*  **description**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, description, discoveredAt, discoverySource**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDiscoveredApplications: function (limit, offset, filter, sorters, axiosOptions) {
            return localVarFp.getDiscoveredApplications(limit, offset, filter, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint allows the user to download an example CSV file with two columns `application_name` and `description`.  The CSV file contains a single row with the values \'Example Application\' and \'Example Description\'.  The downloaded template is specifically designed for use with the `/manual-discover-applications` endpoint.
         * @summary CSV template download for discovery
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManualDiscoverApplicationsCsvTemplate: function (axiosOptions) {
            return localVarFp.getManualDiscoverApplicationsCsvTemplate(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieves a list of mappings between SaaS vendors and IDN connectors, detailing the connections established for correlation.
         * @summary List vendor connector mappings
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getVendorConnectorMappings: function (axiosOptions) {
            return localVarFp.getVendorConnectorMappings(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint supports uploading a CSV file with application data for manual correlation to specific IDN connectors.  If a suitable IDN connector is unavailable, the system will recommend generic connectors instead.
         * @summary CSV Upload to discover applications
         * @param {any} file The CSV file to upload containing &#x60;application_name&#x60; and &#x60;description&#x60; columns. Each row represents an application to be discovered.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendManualDiscoverApplicationsCsvTemplate: function (file, axiosOptions) {
            return localVarFp.sendManualDiscoverApplicationsCsvTemplate(file, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ApplicationDiscoveryApiFactory = ApplicationDiscoveryApiFactory;
/**
 * ApplicationDiscoveryApi - object-oriented interface
 * @export
 * @class ApplicationDiscoveryApi
 * @extends {BaseAPI}
 */
var ApplicationDiscoveryApi = /** @class */ (function (_super) {
    __extends(ApplicationDiscoveryApi, _super);
    function ApplicationDiscoveryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fetches a list of applications that have been identified within the environment. This includes details such as application names, discovery dates, potential correlated saas_vendors and related suggested connectors.
     * @summary Retrieve discovered applications for tenant
     * @param {ApplicationDiscoveryApiGetDiscoveredApplicationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDiscoveryApi
     */
    ApplicationDiscoveryApi.prototype.getDiscoveredApplications = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.ApplicationDiscoveryApiFp)(this.configuration).getDiscoveredApplications(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint allows the user to download an example CSV file with two columns `application_name` and `description`.  The CSV file contains a single row with the values \'Example Application\' and \'Example Description\'.  The downloaded template is specifically designed for use with the `/manual-discover-applications` endpoint.
     * @summary CSV template download for discovery
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDiscoveryApi
     */
    ApplicationDiscoveryApi.prototype.getManualDiscoverApplicationsCsvTemplate = function (axiosOptions) {
        var _this = this;
        return (0, exports.ApplicationDiscoveryApiFp)(this.configuration).getManualDiscoverApplicationsCsvTemplate(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieves a list of mappings between SaaS vendors and IDN connectors, detailing the connections established for correlation.
     * @summary List vendor connector mappings
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDiscoveryApi
     */
    ApplicationDiscoveryApi.prototype.getVendorConnectorMappings = function (axiosOptions) {
        var _this = this;
        return (0, exports.ApplicationDiscoveryApiFp)(this.configuration).getVendorConnectorMappings(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint supports uploading a CSV file with application data for manual correlation to specific IDN connectors.  If a suitable IDN connector is unavailable, the system will recommend generic connectors instead.
     * @summary CSV Upload to discover applications
     * @param {ApplicationDiscoveryApiSendManualDiscoverApplicationsCsvTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDiscoveryApi
     */
    ApplicationDiscoveryApi.prototype.sendManualDiscoverApplicationsCsvTemplate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ApplicationDiscoveryApiFp)(this.configuration).sendManualDiscoverApplicationsCsvTemplate(requestParameters.file, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ApplicationDiscoveryApi;
}(base_1.BaseAPI));
exports.ApplicationDiscoveryApi = ApplicationDiscoveryApi;
/**
 * AuthUsersApi - axios parameter creator
 * @export
 */
var AuthUsersApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Return the specified user\'s authentication system details.
         * @summary Auth User Details
         * @param {string} id Identity ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUser: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getAuthUser', 'id', id);
                            localVarPath = "/auth-users/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
         * @summary Auth User Update
         * @param {string} id Identity ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthUser: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchAuthUser', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchAuthUser', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/auth-users/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.AuthUsersApiAxiosParamCreator = AuthUsersApiAxiosParamCreator;
/**
 * AuthUsersApi - functional programming interface
 * @export
 */
var AuthUsersApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AuthUsersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Return the specified user\'s authentication system details.
         * @summary Auth User Details
         * @param {string} id Identity ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUser: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAuthUser(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
         * @summary Auth User Update
         * @param {string} id Identity ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthUser: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchAuthUser(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AuthUsersApiFp = AuthUsersApiFp;
/**
 * AuthUsersApi - factory interface
 * @export
 */
var AuthUsersApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AuthUsersApiFp)(configuration);
    return {
        /**
         * Return the specified user\'s authentication system details.
         * @summary Auth User Details
         * @param {string} id Identity ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUser: function (id, axiosOptions) {
            return localVarFp.getAuthUser(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
         * @summary Auth User Update
         * @param {string} id Identity ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth user update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthUser: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchAuthUser(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AuthUsersApiFactory = AuthUsersApiFactory;
/**
 * AuthUsersApi - object-oriented interface
 * @export
 * @class AuthUsersApi
 * @extends {BaseAPI}
 */
var AuthUsersApi = /** @class */ (function (_super) {
    __extends(AuthUsersApi, _super);
    function AuthUsersApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Return the specified user\'s authentication system details.
     * @summary Auth User Details
     * @param {AuthUsersApiGetAuthUserRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthUsersApi
     */
    AuthUsersApi.prototype.getAuthUser = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AuthUsersApiFp)(this.configuration).getAuthUser(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use a PATCH request to update an existing user in the authentication system. Use this endpoint to modify these fields:    * `capabilities`  A \'400.1.1 Illegal update attempt\' detail code indicates that you attempted to PATCH a field that is not allowed.
     * @summary Auth User Update
     * @param {AuthUsersApiPatchAuthUserRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthUsersApi
     */
    AuthUsersApi.prototype.patchAuthUser = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AuthUsersApiFp)(this.configuration).patchAuthUser(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AuthUsersApi;
}(base_1.BaseAPI));
exports.AuthUsersApi = AuthUsersApi;
/**
 * BrandingApi - axios parameter creator
 * @export
 */
var BrandingApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API endpoint creates a branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Create a branding item
         * @param {string} name name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createBrandingItem: function (name, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'name' is not null or undefined
                            (0, common_1.assertParamExists)('createBrandingItem', 'name', name);
                            // verify required parameter 'productName' is not null or undefined
                            (0, common_1.assertParamExists)('createBrandingItem', 'productName', productName);
                            localVarPath = "/brandings";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (name !== undefined) {
                                localVarFormParams.append('name', name);
                            }
                            if (productName !== undefined) {
                                localVarFormParams.append('productName', productName);
                            }
                            if (actionButtonColor !== undefined) {
                                localVarFormParams.append('actionButtonColor', actionButtonColor);
                            }
                            if (activeLinkColor !== undefined) {
                                localVarFormParams.append('activeLinkColor', activeLinkColor);
                            }
                            if (navigationColor !== undefined) {
                                localVarFormParams.append('navigationColor', navigationColor);
                            }
                            if (emailFromAddress !== undefined) {
                                localVarFormParams.append('emailFromAddress', emailFromAddress);
                            }
                            if (loginInformationalMessage !== undefined) {
                                localVarFormParams.append('loginInformationalMessage', loginInformationalMessage);
                            }
                            if (fileStandard !== undefined) {
                                localVarFormParams.append('fileStandard', fileStandard);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API endpoint delete information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Delete a branding item
         * @param {string} name The name of the branding item to be deleted
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranding: function (name, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'name' is not null or undefined
                            (0, common_1.assertParamExists)('deleteBranding', 'name', name);
                            localVarPath = "/brandings/{name}"
                                .replace("{".concat("name", "}"), encodeURIComponent(String(name)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API endpoint retrieves information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Get a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBranding: function (name, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'name' is not null or undefined
                            (0, common_1.assertParamExists)('getBranding', 'name', name);
                            localVarPath = "/brandings/{name}"
                                .replace("{".concat("name", "}"), encodeURIComponent(String(name)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API endpoint returns a list of branding items.  A token with API, ORG_ADMIN authority is required to call this API.
         * @summary List of branding items
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingList: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/brandings";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API endpoint updates information for an existing branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Update a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {string} name2 name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setBrandingItem: function (name, name2, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'name' is not null or undefined
                            (0, common_1.assertParamExists)('setBrandingItem', 'name', name);
                            // verify required parameter 'name2' is not null or undefined
                            (0, common_1.assertParamExists)('setBrandingItem', 'name2', name2);
                            // verify required parameter 'productName' is not null or undefined
                            (0, common_1.assertParamExists)('setBrandingItem', 'productName', productName);
                            localVarPath = "/brandings/{name}"
                                .replace("{".concat("name", "}"), encodeURIComponent(String(name)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (name2 !== undefined) {
                                localVarFormParams.append('name', name2);
                            }
                            if (productName !== undefined) {
                                localVarFormParams.append('productName', productName);
                            }
                            if (actionButtonColor !== undefined) {
                                localVarFormParams.append('actionButtonColor', actionButtonColor);
                            }
                            if (activeLinkColor !== undefined) {
                                localVarFormParams.append('activeLinkColor', activeLinkColor);
                            }
                            if (navigationColor !== undefined) {
                                localVarFormParams.append('navigationColor', navigationColor);
                            }
                            if (emailFromAddress !== undefined) {
                                localVarFormParams.append('emailFromAddress', emailFromAddress);
                            }
                            if (loginInformationalMessage !== undefined) {
                                localVarFormParams.append('loginInformationalMessage', loginInformationalMessage);
                            }
                            if (fileStandard !== undefined) {
                                localVarFormParams.append('fileStandard', fileStandard);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.BrandingApiAxiosParamCreator = BrandingApiAxiosParamCreator;
/**
 * BrandingApi - functional programming interface
 * @export
 */
var BrandingApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.BrandingApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API endpoint creates a branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Create a branding item
         * @param {string} name name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createBrandingItem: function (name, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createBrandingItem(name, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API endpoint delete information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Delete a branding item
         * @param {string} name The name of the branding item to be deleted
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranding: function (name, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteBranding(name, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API endpoint retrieves information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Get a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBranding: function (name, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBranding(name, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API endpoint returns a list of branding items.  A token with API, ORG_ADMIN authority is required to call this API.
         * @summary List of branding items
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingList: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getBrandingList(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API endpoint updates information for an existing branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Update a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {string} name2 name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setBrandingItem: function (name, name2, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setBrandingItem(name, name2, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.BrandingApiFp = BrandingApiFp;
/**
 * BrandingApi - factory interface
 * @export
 */
var BrandingApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.BrandingApiFp)(configuration);
    return {
        /**
         * This API endpoint creates a branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Create a branding item
         * @param {string} name name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createBrandingItem: function (name, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions) {
            return localVarFp.createBrandingItem(name, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API endpoint delete information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Delete a branding item
         * @param {string} name The name of the branding item to be deleted
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranding: function (name, axiosOptions) {
            return localVarFp.deleteBranding(name, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API endpoint retrieves information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Get a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBranding: function (name, axiosOptions) {
            return localVarFp.getBranding(name, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API endpoint returns a list of branding items.  A token with API, ORG_ADMIN authority is required to call this API.
         * @summary List of branding items
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingList: function (axiosOptions) {
            return localVarFp.getBrandingList(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API endpoint updates information for an existing branding item. A token with API, ORG_ADMIN authority is required to call this API.
         * @summary Update a branding item
         * @param {string} name The name of the branding item to be retrieved
         * @param {string} name2 name of branding item
         * @param {string} productName product name
         * @param {string} [actionButtonColor] hex value of color for action button
         * @param {string} [activeLinkColor] hex value of color for link
         * @param {string} [navigationColor] hex value of color for navigation bar
         * @param {string} [emailFromAddress] email from address
         * @param {string} [loginInformationalMessage] login information message
         * @param {any} [fileStandard] png file with logo
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setBrandingItem: function (name, name2, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions) {
            return localVarFp.setBrandingItem(name, name2, productName, actionButtonColor, activeLinkColor, navigationColor, emailFromAddress, loginInformationalMessage, fileStandard, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.BrandingApiFactory = BrandingApiFactory;
/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
var BrandingApi = /** @class */ (function (_super) {
    __extends(BrandingApi, _super);
    function BrandingApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API endpoint creates a branding item. A token with API, ORG_ADMIN authority is required to call this API.
     * @summary Create a branding item
     * @param {BrandingApiCreateBrandingItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    BrandingApi.prototype.createBrandingItem = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.BrandingApiFp)(this.configuration).createBrandingItem(requestParameters.name, requestParameters.productName, requestParameters.actionButtonColor, requestParameters.activeLinkColor, requestParameters.navigationColor, requestParameters.emailFromAddress, requestParameters.loginInformationalMessage, requestParameters.fileStandard, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API endpoint delete information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
     * @summary Delete a branding item
     * @param {BrandingApiDeleteBrandingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    BrandingApi.prototype.deleteBranding = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.BrandingApiFp)(this.configuration).deleteBranding(requestParameters.name, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API endpoint retrieves information for an existing branding item by name. A token with API, ORG_ADMIN authority is required to call this API.
     * @summary Get a branding item
     * @param {BrandingApiGetBrandingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    BrandingApi.prototype.getBranding = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.BrandingApiFp)(this.configuration).getBranding(requestParameters.name, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API endpoint returns a list of branding items.  A token with API, ORG_ADMIN authority is required to call this API.
     * @summary List of branding items
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    BrandingApi.prototype.getBrandingList = function (axiosOptions) {
        var _this = this;
        return (0, exports.BrandingApiFp)(this.configuration).getBrandingList(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API endpoint updates information for an existing branding item. A token with API, ORG_ADMIN authority is required to call this API.
     * @summary Update a branding item
     * @param {BrandingApiSetBrandingItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    BrandingApi.prototype.setBrandingItem = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.BrandingApiFp)(this.configuration).setBrandingItem(requestParameters.name, requestParameters.name2, requestParameters.productName, requestParameters.actionButtonColor, requestParameters.activeLinkColor, requestParameters.navigationColor, requestParameters.emailFromAddress, requestParameters.loginInformationalMessage, requestParameters.fileStandard, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return BrandingApi;
}(base_1.BaseAPI));
exports.BrandingApi = BrandingApi;
/**
 * CertificationCampaignFiltersApi - axios parameter creator
 * @export
 */
var CertificationCampaignFiltersApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Use this API to create a campaign filter based on filter details and criteria.
         * @summary Create Campaign Filter
         * @param {CampaignFilterDetails} campaignFilterDetails
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignFilter: function (campaignFilterDetails, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'campaignFilterDetails' is not null or undefined
                            (0, common_1.assertParamExists)('createCampaignFilter', 'campaignFilterDetails', campaignFilterDetails);
                            localVarPath = "/campaign-filters";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(campaignFilterDetails, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {Array<string>} requestBody A json list of IDs of campaign filters to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignFilters: function (requestBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'requestBody' is not null or undefined
                            (0, common_1.assertParamExists)('deleteCampaignFilters', 'requestBody', requestBody);
                            localVarPath = "/campaign-filters/delete";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(requestBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {string} filterId The ID of the campaign filter to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignFilterById: function (filterId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'filterId' is not null or undefined
                            (0, common_1.assertParamExists)('getCampaignFilterById', 'filterId', filterId);
                            localVarPath = "/campaign-filters/{id}"
                                .replace("{".concat("filterId", "}"), encodeURIComponent(String(filterId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to list all campaign filters. You can reduce scope with standard V3 query parameters.
         * @summary List Campaign Filters
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [start] Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeSystemFilters] If this is true, the API includes system filters in the count and results. Otherwise it excludes them. If no value is provided, the default is true.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignFilters: function (limit, start, includeSystemFilters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/campaign-filters";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (start !== undefined) {
                                localVarQueryParameter['start'] = start;
                            }
                            if (includeSystemFilters !== undefined) {
                                localVarQueryParameter['includeSystemFilters'] = includeSystemFilters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {string} filterId The ID of the campaign filter being modified.
         * @param {CampaignFilterDetails} campaignFilterDetails A campaign filter details with updated field values.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaignFilter: function (filterId, campaignFilterDetails, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'filterId' is not null or undefined
                            (0, common_1.assertParamExists)('updateCampaignFilter', 'filterId', filterId);
                            // verify required parameter 'campaignFilterDetails' is not null or undefined
                            (0, common_1.assertParamExists)('updateCampaignFilter', 'campaignFilterDetails', campaignFilterDetails);
                            localVarPath = "/campaign-filters/{id}"
                                .replace("{".concat("filterId", "}"), encodeURIComponent(String(filterId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(campaignFilterDetails, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.CertificationCampaignFiltersApiAxiosParamCreator = CertificationCampaignFiltersApiAxiosParamCreator;
/**
 * CertificationCampaignFiltersApi - functional programming interface
 * @export
 */
var CertificationCampaignFiltersApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.CertificationCampaignFiltersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Use this API to create a campaign filter based on filter details and criteria.
         * @summary Create Campaign Filter
         * @param {CampaignFilterDetails} campaignFilterDetails
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignFilter: function (campaignFilterDetails, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createCampaignFilter(campaignFilterDetails, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {Array<string>} requestBody A json list of IDs of campaign filters to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignFilters: function (requestBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteCampaignFilters(requestBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {string} filterId The ID of the campaign filter to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignFilterById: function (filterId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCampaignFilterById(filterId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to list all campaign filters. You can reduce scope with standard V3 query parameters.
         * @summary List Campaign Filters
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [start] Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeSystemFilters] If this is true, the API includes system filters in the count and results. Otherwise it excludes them. If no value is provided, the default is true.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignFilters: function (limit, start, includeSystemFilters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listCampaignFilters(limit, start, includeSystemFilters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {string} filterId The ID of the campaign filter being modified.
         * @param {CampaignFilterDetails} campaignFilterDetails A campaign filter details with updated field values.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaignFilter: function (filterId, campaignFilterDetails, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateCampaignFilter(filterId, campaignFilterDetails, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.CertificationCampaignFiltersApiFp = CertificationCampaignFiltersApiFp;
/**
 * CertificationCampaignFiltersApi - factory interface
 * @export
 */
var CertificationCampaignFiltersApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.CertificationCampaignFiltersApiFp)(configuration);
    return {
        /**
         * Use this API to create a campaign filter based on filter details and criteria.
         * @summary Create Campaign Filter
         * @param {CampaignFilterDetails} campaignFilterDetails
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignFilter: function (campaignFilterDetails, axiosOptions) {
            return localVarFp.createCampaignFilter(campaignFilterDetails, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
         * @summary Deletes Campaign Filters
         * @param {Array<string>} requestBody A json list of IDs of campaign filters to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignFilters: function (requestBody, axiosOptions) {
            return localVarFp.deleteCampaignFilters(requestBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieves information for an existing campaign filter using the filter\'s ID.
         * @summary Get Campaign Filter by ID
         * @param {string} filterId The ID of the campaign filter to be retrieved.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignFilterById: function (filterId, axiosOptions) {
            return localVarFp.getCampaignFilterById(filterId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to list all campaign filters. You can reduce scope with standard V3 query parameters.
         * @summary List Campaign Filters
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [start] Start/Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [includeSystemFilters] If this is true, the API includes system filters in the count and results. Otherwise it excludes them. If no value is provided, the default is true.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCampaignFilters: function (limit, start, includeSystemFilters, axiosOptions) {
            return localVarFp.listCampaignFilters(limit, start, includeSystemFilters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates an existing campaign filter using the filter\'s ID.
         * @summary Updates a Campaign Filter
         * @param {string} filterId The ID of the campaign filter being modified.
         * @param {CampaignFilterDetails} campaignFilterDetails A campaign filter details with updated field values.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaignFilter: function (filterId, campaignFilterDetails, axiosOptions) {
            return localVarFp.updateCampaignFilter(filterId, campaignFilterDetails, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.CertificationCampaignFiltersApiFactory = CertificationCampaignFiltersApiFactory;
/**
 * CertificationCampaignFiltersApi - object-oriented interface
 * @export
 * @class CertificationCampaignFiltersApi
 * @extends {BaseAPI}
 */
var CertificationCampaignFiltersApi = /** @class */ (function (_super) {
    __extends(CertificationCampaignFiltersApi, _super);
    function CertificationCampaignFiltersApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this API to create a campaign filter based on filter details and criteria.
     * @summary Create Campaign Filter
     * @param {CertificationCampaignFiltersApiCreateCampaignFilterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    CertificationCampaignFiltersApi.prototype.createCampaignFilter = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignFiltersApiFp)(this.configuration).createCampaignFilter(requestParameters.campaignFilterDetails, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes campaign filters whose Ids are specified in the provided list of campaign filter Ids. Authorized callers must be an ORG_ADMIN or a CERT_ADMIN.
     * @summary Deletes Campaign Filters
     * @param {CertificationCampaignFiltersApiDeleteCampaignFiltersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    CertificationCampaignFiltersApi.prototype.deleteCampaignFilters = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignFiltersApiFp)(this.configuration).deleteCampaignFilters(requestParameters.requestBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieves information for an existing campaign filter using the filter\'s ID.
     * @summary Get Campaign Filter by ID
     * @param {CertificationCampaignFiltersApiGetCampaignFilterByIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    CertificationCampaignFiltersApi.prototype.getCampaignFilterById = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignFiltersApiFp)(this.configuration).getCampaignFilterById(requestParameters.filterId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to list all campaign filters. You can reduce scope with standard V3 query parameters.
     * @summary List Campaign Filters
     * @param {CertificationCampaignFiltersApiListCampaignFiltersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    CertificationCampaignFiltersApi.prototype.listCampaignFilters = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.CertificationCampaignFiltersApiFp)(this.configuration).listCampaignFilters(requestParameters.limit, requestParameters.start, requestParameters.includeSystemFilters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Updates an existing campaign filter using the filter\'s ID.
     * @summary Updates a Campaign Filter
     * @param {CertificationCampaignFiltersApiUpdateCampaignFilterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignFiltersApi
     */
    CertificationCampaignFiltersApi.prototype.updateCampaignFilter = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignFiltersApiFp)(this.configuration).updateCampaignFilter(requestParameters.filterId, requestParameters.campaignFilterDetails, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return CertificationCampaignFiltersApi;
}(base_1.BaseAPI));
exports.CertificationCampaignFiltersApi = CertificationCampaignFiltersApi;
/**
 * CertificationCampaignsApi - axios parameter creator
 * @export
 */
var CertificationCampaignsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Complete a Campaign
         * @param {string} id Campaign ID.
         * @param {CampaignCompleteOptions} [campaignCompleteOptions] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeCampaign: function (id, campaignCompleteOptions, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('completeCampaign', 'id', id);
                            localVarPath = "/campaigns/{id}/complete"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(campaignCompleteOptions, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to create a certification campaign with the information provided in the request body.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Create a campaign
         * @param {Campaign} campaign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: function (campaign, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'campaign' is not null or undefined
                            (0, common_1.assertParamExists)('createCampaign', 'campaign', campaign);
                            localVarPath = "/campaigns";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(campaign, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to create a certification campaign template based on campaign.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Create a Campaign Template
         * @param {CampaignTemplate} campaignTemplate
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignTemplate: function (campaignTemplate, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'campaignTemplate' is not null or undefined
                            (0, common_1.assertParamExists)('createCampaignTemplate', 'campaignTemplate', campaignTemplate);
                            localVarPath = "/campaign-templates";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(campaignTemplate, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to delete a certification campaign template by ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Delete a Campaign Template
         * @param {string} id ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplate: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteCampaignTemplate', 'id', id);
                            localVarPath = "/campaign-templates/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Delete Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplateSchedule: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteCampaignTemplateSchedule', 'id', id);
                            localVarPath = "/campaign-templates/{id}/schedule"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Delete Campaigns
         * @param {CampaignsDeleteRequest} campaignsDeleteRequest IDs of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaigns: function (campaignsDeleteRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'campaignsDeleteRequest' is not null or undefined
                            (0, common_1.assertParamExists)('deleteCampaigns', 'campaignsDeleteRequest', campaignsDeleteRequest);
                            localVarPath = "/campaigns/delete";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(campaignsDeleteRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCampaigns: function (detail, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/campaigns";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (detail !== undefined) {
                                localVarQueryParameter['detail'] = detail;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to get information for an existing certification campaign by the campaign\'s ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get Campaign
         * @param {string} id ID of the campaign to be retrieved.
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign: function (id, detail, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getCampaign', 'id', id);
                            localVarPath = "/campaigns/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (detail !== undefined) {
                                localVarQueryParameter['detail'] = detail;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to fetch all reports for a certification campaign by campaign ID.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary Get Campaign Reports
         * @param {string} id ID of the campaign whose reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReports: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getCampaignReports', 'id', id);
                            localVarPath = "/campaigns/{id}/reports"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReportsConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/campaigns/reports-configuration";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to fetch a certification campaign template by ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get a Campaign Template
         * @param {string} id Requested campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplate: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getCampaignTemplate', 'id', id);
                            localVarPath = "/campaign-templates/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplateSchedule: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getCampaignTemplateSchedule', 'id', id);
                            localVarPath = "/campaign-templates/{id}/schedule"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params.  The API returns all campaign templates matching the query parameters.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplates: function (limit, offset, count, sorters, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/campaign-templates";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API reassigns the specified certifications from one identity to another.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        move: function (id, adminReviewReassign, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('move', 'id', id);
                            // verify required parameter 'adminReviewReassign' is not null or undefined
                            (0, common_1.assertParamExists)('move', 'adminReviewReassign', adminReviewReassign);
                            localVarPath = "/campaigns/{id}/reassign"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(adminReviewReassign, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Update a Campaign Template
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchCampaignTemplate: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchCampaignTemplate', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchCampaignTemplate', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/campaign-templates/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to overwrite the configuration for campaign reports.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfig} campaignReportsConfig Campaign report configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignReportsConfig: function (campaignReportsConfig, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'campaignReportsConfig' is not null or undefined
                            (0, common_1.assertParamExists)('setCampaignReportsConfig', 'campaignReportsConfig', campaignReportsConfig);
                            localVarPath = "/campaigns/reports-configuration";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(campaignReportsConfig, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Set Campaign Template Schedule
         * @param {string} id ID of the campaign template being scheduled.
         * @param {Schedule} [schedule]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignTemplateSchedule: function (id, schedule, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('setCampaignTemplateSchedule', 'id', id);
                            localVarPath = "/campaign-templates/{id}/schedule"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(schedule, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Activate a Campaign
         * @param {string} id Campaign ID.
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign: function (id, activateCampaignOptions, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('startCampaign', 'id', id);
                            localVarPath = "/campaigns/{id}/activate"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(activateCampaignOptions, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to run a remediation scan task for a certification campaign.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary Run Campaign Remediation Scan
         * @param {string} id ID of the campaign the remediation scan is being run for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignRemediationScan: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('startCampaignRemediationScan', 'id', id);
                            localVarPath = "/campaigns/{id}/run-remediation-scan"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to run a report for a certification campaign.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary Run Campaign Report
         * @param {string} id ID of the campaign the report is being run for.
         * @param {ReportType} type Type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignReport: function (id, type, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('startCampaignReport', 'id', id);
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('startCampaignReport', 'type', type);
                            localVarPath = "/campaigns/{id}/run-report/{type}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)))
                                .replace("{".concat("type", "}"), encodeURIComponent(String(type)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to generate a new certification campaign from a campaign template.  The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation.  Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020).  Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html).  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Generate a Campaign from Template
         * @param {string} id ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startGenerateCampaignTemplate: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('startGenerateCampaignTemplate', 'id', id);
                            localVarPath = "/campaign-templates/{id}/generate"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Update a Campaign
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  When the campaign is in the *STAGED* status, you can patch these fields: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  When the campaign is in the *ACTIVE* status, you can patch these fields: * deadline
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('updateCampaign', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('updateCampaign', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/campaigns/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.CertificationCampaignsApiAxiosParamCreator = CertificationCampaignsApiAxiosParamCreator;
/**
 * CertificationCampaignsApi - functional programming interface
 * @export
 */
var CertificationCampaignsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.CertificationCampaignsApiAxiosParamCreator)(configuration);
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Complete a Campaign
         * @param {string} id Campaign ID.
         * @param {CampaignCompleteOptions} [campaignCompleteOptions] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeCampaign: function (id, campaignCompleteOptions, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.completeCampaign(id, campaignCompleteOptions, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to create a certification campaign with the information provided in the request body.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Create a campaign
         * @param {Campaign} campaign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: function (campaign, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createCampaign(campaign, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to create a certification campaign template based on campaign.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Create a Campaign Template
         * @param {CampaignTemplate} campaignTemplate
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignTemplate: function (campaignTemplate, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createCampaignTemplate(campaignTemplate, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to delete a certification campaign template by ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Delete a Campaign Template
         * @param {string} id ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplate: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteCampaignTemplate(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Delete Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplateSchedule: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteCampaignTemplateSchedule(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Delete Campaigns
         * @param {CampaignsDeleteRequest} campaignsDeleteRequest IDs of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaigns: function (campaignsDeleteRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteCampaigns(campaignsDeleteRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCampaigns: function (detail, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getActiveCampaigns(detail, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to get information for an existing certification campaign by the campaign\'s ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get Campaign
         * @param {string} id ID of the campaign to be retrieved.
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign: function (id, detail, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCampaign(id, detail, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to fetch all reports for a certification campaign by campaign ID.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary Get Campaign Reports
         * @param {string} id ID of the campaign whose reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReports: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCampaignReports(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReportsConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCampaignReportsConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to fetch a certification campaign template by ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get a Campaign Template
         * @param {string} id Requested campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplate: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCampaignTemplate(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplateSchedule: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCampaignTemplateSchedule(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params.  The API returns all campaign templates matching the query parameters.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplates: function (limit, offset, count, sorters, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCampaignTemplates(limit, offset, count, sorters, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API reassigns the specified certifications from one identity to another.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        move: function (id, adminReviewReassign, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.move(id, adminReviewReassign, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Update a Campaign Template
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchCampaignTemplate: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchCampaignTemplate(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to overwrite the configuration for campaign reports.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfig} campaignReportsConfig Campaign report configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignReportsConfig: function (campaignReportsConfig, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setCampaignReportsConfig(campaignReportsConfig, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Set Campaign Template Schedule
         * @param {string} id ID of the campaign template being scheduled.
         * @param {Schedule} [schedule]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignTemplateSchedule: function (id, schedule, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setCampaignTemplateSchedule(id, schedule, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Activate a Campaign
         * @param {string} id Campaign ID.
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign: function (id, activateCampaignOptions, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startCampaign(id, activateCampaignOptions, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to run a remediation scan task for a certification campaign.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary Run Campaign Remediation Scan
         * @param {string} id ID of the campaign the remediation scan is being run for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignRemediationScan: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startCampaignRemediationScan(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to run a report for a certification campaign.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary Run Campaign Report
         * @param {string} id ID of the campaign the report is being run for.
         * @param {ReportType} type Type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignReport: function (id, type, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startCampaignReport(id, type, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to generate a new certification campaign from a campaign template.  The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation.  Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020).  Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html).  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Generate a Campaign from Template
         * @param {string} id ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startGenerateCampaignTemplate: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startGenerateCampaignTemplate(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Update a Campaign
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  When the campaign is in the *STAGED* status, you can patch these fields: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  When the campaign is in the *ACTIVE* status, you can patch these fields: * deadline
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateCampaign(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.CertificationCampaignsApiFp = CertificationCampaignsApiFp;
/**
 * CertificationCampaignsApi - factory interface
 * @export
 */
var CertificationCampaignsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.CertificationCampaignsApiFp)(configuration);
    return {
        /**
         * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Complete a Campaign
         * @param {string} id Campaign ID.
         * @param {CampaignCompleteOptions} [campaignCompleteOptions] Optional. Default behavior is for the campaign to auto-approve upon completion, unless autoCompleteAction&#x3D;REVOKE
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeCampaign: function (id, campaignCompleteOptions, axiosOptions) {
            return localVarFp.completeCampaign(id, campaignCompleteOptions, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to create a certification campaign with the information provided in the request body.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Create a campaign
         * @param {Campaign} campaign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: function (campaign, axiosOptions) {
            return localVarFp.createCampaign(campaign, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to create a certification campaign template based on campaign.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Create a Campaign Template
         * @param {CampaignTemplate} campaignTemplate
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCampaignTemplate: function (campaignTemplate, axiosOptions) {
            return localVarFp.createCampaignTemplate(campaignTemplate, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to delete a certification campaign template by ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Delete a Campaign Template
         * @param {string} id ID of the campaign template being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplate: function (id, axiosOptions) {
            return localVarFp.deleteCampaignTemplate(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Delete Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaignTemplateSchedule: function (id, axiosOptions) {
            return localVarFp.deleteCampaignTemplateSchedule(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Delete Campaigns
         * @param {CampaignsDeleteRequest} campaignsDeleteRequest IDs of the campaigns to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaigns: function (campaignsDeleteRequest, axiosOptions) {
            return localVarFp.deleteCampaigns(campaignsDeleteRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary List Campaigns
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **status**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCampaigns: function (detail, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.getActiveCampaigns(detail, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to get information for an existing certification campaign by the campaign\'s ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get Campaign
         * @param {string} id ID of the campaign to be retrieved.
         * @param {'SLIM' | 'FULL'} [detail] Determines whether slim, or increased level of detail is provided for each campaign in the returned list. Slim is the default behavior.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign: function (id, detail, axiosOptions) {
            return localVarFp.getCampaign(id, detail, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to fetch all reports for a certification campaign by campaign ID.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary Get Campaign Reports
         * @param {string} id ID of the campaign whose reports are being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReports: function (id, axiosOptions) {
            return localVarFp.getCampaignReports(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get Campaign Reports Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignReportsConfig: function (axiosOptions) {
            return localVarFp.getCampaignReportsConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to fetch a certification campaign template by ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get a Campaign Template
         * @param {string} id Requested campaign template\&#39;s ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplate: function (id, axiosOptions) {
            return localVarFp.getCampaignTemplate(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Get Campaign Template Schedule
         * @param {string} id ID of the campaign template whose schedule is being fetched.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplateSchedule: function (id, axiosOptions) {
            return localVarFp.getCampaignTemplateSchedule(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params.  The API returns all campaign templates matching the query parameters.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary List Campaign Templates
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *eq, ge, gt, in, le, lt, ne, sw*  **id**: *eq, ge, gt, in, le, lt, ne, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignTemplates: function (limit, offset, count, sorters, filters, axiosOptions) {
            return localVarFp.getCampaignTemplates(limit, offset, count, sorters, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API reassigns the specified certifications from one identity to another.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Reassign Certifications
         * @param {string} id The certification campaign ID
         * @param {AdminReviewReassign} adminReviewReassign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        move: function (id, adminReviewReassign, axiosOptions) {
            return localVarFp.move(id, adminReviewReassign, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Update a Campaign Template
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * deadlineDuration * campaign (all fields that are allowed during create)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchCampaignTemplate: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchCampaignTemplate(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to overwrite the configuration for campaign reports.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Set Campaign Reports Configuration
         * @param {CampaignReportsConfig} campaignReportsConfig Campaign report configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignReportsConfig: function (campaignReportsConfig, axiosOptions) {
            return localVarFp.setCampaignReportsConfig(campaignReportsConfig, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Set Campaign Template Schedule
         * @param {string} id ID of the campaign template being scheduled.
         * @param {Schedule} [schedule]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setCampaignTemplateSchedule: function (id, schedule, axiosOptions) {
            return localVarFp.setCampaignTemplateSchedule(id, schedule, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Activate a Campaign
         * @param {string} id Campaign ID.
         * @param {ActivateCampaignOptions} [activateCampaignOptions] Optional. If no timezone is specified, the standard UTC timezone is used (i.e. UTC+00:00). Although this can take any timezone, the intended value is the caller\&#39;s timezone. The activation time calculated from the given timezone may cause the campaign deadline time to be modified, but it will remain within the original date. The timezone must be in a valid ISO 8601 format.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign: function (id, activateCampaignOptions, axiosOptions) {
            return localVarFp.startCampaign(id, activateCampaignOptions, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to run a remediation scan task for a certification campaign.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary Run Campaign Remediation Scan
         * @param {string} id ID of the campaign the remediation scan is being run for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignRemediationScan: function (id, axiosOptions) {
            return localVarFp.startCampaignRemediationScan(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to run a report for a certification campaign.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
         * @summary Run Campaign Report
         * @param {string} id ID of the campaign the report is being run for.
         * @param {ReportType} type Type of the report to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startCampaignReport: function (id, type, axiosOptions) {
            return localVarFp.startCampaignReport(id, type, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to generate a new certification campaign from a campaign template.  The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation.  Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020).  Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html).  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Generate a Campaign from Template
         * @param {string} id ID of the campaign template to use for generation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startGenerateCampaignTemplate: function (id, axiosOptions) {
            return localVarFp.startGenerateCampaignTemplate(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
         * @summary Update a Campaign
         * @param {string} id ID of the campaign template being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of campaign update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The fields that can be patched differ based on the status of the campaign.  When the campaign is in the *STAGED* status, you can patch these fields: * name * description * recommendationsEnabled * deadline * emailNotificationEnabled * autoRevokeAllowed  When the campaign is in the *ACTIVE* status, you can patch these fields: * deadline
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.updateCampaign(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.CertificationCampaignsApiFactory = CertificationCampaignsApiFactory;
/**
 * CertificationCampaignsApi - object-oriented interface
 * @export
 * @class CertificationCampaignsApi
 * @extends {BaseAPI}
 */
var CertificationCampaignsApi = /** @class */ (function (_super) {
    __extends(CertificationCampaignsApi, _super);
    function CertificationCampaignsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * :::caution  This endpoint will run successfully for any campaigns that are **past due**.  This endpoint will return a content error if the campaign is **not past due**.  :::  Use this API to complete a certification campaign. This functionality is provided to admins so that they can complete a certification even if all items have not been completed.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Complete a Campaign
     * @param {CertificationCampaignsApiCompleteCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.completeCampaign = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).completeCampaign(requestParameters.id, requestParameters.campaignCompleteOptions, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to create a certification campaign with the information provided in the request body.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Create a campaign
     * @param {CertificationCampaignsApiCreateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.createCampaign = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).createCampaign(requestParameters.campaign, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to create a certification campaign template based on campaign.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Create a Campaign Template
     * @param {CertificationCampaignsApiCreateCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.createCampaignTemplate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).createCampaignTemplate(requestParameters.campaignTemplate, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to delete a certification campaign template by ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Delete a Campaign Template
     * @param {CertificationCampaignsApiDeleteCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.deleteCampaignTemplate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).deleteCampaignTemplate(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to delete the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Delete Campaign Template Schedule
     * @param {CertificationCampaignsApiDeleteCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.deleteCampaignTemplateSchedule = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).deleteCampaignTemplateSchedule(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to delete certification campaigns whose IDs are specified in the provided list of campaign IDs.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Delete Campaigns
     * @param {CertificationCampaignsApiDeleteCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.deleteCampaigns = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).deleteCampaigns(requestParameters.campaignsDeleteRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to get a list of campaigns. This API can provide increased level of detail for each campaign for the correct provided query.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
     * @summary List Campaigns
     * @param {CertificationCampaignsApiGetActiveCampaignsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.getActiveCampaigns = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).getActiveCampaigns(requestParameters.detail, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to get information for an existing certification campaign by the campaign\'s ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Get Campaign
     * @param {CertificationCampaignsApiGetCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.getCampaign = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).getCampaign(requestParameters.id, requestParameters.detail, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to fetch all reports for a certification campaign by campaign ID.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
     * @summary Get Campaign Reports
     * @param {CertificationCampaignsApiGetCampaignReportsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.getCampaignReports = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).getCampaignReports(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to fetch the configuration for certification campaign reports. The configuration includes only one element - identity attributes defined as custom report columns.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Get Campaign Reports Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.getCampaignReportsConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).getCampaignReportsConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to fetch a certification campaign template by ID.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Get a Campaign Template
     * @param {CertificationCampaignsApiGetCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.getCampaignTemplate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).getCampaignTemplate(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to get the schedule for a certification campaign template. The API returns a 404 if there is no schedule set.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Get Campaign Template Schedule
     * @param {CertificationCampaignsApiGetCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.getCampaignTemplateSchedule = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).getCampaignTemplateSchedule(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to get a list of all campaign templates. Scope can be reduced through standard V3 query params.  The API returns all campaign templates matching the query parameters.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary List Campaign Templates
     * @param {CertificationCampaignsApiGetCampaignTemplatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.getCampaignTemplates = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).getCampaignTemplates(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API reassigns the specified certifications from one identity to another.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Reassign Certifications
     * @param {CertificationCampaignsApiMoveRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.move = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).move(requestParameters.id, requestParameters.adminReviewReassign, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to update individual fields on a certification campaign template, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Update a Campaign Template
     * @param {CertificationCampaignsApiPatchCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.patchCampaignTemplate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).patchCampaignTemplate(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to overwrite the configuration for campaign reports.   A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Set Campaign Reports Configuration
     * @param {CertificationCampaignsApiSetCampaignReportsConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.setCampaignReportsConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).setCampaignReportsConfig(requestParameters.campaignReportsConfig, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to set the schedule for a certification campaign template. If a schedule already exists, the API overwrites it with the new one.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Set Campaign Template Schedule
     * @param {CertificationCampaignsApiSetCampaignTemplateScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.setCampaignTemplateSchedule = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).setCampaignTemplateSchedule(requestParameters.id, requestParameters.schedule, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to submit a job to activate the certified campaign with the specified ID. The campaign must be staged.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Activate a Campaign
     * @param {CertificationCampaignsApiStartCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.startCampaign = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).startCampaign(requestParameters.id, requestParameters.activateCampaignOptions, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to run a remediation scan task for a certification campaign.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
     * @summary Run Campaign Remediation Scan
     * @param {CertificationCampaignsApiStartCampaignRemediationScanRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.startCampaignRemediationScan = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).startCampaignRemediationScan(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to run a report for a certification campaign.  A token with ORG_ADMIN, CERT_ADMIN or REPORT_ADMIN authority is required to call this API.
     * @summary Run Campaign Report
     * @param {CertificationCampaignsApiStartCampaignReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.startCampaignReport = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).startCampaignReport(requestParameters.id, requestParameters.type, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to generate a new certification campaign from a campaign template.  The campaign object contained in the template has special formatting applied to its name and description fields that determine the generated campaign\'s name/description. Placeholders in those fields are formatted with the current date and time upon generation.  Placeholders consist of a percent sign followed by a letter indicating what should be inserted. For example, \"%Y\" inserts the current year, and a campaign template named \"Campaign for %y\" generates a campaign called \"Campaign for 2020\" (assuming the year at generation time is 2020).  Valid placeholders are the date/time conversion suffix characters supported by [java.util.Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html).  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Generate a Campaign from Template
     * @param {CertificationCampaignsApiStartGenerateCampaignTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.startGenerateCampaignTemplate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).startGenerateCampaignTemplate(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to update individual fields on a certification campaign, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API.
     * @summary Update a Campaign
     * @param {CertificationCampaignsApiUpdateCampaignRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationCampaignsApi
     */
    CertificationCampaignsApi.prototype.updateCampaign = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationCampaignsApiFp)(this.configuration).updateCampaign(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return CertificationCampaignsApi;
}(base_1.BaseAPI));
exports.CertificationCampaignsApi = CertificationCampaignsApi;
/**
 * CertificationSummariesApi - axios parameter creator
 * @export
 */
var CertificationSummariesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries: function (id, type, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getIdentityAccessSummaries', 'id', id);
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('getIdentityAccessSummaries', 'type', type);
                            localVarPath = "/certifications/{id}/access-summaries/{type}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)))
                                .replace("{".concat("type", "}"), encodeURIComponent(String(type)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary: function (id, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getIdentityDecisionSummary', 'id', id);
                            localVarPath = "/certifications/{id}/decision-summary"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getIdentitySummaries', 'id', id);
                            localVarPath = "/certifications/{id}/identity-summaries"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary: function (id, identitySummaryId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getIdentitySummary', 'id', id);
                            // verify required parameter 'identitySummaryId' is not null or undefined
                            (0, common_1.assertParamExists)('getIdentitySummary', 'identitySummaryId', identitySummaryId);
                            localVarPath = "/certifications/{id}/identity-summaries/{identitySummaryId}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)))
                                .replace("{".concat("identitySummaryId", "}"), encodeURIComponent(String(identitySummaryId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.CertificationSummariesApiAxiosParamCreator = CertificationSummariesApiAxiosParamCreator;
/**
 * CertificationSummariesApi - functional programming interface
 * @export
 */
var CertificationSummariesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.CertificationSummariesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries: function (id, type, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getIdentityAccessSummaries(id, type, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary: function (id, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getIdentityDecisionSummary(id, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getIdentitySummaries(id, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary: function (id, identitySummaryId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getIdentitySummary(id, identitySummaryId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.CertificationSummariesApiFp = CertificationSummariesApiFp;
/**
 * CertificationSummariesApi - factory interface
 * @export
 */
var CertificationSummariesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.CertificationSummariesApiFp)(configuration);
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries: function (id, type, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.getIdentityAccessSummaries(id, type, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary: function (id, filters, axiosOptions) {
            return localVarFp.getIdentityDecisionSummary(id, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.getIdentitySummaries(id, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary: function (id, identitySummaryId, axiosOptions) {
            return localVarFp.getIdentitySummary(id, identitySummaryId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.CertificationSummariesApiFactory = CertificationSummariesApiFactory;
/**
 * CertificationSummariesApi - object-oriented interface
 * @export
 * @class CertificationSummariesApi
 * @extends {BaseAPI}
 */
var CertificationSummariesApi = /** @class */ (function (_super) {
    __extends(CertificationSummariesApi, _super);
    function CertificationSummariesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Access Summaries
     * @param {CertificationSummariesApiGetIdentityAccessSummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    CertificationSummariesApi.prototype.getIdentityAccessSummaries = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationSummariesApiFp)(this.configuration).getIdentityAccessSummaries(requestParameters.id, requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Summary of Certification Decisions
     * @param {CertificationSummariesApiGetIdentityDecisionSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    CertificationSummariesApi.prototype.getIdentityDecisionSummary = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationSummariesApiFp)(this.configuration).getIdentityDecisionSummary(requestParameters.id, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Identity Summaries for Campaign Certification
     * @param {CertificationSummariesApiGetIdentitySummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    CertificationSummariesApi.prototype.getIdentitySummaries = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationSummariesApiFp)(this.configuration).getIdentitySummaries(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Summary for Identity
     * @param {CertificationSummariesApiGetIdentitySummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    CertificationSummariesApi.prototype.getIdentitySummary = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationSummariesApiFp)(this.configuration).getIdentitySummary(requestParameters.id, requestParameters.identitySummaryId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return CertificationSummariesApi;
}(base_1.BaseAPI));
exports.CertificationSummariesApi = CertificationSummariesApi;
/**
 * CertificationsApi - axios parameter creator
 * @export
 */
var CertificationsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {string} id The task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCertificationTask: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getCertificationTask', 'id', id);
                            localVarPath = "/certification-tasks/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getIdentityCertification', 'id', id);
                            localVarPath = "/certifications/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationItemPermissions: function (certificationId, itemId, filters, limit, offset, count, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'certificationId' is not null or undefined
                            (0, common_1.assertParamExists)('getIdentityCertificationItemPermissions', 'certificationId', certificationId);
                            // verify required parameter 'itemId' is not null or undefined
                            (0, common_1.assertParamExists)('getIdentityCertificationItemPermissions', 'itemId', itemId);
                            localVarPath = "/certifications/{certificationId}/access-review-items/{itemId}/permissions"
                                .replace("{".concat("certificationId", "}"), encodeURIComponent(String(certificationId)))
                                .replace("{".concat("itemId", "}"), encodeURIComponent(String(itemId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPendingCertificationTasks: function (reviewerIdentity, limit, offset, count, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/certification-tasks";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (reviewerIdentity !== undefined) {
                                localVarQueryParameter['reviewer-identity'] = reviewerIdentity;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCertificationReviewers: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('listCertificationReviewers', 'id', id);
                            localVarPath = "/certifications/{id}/reviewers"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems: function (id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('listIdentityAccessReviewItems', 'id', id);
                            localVarPath = "/certifications/{id}/access-review-items"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            if (entitlements !== undefined) {
                                localVarQueryParameter['entitlements'] = entitlements;
                            }
                            if (accessProfiles !== undefined) {
                                localVarQueryParameter['access-profiles'] = accessProfiles;
                            }
                            if (roles !== undefined) {
                                localVarQueryParameter['roles'] = roles;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
         * @summary List Identity Campaign Certifications
         * @param {string} [reviewerIdentity] Reviewer\&#39;s identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications: function (reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/certifications";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (reviewerIdentity !== undefined) {
                                localVarQueryParameter['reviewer-identity'] = reviewerIdentity;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision: function (id, reviewDecision, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('makeIdentityDecision', 'id', id);
                            // verify required parameter 'reviewDecision' is not null or undefined
                            (0, common_1.assertParamExists)('makeIdentityDecision', 'reviewDecision', reviewDecision);
                            localVarPath = "/certifications/{id}/decide"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(reviewDecision, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications: function (id, reviewReassign, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('reassignIdentityCertifications', 'id', id);
                            // verify required parameter 'reviewReassign' is not null or undefined
                            (0, common_1.assertParamExists)('reassignIdentityCertifications', 'reviewReassign', reviewReassign);
                            localVarPath = "/certifications/{id}/reassign"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(reviewReassign, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('signOffIdentityCertification', 'id', id);
                            localVarPath = "/certifications/{id}/sign-off"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReassignCertsAsync: function (id, reviewReassign, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('submitReassignCertsAsync', 'id', id);
                            // verify required parameter 'reviewReassign' is not null or undefined
                            (0, common_1.assertParamExists)('submitReassignCertsAsync', 'reviewReassign', reviewReassign);
                            localVarPath = "/certifications/{id}/reassign-async"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(reviewReassign, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.CertificationsApiAxiosParamCreator = CertificationsApiAxiosParamCreator;
/**
 * CertificationsApi - functional programming interface
 * @export
 */
var CertificationsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.CertificationsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {string} id The task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCertificationTask: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCertificationTask(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getIdentityCertification(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationItemPermissions: function (certificationId, itemId, filters, limit, offset, count, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getIdentityCertificationItemPermissions(certificationId, itemId, filters, limit, offset, count, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPendingCertificationTasks: function (reviewerIdentity, limit, offset, count, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPendingCertificationTasks(reviewerIdentity, limit, offset, count, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCertificationReviewers: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listCertificationReviewers(id, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems: function (id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listIdentityAccessReviewItems(id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
         * @summary List Identity Campaign Certifications
         * @param {string} [reviewerIdentity] Reviewer\&#39;s identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications: function (reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listIdentityCertifications(reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision: function (id, reviewDecision, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.makeIdentityDecision(id, reviewDecision, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications: function (id, reviewReassign, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.reassignIdentityCertifications(id, reviewReassign, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.signOffIdentityCertification(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReassignCertsAsync: function (id, reviewReassign, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.submitReassignCertsAsync(id, reviewReassign, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.CertificationsApiFp = CertificationsApiFp;
/**
 * CertificationsApi - factory interface
 * @export
 */
var CertificationsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.CertificationsApiFp)(configuration);
    return {
        /**
         * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
         * @summary Certification Task by ID
         * @param {string} id The task ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCertificationTask: function (id, axiosOptions) {
            return localVarFp.getCertificationTask(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification: function (id, axiosOptions) {
            return localVarFp.getIdentityCertification(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Permissions for Entitlement Certification Item
         * @param {string} certificationId The certification ID
         * @param {string} itemId The certification item ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **target**: *eq, sw*  **rights**: *ca*  Supported composite operators: *and, or*  All field values (second filter operands) are case-insensitive for this API.  Only a single *and* or *or* composite filter operator may be used. It must also be used between a target filter and a rights filter, not between 2 filters for the same field.  For example, the following is valid: &#x60;?filters&#x3D;rights+ca+(%22CREATE%22)+and+target+eq+%22SYS.OBJAUTH2%22&#x60;  The following is invalid: 1?filters&#x3D;rights+ca+(%22CREATE%22)+and+rights+ca+(%SELECT%22)1
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertificationItemPermissions: function (certificationId, itemId, filters, limit, offset, count, axiosOptions) {
            return localVarFp.getIdentityCertificationItemPermissions(certificationId, itemId, filters, limit, offset, count, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
         * @summary List of Pending Certification Tasks
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **targetId**: *eq, in*  **type**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPendingCertificationTasks: function (reviewerIdentity, limit, offset, count, filters, axiosOptions) {
            return localVarFp.getPendingCertificationTasks(reviewerIdentity, limit, offset, count, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary List of Reviewers for certification
         * @param {string} id The certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **email**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCertificationReviewers: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.listCertificationReviewers(id, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type**: *eq*  **access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems: function (id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions) {
            return localVarFp.listIdentityAccessReviewItems(id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
         * @summary List Identity Campaign Certifications
         * @param {string} [reviewerIdentity] Reviewer\&#39;s identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **campaign.id**: *eq, in*  **phase**: *eq*  **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications: function (reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.listIdentityCertifications(reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision: function (id, reviewDecision, axiosOptions) {
            return localVarFp.makeIdentityDecision(id, reviewDecision, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications: function (id, reviewReassign, axiosOptions) {
            return localVarFp.reassignIdentityCertifications(id, reviewReassign, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification: function (id, axiosOptions) {
            return localVarFp.signOffIdentityCertification(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Reassign Certifications Asynchronously
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitReassignCertsAsync: function (id, reviewReassign, axiosOptions) {
            return localVarFp.submitReassignCertsAsync(id, reviewReassign, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.CertificationsApiFactory = CertificationsApiFactory;
/**
 * CertificationsApi - object-oriented interface
 * @export
 * @class CertificationsApi
 * @extends {BaseAPI}
 */
var CertificationsApi = /** @class */ (function (_super) {
    __extends(CertificationsApi, _super);
    function CertificationsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API returns the certification task for the specified ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for the specified certification can also call this API.
     * @summary Certification Task by ID
     * @param {CertificationsApiGetCertificationTaskRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.getCertificationTask = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationsApiFp)(this.configuration).getCertificationTask(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Identity Certification by ID
     * @param {CertificationsApiGetIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.getIdentityCertification = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationsApiFp)(this.configuration).getIdentityCertification(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the permissions associated with an entitlement certification item based on the certification item\'s ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Permissions for Entitlement Certification Item
     * @param {CertificationsApiGetIdentityCertificationItemPermissionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.getIdentityCertificationItemPermissions = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationsApiFp)(this.configuration).getIdentityCertificationItemPermissions(requestParameters.certificationId, requestParameters.itemId, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a list of pending (`QUEUED` or `IN_PROGRESS`) certification tasks. Any authenticated token can call this API, but only certification tasks you are authorized to review will be returned.
     * @summary List of Pending Certification Tasks
     * @param {CertificationsApiGetPendingCertificationTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.getPendingCertificationTasks = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.CertificationsApiFp)(this.configuration).getPendingCertificationTasks(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a list of reviewers for the certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary List of Reviewers for certification
     * @param {CertificationsApiListCertificationReviewersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.listCertificationReviewers = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationsApiFp)(this.configuration).listCertificationReviewers(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary List of Access Review Items
     * @param {CertificationsApiListIdentityAccessReviewItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.listIdentityAccessReviewItems = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationsApiFp)(this.configuration).listIdentityAccessReviewItems(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.entitlements, requestParameters.accessProfiles, requestParameters.roles, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to get a list of identity campaign certifications for the specified query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to governance groups.
     * @summary List Identity Campaign Certifications
     * @param {CertificationsApiListIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.listIdentityCertifications = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.CertificationsApiFp)(this.configuration).listIdentityCertifications(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Decide on a Certification Item
     * @param {CertificationsApiMakeIdentityDecisionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.makeIdentityDecision = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationsApiFp)(this.configuration).makeIdentityDecision(requestParameters.id, requestParameters.reviewDecision, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Reassign Identities or Items
     * @param {CertificationsApiReassignIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.reassignIdentityCertifications = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationsApiFp)(this.configuration).reassignIdentityCertifications(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Finalize Identity Certification Decisions
     * @param {CertificationsApiSignOffIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.signOffIdentityCertification = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationsApiFp)(this.configuration).signOffIdentityCertification(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API initiates a task to reassign up to 500 identities or items in an identity campaign certification to another reviewer. The `certification-tasks` API can be used to get an updated status on the task and determine when the reassignment is complete. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Reassign Certifications Asynchronously
     * @param {CertificationsApiSubmitReassignCertsAsyncRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    CertificationsApi.prototype.submitReassignCertsAsync = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.CertificationsApiFp)(this.configuration).submitReassignCertsAsync(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return CertificationsApi;
}(base_1.BaseAPI));
exports.CertificationsApi = CertificationsApi;
/**
 * ConfigurationHubApi - axios parameter creator
 * @export
 */
var ConfigurationHubApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Creates an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingRequest} objectMappingRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMapping: function (sourceOrg, objectMappingRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceOrg' is not null or undefined
                            (0, common_1.assertParamExists)('createObjectMapping', 'sourceOrg', sourceOrg);
                            // verify required parameter 'objectMappingRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createObjectMapping', 'objectMappingRequest', objectMappingRequest);
                            localVarPath = "/configuration-hub/object-mappings/{sourceOrg}"
                                .replace("{".concat("sourceOrg", "}"), encodeURIComponent(String(sourceOrg)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(objectMappingRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk creates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkCreateRequest} objectMappingBulkCreateRequest The bulk create object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMappings: function (sourceOrg, objectMappingBulkCreateRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceOrg' is not null or undefined
                            (0, common_1.assertParamExists)('createObjectMappings', 'sourceOrg', sourceOrg);
                            // verify required parameter 'objectMappingBulkCreateRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createObjectMappings', 'objectMappingBulkCreateRequest', objectMappingBulkCreateRequest);
                            localVarPath = "/configuration-hub/object-mappings/{sourceOrg}/bulk-create"
                                .replace("{".concat("sourceOrg", "}"), encodeURIComponent(String(sourceOrg)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(objectMappingBulkCreateRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Deletes an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {string} objectMappingId The id of the object mapping to be deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectMapping: function (sourceOrg, objectMappingId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceOrg' is not null or undefined
                            (0, common_1.assertParamExists)('deleteObjectMapping', 'sourceOrg', sourceOrg);
                            // verify required parameter 'objectMappingId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteObjectMapping', 'objectMappingId', objectMappingId);
                            localVarPath = "/configuration-hub/object-mappings/{sourceOrg}/{objectMappingId}"
                                .replace("{".concat("sourceOrg", "}"), encodeURIComponent(String(sourceOrg)))
                                .replace("{".concat("objectMappingId", "}"), encodeURIComponent(String(objectMappingId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This deletes an Uploaded backup based on job ID. On success, this endpoint will return an empty response. The job id can be obtained from the response after a successful upload, or the list uploads endpoint. The following scopes are required to access this endpoint: sp:config:manage
         * @summary Deletes an uploaded backup file
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadedBackup: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteUploadedBackup', 'id', id);
                            localVarPath = "/configuration-hub/backups/uploads/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
         * @summary Gets list of object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getObjectMappings: function (sourceOrg, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceOrg' is not null or undefined
                            (0, common_1.assertParamExists)('getObjectMappings', 'sourceOrg', sourceOrg);
                            localVarPath = "/configuration-hub/object-mappings/{sourceOrg}"
                                .replace("{".concat("sourceOrg", "}"), encodeURIComponent(String(sourceOrg)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns all the information and status of an upload job. - sp:config-backups:read
         * @summary Get an uploaded backup\'s information
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedBackup: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getUploadedBackup', 'id', id);
                            localVarPath = "/configuration-hub/backups/uploads/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns a list of the current uploaded backups associated with the current tenant. A filter \"status\" can be added to only return the Completed, Failed, or Successful uploads
         * @summary Gets list of Uploaded backups
         * @param {string} [status] Filter listed uploaded backups by status of operation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedBackups: function (status, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/configuration-hub/backups/uploads";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (status !== undefined) {
                                localVarQueryParameter['status'] = status;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This post will upload a JSON backup file into a tenant. Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types that currently support by upload file functionality are the same as the ones supported by our regular backup functionality. here: [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).  The request will need the following security scope: - sp:config:manage
         * @summary Uploads a backup file
         * @param {any} data JSON file containing the objects to be imported.
         * @param {string} name Name that will be assigned to the uploaded file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importUploadedBackup: function (data, name, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'data' is not null or undefined
                            (0, common_1.assertParamExists)('importUploadedBackup', 'data', data);
                            // verify required parameter 'name' is not null or undefined
                            (0, common_1.assertParamExists)('importUploadedBackup', 'name', name);
                            localVarPath = "/configuration-hub/backups/uploads";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (data !== undefined) {
                                localVarFormParams.append('data', data);
                            }
                            if (name !== undefined) {
                                localVarFormParams.append('name', name);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk updates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkPatchRequest} objectMappingBulkPatchRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectMappings: function (sourceOrg, objectMappingBulkPatchRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceOrg' is not null or undefined
                            (0, common_1.assertParamExists)('updateObjectMappings', 'sourceOrg', sourceOrg);
                            // verify required parameter 'objectMappingBulkPatchRequest' is not null or undefined
                            (0, common_1.assertParamExists)('updateObjectMappings', 'objectMappingBulkPatchRequest', objectMappingBulkPatchRequest);
                            localVarPath = "/configuration-hub/object-mappings/{sourceOrg}/bulk-patch"
                                .replace("{".concat("sourceOrg", "}"), encodeURIComponent(String(sourceOrg)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(objectMappingBulkPatchRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ConfigurationHubApiAxiosParamCreator = ConfigurationHubApiAxiosParamCreator;
/**
 * ConfigurationHubApi - functional programming interface
 * @export
 */
var ConfigurationHubApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ConfigurationHubApiAxiosParamCreator)(configuration);
    return {
        /**
         * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Creates an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingRequest} objectMappingRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMapping: function (sourceOrg, objectMappingRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createObjectMapping(sourceOrg, objectMappingRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk creates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkCreateRequest} objectMappingBulkCreateRequest The bulk create object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMappings: function (sourceOrg, objectMappingBulkCreateRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createObjectMappings(sourceOrg, objectMappingBulkCreateRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Deletes an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {string} objectMappingId The id of the object mapping to be deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectMapping: function (sourceOrg, objectMappingId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteObjectMapping(sourceOrg, objectMappingId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This deletes an Uploaded backup based on job ID. On success, this endpoint will return an empty response. The job id can be obtained from the response after a successful upload, or the list uploads endpoint. The following scopes are required to access this endpoint: sp:config:manage
         * @summary Deletes an uploaded backup file
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadedBackup: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteUploadedBackup(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
         * @summary Gets list of object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getObjectMappings: function (sourceOrg, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getObjectMappings(sourceOrg, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns all the information and status of an upload job. - sp:config-backups:read
         * @summary Get an uploaded backup\'s information
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedBackup: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUploadedBackup(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of the current uploaded backups associated with the current tenant. A filter \"status\" can be added to only return the Completed, Failed, or Successful uploads
         * @summary Gets list of Uploaded backups
         * @param {string} [status] Filter listed uploaded backups by status of operation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedBackups: function (status, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUploadedBackups(status, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This post will upload a JSON backup file into a tenant. Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types that currently support by upload file functionality are the same as the ones supported by our regular backup functionality. here: [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).  The request will need the following security scope: - sp:config:manage
         * @summary Uploads a backup file
         * @param {any} data JSON file containing the objects to be imported.
         * @param {string} name Name that will be assigned to the uploaded file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importUploadedBackup: function (data, name, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.importUploadedBackup(data, name, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk updates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkPatchRequest} objectMappingBulkPatchRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectMappings: function (sourceOrg, objectMappingBulkPatchRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateObjectMappings(sourceOrg, objectMappingBulkPatchRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ConfigurationHubApiFp = ConfigurationHubApiFp;
/**
 * ConfigurationHubApi - factory interface
 * @export
 */
var ConfigurationHubApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ConfigurationHubApiFp)(configuration);
    return {
        /**
         * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Creates an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingRequest} objectMappingRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMapping: function (sourceOrg, objectMappingRequest, axiosOptions) {
            return localVarFp.createObjectMapping(sourceOrg, objectMappingRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk creates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkCreateRequest} objectMappingBulkCreateRequest The bulk create object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createObjectMappings: function (sourceOrg, objectMappingBulkCreateRequest, axiosOptions) {
            return localVarFp.createObjectMappings(sourceOrg, objectMappingBulkCreateRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Deletes an object mapping
         * @param {string} sourceOrg The name of the source org.
         * @param {string} objectMappingId The id of the object mapping to be deleted.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectMapping: function (sourceOrg, objectMappingId, axiosOptions) {
            return localVarFp.deleteObjectMapping(sourceOrg, objectMappingId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This deletes an Uploaded backup based on job ID. On success, this endpoint will return an empty response. The job id can be obtained from the response after a successful upload, or the list uploads endpoint. The following scopes are required to access this endpoint: sp:config:manage
         * @summary Deletes an uploaded backup file
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadedBackup: function (id, axiosOptions) {
            return localVarFp.deleteUploadedBackup(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
         * @summary Gets list of object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getObjectMappings: function (sourceOrg, axiosOptions) {
            return localVarFp.getObjectMappings(sourceOrg, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns all the information and status of an upload job. - sp:config-backups:read
         * @summary Get an uploaded backup\'s information
         * @param {string} id The id of the uploaded backup.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedBackup: function (id, axiosOptions) {
            return localVarFp.getUploadedBackup(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of the current uploaded backups associated with the current tenant. A filter \"status\" can be added to only return the Completed, Failed, or Successful uploads
         * @summary Gets list of Uploaded backups
         * @param {string} [status] Filter listed uploaded backups by status of operation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedBackups: function (status, axiosOptions) {
            return localVarFp.getUploadedBackups(status, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This post will upload a JSON backup file into a tenant. Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types that currently support by upload file functionality are the same as the ones supported by our regular backup functionality. here: [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).  The request will need the following security scope: - sp:config:manage
         * @summary Uploads a backup file
         * @param {any} data JSON file containing the objects to be imported.
         * @param {string} name Name that will be assigned to the uploaded file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importUploadedBackup: function (data, name, axiosOptions) {
            return localVarFp.importUploadedBackup(data, name, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
         * @summary Bulk updates object mappings
         * @param {string} sourceOrg The name of the source org.
         * @param {ObjectMappingBulkPatchRequest} objectMappingBulkPatchRequest The object mapping request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectMappings: function (sourceOrg, objectMappingBulkPatchRequest, axiosOptions) {
            return localVarFp.updateObjectMappings(sourceOrg, objectMappingBulkPatchRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ConfigurationHubApiFactory = ConfigurationHubApiFactory;
/**
 * ConfigurationHubApi - object-oriented interface
 * @export
 * @class ConfigurationHubApi
 * @extends {BaseAPI}
 */
var ConfigurationHubApi = /** @class */ (function (_super) {
    __extends(ConfigurationHubApi, _super);
    function ConfigurationHubApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This creates an object mapping between current org and source org. Source org should be \"default\" when creating an object mapping that is not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Creates an object mapping
     * @param {ConfigurationHubApiCreateObjectMappingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    ConfigurationHubApi.prototype.createObjectMapping = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConfigurationHubApiFp)(this.configuration).createObjectMapping(requestParameters.sourceOrg, requestParameters.objectMappingRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This creates a set of object mappings (Max 25) between current org and source org. Source org should be \"default\" when creating object mappings that are not to be associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Bulk creates object mappings
     * @param {ConfigurationHubApiCreateObjectMappingsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    ConfigurationHubApi.prototype.createObjectMappings = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConfigurationHubApiFp)(this.configuration).createObjectMappings(requestParameters.sourceOrg, requestParameters.objectMappingBulkCreateRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This deletes an existing object mapping. Source org should be \"default\" when deleting an object mapping that is not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Deletes an object mapping
     * @param {ConfigurationHubApiDeleteObjectMappingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    ConfigurationHubApi.prototype.deleteObjectMapping = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConfigurationHubApiFp)(this.configuration).deleteObjectMapping(requestParameters.sourceOrg, requestParameters.objectMappingId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This deletes an Uploaded backup based on job ID. On success, this endpoint will return an empty response. The job id can be obtained from the response after a successful upload, or the list uploads endpoint. The following scopes are required to access this endpoint: sp:config:manage
     * @summary Deletes an uploaded backup file
     * @param {ConfigurationHubApiDeleteUploadedBackupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    ConfigurationHubApi.prototype.deleteUploadedBackup = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConfigurationHubApiFp)(this.configuration).deleteUploadedBackup(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a list of existing object mappings between current org and source org. Source org should be \"default\" when getting object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:read
     * @summary Gets list of object mappings
     * @param {ConfigurationHubApiGetObjectMappingsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    ConfigurationHubApi.prototype.getObjectMappings = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConfigurationHubApiFp)(this.configuration).getObjectMappings(requestParameters.sourceOrg, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns all the information and status of an upload job. - sp:config-backups:read
     * @summary Get an uploaded backup\'s information
     * @param {ConfigurationHubApiGetUploadedBackupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    ConfigurationHubApi.prototype.getUploadedBackup = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConfigurationHubApiFp)(this.configuration).getUploadedBackup(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of the current uploaded backups associated with the current tenant. A filter \"status\" can be added to only return the Completed, Failed, or Successful uploads
     * @summary Gets list of Uploaded backups
     * @param {ConfigurationHubApiGetUploadedBackupsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    ConfigurationHubApi.prototype.getUploadedBackups = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.ConfigurationHubApiFp)(this.configuration).getUploadedBackups(requestParameters.status, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This post will upload a JSON backup file into a tenant. Configuration files can be managed and deployed via Configuration Hub by uploading a json file which contains configuration data. The JSON file should be the same as the one used by our import endpoints. The object types that currently support by upload file functionality are the same as the ones supported by our regular backup functionality. here: [SaaS Configuration](https://developer.sailpoint.com/idn/docs/saas-configuration/#supported-objects).  The request will need the following security scope: - sp:config:manage
     * @summary Uploads a backup file
     * @param {ConfigurationHubApiImportUploadedBackupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    ConfigurationHubApi.prototype.importUploadedBackup = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConfigurationHubApiFp)(this.configuration).importUploadedBackup(requestParameters.data, requestParameters.name, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This updates a set of object mappings, only enabled and targetValue fields can be updated. Source org should be \"default\" when updating object mappings that are not associated to any particular org. The request will need the following security scope: - sp:config-object-mapping:manage
     * @summary Bulk updates object mappings
     * @param {ConfigurationHubApiUpdateObjectMappingsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationHubApi
     */
    ConfigurationHubApi.prototype.updateObjectMappings = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConfigurationHubApiFp)(this.configuration).updateObjectMappings(requestParameters.sourceOrg, requestParameters.objectMappingBulkPatchRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ConfigurationHubApi;
}(base_1.BaseAPI));
exports.ConfigurationHubApi = ConfigurationHubApi;
/**
 * ConnectorsApi - axios parameter creator
 * @export
 */
var ConnectorsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Create custom connector. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create custom connector
         * @param {V3CreateConnectorDto} v3CreateConnectorDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCustomConnector: function (v3CreateConnectorDto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'v3CreateConnectorDto' is not null or undefined
                            (0, common_1.assertParamExists)('createCustomConnector', 'v3CreateConnectorDto', v3CreateConnectorDto);
                            localVarPath = "/connectors";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(v3CreateConnectorDto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Delete a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Deletes connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomConnector: function (scriptName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('deleteCustomConnector', 'scriptName', scriptName);
                            localVarPath = "/connectors/{scriptName}"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fetches a connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: function (scriptName, locale, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('getConnector', 'scriptName', scriptName);
                            localVarPath = "/connectors/{scriptName}"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (locale !== undefined) {
                                localVarQueryParameter['locale'] = locale;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fetches a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorCorrelationConfig: function (scriptName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('getConnectorCorrelationConfig', 'scriptName', scriptName);
                            localVarPath = "/connectors/{scriptName}/correlation-config"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector list
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *sw, co*  **type**: *sw, co, eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*  **labels**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorList: function (filters, limit, offset, count, locale, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/connectors";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (locale !== undefined) {
                                localVarQueryParameter['locale'] = locale;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fetches a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceConfig: function (scriptName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('getConnectorSourceConfig', 'scriptName', scriptName);
                            localVarPath = "/connectors/{scriptName}/source-config"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fetches a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceTemplate: function (scriptName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('getConnectorSourceTemplate', 'scriptName', scriptName);
                            localVarPath = "/connectors/{scriptName}/source-template"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fetches a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTranslations: function (scriptName, locale, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('getConnectorTranslations', 'scriptName', scriptName);
                            // verify required parameter 'locale' is not null or undefined
                            (0, common_1.assertParamExists)('getConnectorTranslations', 'locale', locale);
                            localVarPath = "/connectors/{scriptName}/translations/{locale}"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)))
                                .replace("{".concat("locale", "}"), encodeURIComponent(String(locale)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector correlation config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putCorrelationConfig: function (scriptName, file, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('putCorrelationConfig', 'scriptName', scriptName);
                            // verify required parameter 'file' is not null or undefined
                            (0, common_1.assertParamExists)('putCorrelationConfig', 'file', file);
                            localVarPath = "/connectors/{scriptName}/correlation-config"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (file !== undefined) {
                                localVarFormParams.append('file', file);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceConfig: function (scriptName, file, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('putSourceConfig', 'scriptName', scriptName);
                            // verify required parameter 'file' is not null or undefined
                            (0, common_1.assertParamExists)('putSourceConfig', 'file', file);
                            localVarPath = "/connectors/{scriptName}/source-config"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (file !== undefined) {
                                localVarFormParams.append('file', file);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source template xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceTemplate: function (scriptName, file, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('putSourceTemplate', 'scriptName', scriptName);
                            // verify required parameter 'file' is not null or undefined
                            (0, common_1.assertParamExists)('putSourceTemplate', 'file', file);
                            localVarPath = "/connectors/{scriptName}/source-template"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (file !== undefined) {
                                localVarFormParams.append('file', file);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTranslations: function (scriptName, locale, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('putTranslations', 'scriptName', scriptName);
                            // verify required parameter 'locale' is not null or undefined
                            (0, common_1.assertParamExists)('putTranslations', 'locale', locale);
                            localVarPath = "/connectors/{scriptName}/translations/{locale}"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)))
                                .replace("{".concat("locale", "}"), encodeURIComponent(String(locale)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Patch a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API. The following fields are patchable: * connectorMetadata * applicationXml * correlationConfigXml * sourceConfigXml
         * @summary Update connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of connector detail update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector: function (scriptName, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('updateConnector', 'scriptName', scriptName);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('updateConnector', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/connectors/{scriptName}"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ConnectorsApiAxiosParamCreator = ConnectorsApiAxiosParamCreator;
/**
 * ConnectorsApi - functional programming interface
 * @export
 */
var ConnectorsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ConnectorsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create custom connector. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create custom connector
         * @param {V3CreateConnectorDto} v3CreateConnectorDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCustomConnector: function (v3CreateConnectorDto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createCustomConnector(v3CreateConnectorDto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Delete a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Deletes connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomConnector: function (scriptName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteCustomConnector(scriptName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fetches a connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: function (scriptName, locale, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConnector(scriptName, locale, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fetches a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorCorrelationConfig: function (scriptName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConnectorCorrelationConfig(scriptName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector list
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *sw, co*  **type**: *sw, co, eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*  **labels**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorList: function (filters, limit, offset, count, locale, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConnectorList(filters, limit, offset, count, locale, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fetches a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceConfig: function (scriptName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConnectorSourceConfig(scriptName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fetches a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceTemplate: function (scriptName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConnectorSourceTemplate(scriptName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fetches a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTranslations: function (scriptName, locale, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConnectorTranslations(scriptName, locale, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector correlation config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putCorrelationConfig: function (scriptName, file, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putCorrelationConfig(scriptName, file, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceConfig: function (scriptName, file, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putSourceConfig(scriptName, file, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source template xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceTemplate: function (scriptName, file, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putSourceTemplate(scriptName, file, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTranslations: function (scriptName, locale, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putTranslations(scriptName, locale, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Patch a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API. The following fields are patchable: * connectorMetadata * applicationXml * correlationConfigXml * sourceConfigXml
         * @summary Update connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of connector detail update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector: function (scriptName, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateConnector(scriptName, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ConnectorsApiFp = ConnectorsApiFp;
/**
 * ConnectorsApi - factory interface
 * @export
 */
var ConnectorsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ConnectorsApiFp)(configuration);
    return {
        /**
         * Create custom connector. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create custom connector
         * @param {V3CreateConnectorDto} v3CreateConnectorDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createCustomConnector: function (v3CreateConnectorDto, axiosOptions) {
            return localVarFp.createCustomConnector(v3CreateConnectorDto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Deletes connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomConnector: function (scriptName, axiosOptions) {
            return localVarFp.deleteCustomConnector(scriptName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fetches a connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: function (scriptName, locale, axiosOptions) {
            return localVarFp.getConnector(scriptName, locale, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fetches a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorCorrelationConfig: function (scriptName, axiosOptions) {
            return localVarFp.getConnectorCorrelationConfig(scriptName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
         * @summary Gets connector list
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **name**: *sw, co*  **type**: *sw, co, eq*  **directConnect**: *eq*  **category**: *eq*  **features**: *ca*  **labels**: *ca*
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} [locale] The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorList: function (filters, limit, offset, count, locale, axiosOptions) {
            return localVarFp.getConnectorList(filters, limit, offset, count, locale, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fetches a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceConfig: function (scriptName, axiosOptions) {
            return localVarFp.getConnectorSourceConfig(scriptName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fetches a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorSourceTemplate: function (scriptName, axiosOptions) {
            return localVarFp.getConnectorSourceTemplate(scriptName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fetches a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTranslations: function (scriptName, locale, axiosOptions) {
            return localVarFp.getConnectorTranslations(scriptName, locale, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector correlation config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putCorrelationConfig: function (scriptName, file, axiosOptions) {
            return localVarFp.putCorrelationConfig(scriptName, file, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source config xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceConfig: function (scriptName, file, axiosOptions) {
            return localVarFp.putSourceConfig(scriptName, file, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {any} file connector source template xml file
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceTemplate: function (scriptName, file, axiosOptions) {
            return localVarFp.putSourceTemplate(scriptName, file, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {'de' | 'false' | 'fi' | 'sv' | 'ru' | 'pt' | 'ko' | 'zh-TW' | 'en' | 'it' | 'fr' | 'zh-CN' | 'hu' | 'es' | 'cs' | 'ja' | 'pl' | 'da' | 'nl'} locale The locale to apply to the config. If no viable locale is given, it will default to \&quot;en\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTranslations: function (scriptName, locale, axiosOptions) {
            return localVarFp.putTranslations(scriptName, locale, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Patch a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API. The following fields are patchable: * connectorMetadata * applicationXml * correlationConfigXml * sourceConfigXml
         * @summary Update connector by script name
         * @param {string} scriptName The scriptName value of the connector. Scriptname is the unique id generated at connector creation.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of connector detail update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector: function (scriptName, jsonPatchOperation, axiosOptions) {
            return localVarFp.updateConnector(scriptName, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ConnectorsApiFactory = ConnectorsApiFactory;
/**
 * ConnectorsApi - object-oriented interface
 * @export
 * @class ConnectorsApi
 * @extends {BaseAPI}
 */
var ConnectorsApi = /** @class */ (function (_super) {
    __extends(ConnectorsApi, _super);
    function ConnectorsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create custom connector. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create custom connector
     * @param {ConnectorsApiCreateCustomConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.createCustomConnector = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).createCustomConnector(requestParameters.v3CreateConnectorDto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Delete a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @summary Deletes connector by script name
     * @param {ConnectorsApiDeleteCustomConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.deleteCustomConnector = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).deleteCustomConnector(requestParameters.scriptName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fetches a connector that using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @summary Gets connector by script name
     * @param {ConnectorsApiGetConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.getConnector = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).getConnector(requestParameters.scriptName, requestParameters.locale, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fetches a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiGetConnectorCorrelationConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.getConnectorCorrelationConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).getConnectorCorrelationConfig(requestParameters.scriptName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fetches list of connectors that have \'RELEASED\' status using filtering and pagination. A token with ORG_ADMIN authority is required to call this API.
     * @summary Gets connector list
     * @param {ConnectorsApiGetConnectorListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.getConnectorList = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.ConnectorsApiFp)(this.configuration).getConnectorList(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.locale, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fetches a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiGetConnectorSourceConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.getConnectorSourceConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).getConnectorSourceConfig(requestParameters.scriptName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fetches a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiGetConnectorSourceTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.getConnectorSourceTemplate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).getConnectorSourceTemplate(requestParameters.scriptName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fetches a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiGetConnectorTranslationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.getConnectorTranslations = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).getConnectorTranslations(requestParameters.scriptName, requestParameters.locale, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update a connector\'s correlation config using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiPutCorrelationConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.putCorrelationConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).putCorrelationConfig(requestParameters.scriptName, requestParameters.file, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update a connector\'s source config using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiPutSourceConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.putSourceConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).putSourceConfig(requestParameters.scriptName, requestParameters.file, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update a connector\'s source template using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiPutSourceTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.putSourceTemplate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).putSourceTemplate(requestParameters.scriptName, requestParameters.file, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update a connector\'s translations using its script name. A token with ORG_ADMIN authority is required to call this API.
     * @param {ConnectorsApiPutTranslationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.putTranslations = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).putTranslations(requestParameters.scriptName, requestParameters.locale, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Patch a custom connector that using its script name. A token with ORG_ADMIN authority is required to call this API. The following fields are patchable: * connectorMetadata * applicationXml * correlationConfigXml * sourceConfigXml
     * @summary Update connector by script name
     * @param {ConnectorsApiUpdateConnectorRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    ConnectorsApi.prototype.updateConnector = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ConnectorsApiFp)(this.configuration).updateConnector(requestParameters.scriptName, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ConnectorsApi;
}(base_1.BaseAPI));
exports.ConnectorsApi = ConnectorsApi;
/**
 * GlobalTenantSecuritySettingsApi - axios parameter creator
 * @export
 */
var GlobalTenantSecuritySettingsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
         * @summary Create security network configuration.
         * @param {NetworkConfiguration} networkConfiguration Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAuthOrgNetworkConfig: function (networkConfiguration, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'networkConfiguration' is not null or undefined
                            (0, common_1.assertParamExists)('createAuthOrgNetworkConfig', 'networkConfiguration', networkConfiguration);
                            localVarPath = "/auth-org/network-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(networkConfiguration, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the details of an org\'s lockout auth configuration.
         * @summary Get Auth Org Lockout Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgLockoutConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/auth-org/lockout-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgNetworkConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/auth-org/network-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the details of an org\'s service provider auth configuration.
         * @summary Get Service Provider Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgServiceProviderConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/auth-org/service-provider-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the details of an org\'s session auth configuration.
         * @summary Get Auth Org Session Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgSessionConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/auth-org/session-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API updates an existing lockout configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update Auth Org Lockout Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org lockout configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Lockout Config conforms to certain logical guidelines, which are:   1. maximumAttempts &gt;&#x3D; 1 &amp;&amp; maximumAttempts &lt;&#x3D; 15   2. lockoutDuration &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60   3. lockoutWindow &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgLockoutConfig: function (jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchAuthOrgLockoutConfig', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/auth-org/lockout-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update security network configuration.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgNetworkConfig: function (jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchAuthOrgNetworkConfig', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/auth-org/network-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API updates an existing service provider configuration for an org using PATCH.
         * @summary Update Service Provider Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org service provider configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Note: /federationProtocolDetails/0 is IdpDetails /federationProtocolDetails/1 is SpDetails Ensures that the patched ServiceProviderConfig conforms to certain logical guidelines, which are:   1. Do not add or remove any elements in the federation protocol details in the service provider configuration.   2. Do not modify, add, or delete the service provider details element in the federation protocol details.   3. If this is the first time the patched ServiceProviderConfig enables Remote IDP sign-in, it must also include IDPDetails.   4. If the patch enables Remote IDP sign in, the entityID in the IDPDetails cannot be null. IDPDetails must include an entityID.   5. Any JIT configuration update must be valid.  Just in time configuration update must be valid when enabled. This includes:   - A Source ID   - Source attribute mappings   - Source attribute maps have all the required key values (firstName, lastName, email)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgServiceProviderConfig: function (jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchAuthOrgServiceProviderConfig', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/auth-org/service-provider-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API updates an existing session configuration for an org using PATCH.
         * @summary Update Auth Org Session Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org session configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Session Config conforms to certain logical guidelines, which are:   1. maxSessionTime &gt;&#x3D; 1 &amp;&amp; maxSessionTime &lt;&#x3D; 10080 (1 week)   2. maxIdleTime &gt;&#x3D; 1 &amp;&amp; maxIdleTime &lt;&#x3D; 1440 (1 day)   3. maxSessionTime must have a greater duration than maxIdleTime.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgSessionConfig: function (jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchAuthOrgSessionConfig', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/auth-org/session-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.GlobalTenantSecuritySettingsApiAxiosParamCreator = GlobalTenantSecuritySettingsApiAxiosParamCreator;
/**
 * GlobalTenantSecuritySettingsApi - functional programming interface
 * @export
 */
var GlobalTenantSecuritySettingsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.GlobalTenantSecuritySettingsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
         * @summary Create security network configuration.
         * @param {NetworkConfiguration} networkConfiguration Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAuthOrgNetworkConfig: function (networkConfiguration, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createAuthOrgNetworkConfig(networkConfiguration, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the details of an org\'s lockout auth configuration.
         * @summary Get Auth Org Lockout Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgLockoutConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAuthOrgLockoutConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgNetworkConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAuthOrgNetworkConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the details of an org\'s service provider auth configuration.
         * @summary Get Service Provider Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgServiceProviderConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAuthOrgServiceProviderConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the details of an org\'s session auth configuration.
         * @summary Get Auth Org Session Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgSessionConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAuthOrgSessionConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API updates an existing lockout configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update Auth Org Lockout Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org lockout configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Lockout Config conforms to certain logical guidelines, which are:   1. maximumAttempts &gt;&#x3D; 1 &amp;&amp; maximumAttempts &lt;&#x3D; 15   2. lockoutDuration &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60   3. lockoutWindow &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgLockoutConfig: function (jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchAuthOrgLockoutConfig(jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update security network configuration.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgNetworkConfig: function (jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchAuthOrgNetworkConfig(jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API updates an existing service provider configuration for an org using PATCH.
         * @summary Update Service Provider Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org service provider configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Note: /federationProtocolDetails/0 is IdpDetails /federationProtocolDetails/1 is SpDetails Ensures that the patched ServiceProviderConfig conforms to certain logical guidelines, which are:   1. Do not add or remove any elements in the federation protocol details in the service provider configuration.   2. Do not modify, add, or delete the service provider details element in the federation protocol details.   3. If this is the first time the patched ServiceProviderConfig enables Remote IDP sign-in, it must also include IDPDetails.   4. If the patch enables Remote IDP sign in, the entityID in the IDPDetails cannot be null. IDPDetails must include an entityID.   5. Any JIT configuration update must be valid.  Just in time configuration update must be valid when enabled. This includes:   - A Source ID   - Source attribute mappings   - Source attribute maps have all the required key values (firstName, lastName, email)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgServiceProviderConfig: function (jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchAuthOrgServiceProviderConfig(jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API updates an existing session configuration for an org using PATCH.
         * @summary Update Auth Org Session Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org session configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Session Config conforms to certain logical guidelines, which are:   1. maxSessionTime &gt;&#x3D; 1 &amp;&amp; maxSessionTime &lt;&#x3D; 10080 (1 week)   2. maxIdleTime &gt;&#x3D; 1 &amp;&amp; maxIdleTime &lt;&#x3D; 1440 (1 day)   3. maxSessionTime must have a greater duration than maxIdleTime.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgSessionConfig: function (jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchAuthOrgSessionConfig(jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.GlobalTenantSecuritySettingsApiFp = GlobalTenantSecuritySettingsApiFp;
/**
 * GlobalTenantSecuritySettingsApi - factory interface
 * @export
 */
var GlobalTenantSecuritySettingsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.GlobalTenantSecuritySettingsApiFp)(configuration);
    return {
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
         * @summary Create security network configuration.
         * @param {NetworkConfiguration} networkConfiguration Network configuration creation request body.   The following constraints ensure the request body conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAuthOrgNetworkConfig: function (networkConfiguration, axiosOptions) {
            return localVarFp.createAuthOrgNetworkConfig(networkConfiguration, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the details of an org\'s lockout auth configuration.
         * @summary Get Auth Org Lockout Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgLockoutConfig: function (axiosOptions) {
            return localVarFp.getAuthOrgLockoutConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
         * @summary Get security network configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgNetworkConfig: function (axiosOptions) {
            return localVarFp.getAuthOrgNetworkConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the details of an org\'s service provider auth configuration.
         * @summary Get Service Provider Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgServiceProviderConfig: function (axiosOptions) {
            return localVarFp.getAuthOrgServiceProviderConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the details of an org\'s session auth configuration.
         * @summary Get Auth Org Session Configuration.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAuthOrgSessionConfig: function (axiosOptions) {
            return localVarFp.getAuthOrgSessionConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API updates an existing lockout configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update Auth Org Lockout Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org lockout configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Lockout Config conforms to certain logical guidelines, which are:   1. maximumAttempts &gt;&#x3D; 1 &amp;&amp; maximumAttempts &lt;&#x3D; 15   2. lockoutDuration &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60   3. lockoutWindow &gt;&#x3D; 5 &amp;&amp; lockoutDuration &lt;&#x3D; 60
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgLockoutConfig: function (jsonPatchOperation, axiosOptions) {
            return localVarFp.patchAuthOrgLockoutConfig(jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
         * @summary Update security network configuration.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org network configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Network Config conforms to certain logical guidelines, which are:   1. Each string element in the range array must be a valid ip address or ip subnet mask.   2. Each string element in the geolocation array must be 2 characters, and they can only be uppercase letters.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgNetworkConfig: function (jsonPatchOperation, axiosOptions) {
            return localVarFp.patchAuthOrgNetworkConfig(jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API updates an existing service provider configuration for an org using PATCH.
         * @summary Update Service Provider Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org service provider configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Note: /federationProtocolDetails/0 is IdpDetails /federationProtocolDetails/1 is SpDetails Ensures that the patched ServiceProviderConfig conforms to certain logical guidelines, which are:   1. Do not add or remove any elements in the federation protocol details in the service provider configuration.   2. Do not modify, add, or delete the service provider details element in the federation protocol details.   3. If this is the first time the patched ServiceProviderConfig enables Remote IDP sign-in, it must also include IDPDetails.   4. If the patch enables Remote IDP sign in, the entityID in the IDPDetails cannot be null. IDPDetails must include an entityID.   5. Any JIT configuration update must be valid.  Just in time configuration update must be valid when enabled. This includes:   - A Source ID   - Source attribute mappings   - Source attribute maps have all the required key values (firstName, lastName, email)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgServiceProviderConfig: function (jsonPatchOperation, axiosOptions) {
            return localVarFp.patchAuthOrgServiceProviderConfig(jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API updates an existing session configuration for an org using PATCH.
         * @summary Update Auth Org Session Configuration
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of auth org session configuration update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Ensures that the patched Session Config conforms to certain logical guidelines, which are:   1. maxSessionTime &gt;&#x3D; 1 &amp;&amp; maxSessionTime &lt;&#x3D; 10080 (1 week)   2. maxIdleTime &gt;&#x3D; 1 &amp;&amp; maxIdleTime &lt;&#x3D; 1440 (1 day)   3. maxSessionTime must have a greater duration than maxIdleTime.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchAuthOrgSessionConfig: function (jsonPatchOperation, axiosOptions) {
            return localVarFp.patchAuthOrgSessionConfig(jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.GlobalTenantSecuritySettingsApiFactory = GlobalTenantSecuritySettingsApiFactory;
/**
 * GlobalTenantSecuritySettingsApi - object-oriented interface
 * @export
 * @class GlobalTenantSecuritySettingsApi
 * @extends {BaseAPI}
 */
var GlobalTenantSecuritySettingsApi = /** @class */ (function (_super) {
    __extends(GlobalTenantSecuritySettingsApi, _super);
    function GlobalTenantSecuritySettingsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:create\'
     * @summary Create security network configuration.
     * @param {GlobalTenantSecuritySettingsApiCreateAuthOrgNetworkConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    GlobalTenantSecuritySettingsApi.prototype.createAuthOrgNetworkConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.GlobalTenantSecuritySettingsApiFp)(this.configuration).createAuthOrgNetworkConfig(requestParameters.networkConfiguration, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the details of an org\'s lockout auth configuration.
     * @summary Get Auth Org Lockout Configuration.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    GlobalTenantSecuritySettingsApi.prototype.getAuthOrgLockoutConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.GlobalTenantSecuritySettingsApiFp)(this.configuration).getAuthOrgLockoutConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the details of an org\'s network auth configuration. Requires security scope of: \'sp:auth-org:read\'
     * @summary Get security network configuration.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    GlobalTenantSecuritySettingsApi.prototype.getAuthOrgNetworkConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.GlobalTenantSecuritySettingsApiFp)(this.configuration).getAuthOrgNetworkConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the details of an org\'s service provider auth configuration.
     * @summary Get Service Provider Configuration.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    GlobalTenantSecuritySettingsApi.prototype.getAuthOrgServiceProviderConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.GlobalTenantSecuritySettingsApiFp)(this.configuration).getAuthOrgServiceProviderConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the details of an org\'s session auth configuration.
     * @summary Get Auth Org Session Configuration.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    GlobalTenantSecuritySettingsApi.prototype.getAuthOrgSessionConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.GlobalTenantSecuritySettingsApiFp)(this.configuration).getAuthOrgSessionConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API updates an existing lockout configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
     * @summary Update Auth Org Lockout Configuration
     * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgLockoutConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    GlobalTenantSecuritySettingsApi.prototype.patchAuthOrgLockoutConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.GlobalTenantSecuritySettingsApiFp)(this.configuration).patchAuthOrgLockoutConfig(requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API updates an existing network configuration for an org using PATCH  Requires security scope of:  \'sp:auth-org:update\'
     * @summary Update security network configuration.
     * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgNetworkConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    GlobalTenantSecuritySettingsApi.prototype.patchAuthOrgNetworkConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.GlobalTenantSecuritySettingsApiFp)(this.configuration).patchAuthOrgNetworkConfig(requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API updates an existing service provider configuration for an org using PATCH.
     * @summary Update Service Provider Configuration
     * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgServiceProviderConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    GlobalTenantSecuritySettingsApi.prototype.patchAuthOrgServiceProviderConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.GlobalTenantSecuritySettingsApiFp)(this.configuration).patchAuthOrgServiceProviderConfig(requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API updates an existing session configuration for an org using PATCH.
     * @summary Update Auth Org Session Configuration
     * @param {GlobalTenantSecuritySettingsApiPatchAuthOrgSessionConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalTenantSecuritySettingsApi
     */
    GlobalTenantSecuritySettingsApi.prototype.patchAuthOrgSessionConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.GlobalTenantSecuritySettingsApiFp)(this.configuration).patchAuthOrgSessionConfig(requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return GlobalTenantSecuritySettingsApi;
}(base_1.BaseAPI));
exports.GlobalTenantSecuritySettingsApi = GlobalTenantSecuritySettingsApi;
/**
 * IdentityProfilesApi - axios parameter creator
 * @export
 */
var IdentityProfilesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This creates an Identity Profile.  A token with ORG_ADMIN authority is required to call this API to create an Identity Profile.
         * @summary Create an Identity Profile
         * @param {IdentityProfile} identityProfile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityProfile: function (identityProfile, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfile' is not null or undefined
                            (0, common_1.assertParamExists)('createIdentityProfile', 'identityProfile', identityProfile);
                            localVarPath = "/identity-profiles";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(identityProfile, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfile: function (identityProfileId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteIdentityProfile', 'identityProfileId', identityProfileId);
                            localVarPath = "/identity-profiles/{identity-profile-id}"
                                .replace("{".concat("identity-profile-id", "}"), encodeURIComponent(String(identityProfileId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfiles: function (requestBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'requestBody' is not null or undefined
                            (0, common_1.assertParamExists)('deleteIdentityProfiles', 'requestBody', requestBody);
                            localVarPath = "/identity-profiles/bulk-delete";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(requestBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles: function (limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/identity-profiles/export";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig: function (identityProfileId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileId' is not null or undefined
                            (0, common_1.assertParamExists)('getDefaultIdentityAttributeConfig', 'identityProfileId', identityProfileId);
                            localVarPath = "/identity-profiles/{identity-profile-id}/default-identity-attribute-config"
                                .replace("{".concat("identity-profile-id", "}"), encodeURIComponent(String(identityProfileId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This returns a single Identity Profile based on ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile: function (identityProfileId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileId' is not null or undefined
                            (0, common_1.assertParamExists)('getIdentityProfile', 'identityProfileId', identityProfileId);
                            localVarPath = "/identity-profiles/{identity-profile-id}"
                                .replace("{".concat("identity-profile-id", "}"), encodeURIComponent(String(identityProfileId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles: function (identityProfileExportedObject, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileExportedObject' is not null or undefined
                            (0, common_1.assertParamExists)('importIdentityProfiles', 'identityProfileExportedObject', identityProfileExportedObject);
                            localVarPath = "/identity-profiles/import";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(identityProfileExportedObject, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, lt, isnull, sw*  **name**: *eq, ne, in, le, lt, isnull, sw*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles: function (limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/identity-profiles";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to generate a non-persisted preview of the identity object after applying `IdentityAttributeConfig` sent in request body. This API only allows `accountAttribute`, `reference` and `rule` transform types in the `IdentityAttributeConfig` sent in the request body. A token with ORG_ADMIN authority is required to call this API to generate an identity preview.
         * @summary Generate Identity Profile Preview
         * @param {IdentityPreviewRequest} identityPreviewRequest Identity Preview request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        showIdentityPreview: function (identityPreviewRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityPreviewRequest' is not null or undefined
                            (0, common_1.assertParamExists)('showIdentityPreview', 'identityPreviewRequest', identityPreviewRequest);
                            localVarPath = "/identity-profiles/identity-preview";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(identityPreviewRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria. A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncIdentityProfile: function (identityProfileId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileId' is not null or undefined
                            (0, common_1.assertParamExists)('syncIdentityProfile', 'identityProfileId', identityProfileId);
                            localVarPath = "/identity-profiles/{identity-profile-id}/process-identities"
                                .replace("{".concat("identity-profile-id", "}"), encodeURIComponent(String(identityProfileId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This updates the specified Identity Profile.  A token with ORG_ADMIN authority is required to call this API to update the Identity Profile.  Some fields of the Schema cannot be updated. These fields are listed below: * id * name * created * modified * identityCount * identityRefreshRequired * Authoritative Source and Identity Attribute Configuration cannot be modified at once.
         * @summary Update the Identity Profile
         * @param {string} identityProfileId The Identity Profile ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of Identity Profile update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityProfile: function (identityProfileId, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileId' is not null or undefined
                            (0, common_1.assertParamExists)('updateIdentityProfile', 'identityProfileId', identityProfileId);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('updateIdentityProfile', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/identity-profiles/{identity-profile-id}"
                                .replace("{".concat("identity-profile-id", "}"), encodeURIComponent(String(identityProfileId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.IdentityProfilesApiAxiosParamCreator = IdentityProfilesApiAxiosParamCreator;
/**
 * IdentityProfilesApi - functional programming interface
 * @export
 */
var IdentityProfilesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.IdentityProfilesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This creates an Identity Profile.  A token with ORG_ADMIN authority is required to call this API to create an Identity Profile.
         * @summary Create an Identity Profile
         * @param {IdentityProfile} identityProfile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityProfile: function (identityProfile, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createIdentityProfile(identityProfile, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfile: function (identityProfileId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteIdentityProfile(identityProfileId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfiles: function (requestBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteIdentityProfiles(requestBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles: function (limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig: function (identityProfileId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This returns a single Identity Profile based on ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile: function (identityProfileId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getIdentityProfile(identityProfileId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles: function (identityProfileExportedObject, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.importIdentityProfiles(identityProfileExportedObject, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, lt, isnull, sw*  **name**: *eq, ne, in, le, lt, isnull, sw*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles: function (limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to generate a non-persisted preview of the identity object after applying `IdentityAttributeConfig` sent in request body. This API only allows `accountAttribute`, `reference` and `rule` transform types in the `IdentityAttributeConfig` sent in the request body. A token with ORG_ADMIN authority is required to call this API to generate an identity preview.
         * @summary Generate Identity Profile Preview
         * @param {IdentityPreviewRequest} identityPreviewRequest Identity Preview request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        showIdentityPreview: function (identityPreviewRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.showIdentityPreview(identityPreviewRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria. A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncIdentityProfile: function (identityProfileId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.syncIdentityProfile(identityProfileId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This updates the specified Identity Profile.  A token with ORG_ADMIN authority is required to call this API to update the Identity Profile.  Some fields of the Schema cannot be updated. These fields are listed below: * id * name * created * modified * identityCount * identityRefreshRequired * Authoritative Source and Identity Attribute Configuration cannot be modified at once.
         * @summary Update the Identity Profile
         * @param {string} identityProfileId The Identity Profile ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of Identity Profile update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityProfile: function (identityProfileId, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateIdentityProfile(identityProfileId, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.IdentityProfilesApiFp = IdentityProfilesApiFp;
/**
 * IdentityProfilesApi - factory interface
 * @export
 */
var IdentityProfilesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.IdentityProfilesApiFp)(configuration);
    return {
        /**
         * This creates an Identity Profile.  A token with ORG_ADMIN authority is required to call this API to create an Identity Profile.
         * @summary Create an Identity Profile
         * @param {IdentityProfile} identityProfile
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createIdentityProfile: function (identityProfile, axiosOptions) {
            return localVarFp.createIdentityProfile(identityProfile, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete an Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfile: function (identityProfileId, axiosOptions) {
            return localVarFp.deleteIdentityProfile(identityProfileId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
         * @summary Delete Identity Profiles
         * @param {Array<string>} requestBody Identity Profile bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityProfiles: function (requestBody, axiosOptions) {
            return localVarFp.deleteIdentityProfiles(requestBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles: function (limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig: function (identityProfileId, axiosOptions) {
            return localVarFp.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This returns a single Identity Profile based on ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile: function (identityProfileId, axiosOptions) {
            return localVarFp.getIdentityProfile(identityProfileId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles: function (identityProfileExportedObject, axiosOptions) {
            return localVarFp.importIdentityProfiles(identityProfileExportedObject, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne, ge, gt, in, le, lt, isnull, sw*  **name**: *eq, ne, in, le, lt, isnull, sw*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, priority, created, modified, owner.id, owner.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles: function (limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to generate a non-persisted preview of the identity object after applying `IdentityAttributeConfig` sent in request body. This API only allows `accountAttribute`, `reference` and `rule` transform types in the `IdentityAttributeConfig` sent in the request body. A token with ORG_ADMIN authority is required to call this API to generate an identity preview.
         * @summary Generate Identity Profile Preview
         * @param {IdentityPreviewRequest} identityPreviewRequest Identity Preview request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        showIdentityPreview: function (identityPreviewRequest, axiosOptions) {
            return localVarFp.showIdentityPreview(identityPreviewRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria. A token with ORG_ADMIN authority is required to call this API.
         * @summary Process identities under profile
         * @param {string} identityProfileId The Identity Profile ID to be processed
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        syncIdentityProfile: function (identityProfileId, axiosOptions) {
            return localVarFp.syncIdentityProfile(identityProfileId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This updates the specified Identity Profile.  A token with ORG_ADMIN authority is required to call this API to update the Identity Profile.  Some fields of the Schema cannot be updated. These fields are listed below: * id * name * created * modified * identityCount * identityRefreshRequired * Authoritative Source and Identity Attribute Configuration cannot be modified at once.
         * @summary Update the Identity Profile
         * @param {string} identityProfileId The Identity Profile ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of Identity Profile update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityProfile: function (identityProfileId, jsonPatchOperation, axiosOptions) {
            return localVarFp.updateIdentityProfile(identityProfileId, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.IdentityProfilesApiFactory = IdentityProfilesApiFactory;
/**
 * IdentityProfilesApi - object-oriented interface
 * @export
 * @class IdentityProfilesApi
 * @extends {BaseAPI}
 */
var IdentityProfilesApi = /** @class */ (function (_super) {
    __extends(IdentityProfilesApi, _super);
    function IdentityProfilesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This creates an Identity Profile.  A token with ORG_ADMIN authority is required to call this API to create an Identity Profile.
     * @summary Create an Identity Profile
     * @param {IdentityProfilesApiCreateIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.createIdentityProfile = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.IdentityProfilesApiFp)(this.configuration).createIdentityProfile(requestParameters.identityProfile, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This deletes an Identity Profile based on ID.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
     * @summary Delete an Identity Profile
     * @param {IdentityProfilesApiDeleteIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.deleteIdentityProfile = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.IdentityProfilesApiFp)(this.configuration).deleteIdentityProfile(requestParameters.identityProfileId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This deletes multiple Identity Profiles via a list of supplied IDs.  On success, this endpoint will return a reference to the bulk delete task result.  A token with ORG_ADMIN authority is required to call this API.  The following rights are required to access this endpoint: idn:identity-profile:delete
     * @summary Delete Identity Profiles
     * @param {IdentityProfilesApiDeleteIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.deleteIdentityProfiles = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.IdentityProfilesApiFp)(this.configuration).deleteIdentityProfiles(requestParameters.requestBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This exports existing identity profiles in the format specified by the sp-config service.
     * @summary Export Identity Profiles
     * @param {IdentityProfilesApiExportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.exportIdentityProfiles = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.IdentityProfilesApiFp)(this.configuration).exportIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
     * @summary Get default Identity Attribute Config
     * @param {IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.getDefaultIdentityAttributeConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.IdentityProfilesApiFp)(this.configuration).getDefaultIdentityAttributeConfig(requestParameters.identityProfileId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This returns a single Identity Profile based on ID.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get single Identity Profile
     * @param {IdentityProfilesApiGetIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.getIdentityProfile = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.IdentityProfilesApiFp)(this.configuration).getIdentityProfile(requestParameters.identityProfileId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This imports previously exported identity profiles.
     * @summary Import Identity Profiles
     * @param {IdentityProfilesApiImportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.importIdentityProfiles = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.IdentityProfilesApiFp)(this.configuration).importIdentityProfiles(requestParameters.identityProfileExportedObject, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
     * @summary Identity Profiles List
     * @param {IdentityProfilesApiListIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.listIdentityProfiles = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.IdentityProfilesApiFp)(this.configuration).listIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to generate a non-persisted preview of the identity object after applying `IdentityAttributeConfig` sent in request body. This API only allows `accountAttribute`, `reference` and `rule` transform types in the `IdentityAttributeConfig` sent in the request body. A token with ORG_ADMIN authority is required to call this API to generate an identity preview.
     * @summary Generate Identity Profile Preview
     * @param {IdentityProfilesApiShowIdentityPreviewRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.showIdentityPreview = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.IdentityProfilesApiFp)(this.configuration).showIdentityPreview(requestParameters.identityPreviewRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Process identities under the profile This operation should not be used to schedule your own identity processing or to perform system wide identity refreshes. The system will use a combination of [event-based processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#event-based-processing) and [scheduled processing](https://documentation.sailpoint.com/saas/help/setup/identity_processing.html?h=process#scheduled-processing) that runs every day at 8:00 AM and 8:00 PM in the tenant\'s timezone to keep your identities synchronized.  This should only be run on identity profiles that have the `identityRefreshRequired` attribute set to `true`. If `identityRefreshRequired` is false, then there is no benefit to running this operation. Typically, this operation is performed when a change is made to the identity profile or its related lifecycle states that requires a refresh. This operation will perform the following activities on all identities under the identity profile. 1. Updates identity attribute according to the identity profile mappings. 2. Determines the identity\'s correct manager through manager correlation. 3. Updates the identity\'s access according to their assigned lifecycle state. 4. Updates the identity\'s access based on role assignment criteria. A token with ORG_ADMIN authority is required to call this API.
     * @summary Process identities under profile
     * @param {IdentityProfilesApiSyncIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.syncIdentityProfile = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.IdentityProfilesApiFp)(this.configuration).syncIdentityProfile(requestParameters.identityProfileId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This updates the specified Identity Profile.  A token with ORG_ADMIN authority is required to call this API to update the Identity Profile.  Some fields of the Schema cannot be updated. These fields are listed below: * id * name * created * modified * identityCount * identityRefreshRequired * Authoritative Source and Identity Attribute Configuration cannot be modified at once.
     * @summary Update the Identity Profile
     * @param {IdentityProfilesApiUpdateIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    IdentityProfilesApi.prototype.updateIdentityProfile = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.IdentityProfilesApiFp)(this.configuration).updateIdentityProfile(requestParameters.identityProfileId, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return IdentityProfilesApi;
}(base_1.BaseAPI));
exports.IdentityProfilesApi = IdentityProfilesApi;
/**
 * LifecycleStatesApi - axios parameter creator
 * @export
 */
var LifecycleStatesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Use this endpoint to create a lifecycle state. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {LifecycleState} lifecycleState Lifecycle state to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState: function (identityProfileId, lifecycleState, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileId' is not null or undefined
                            (0, common_1.assertParamExists)('createLifecycleState', 'identityProfileId', identityProfileId);
                            // verify required parameter 'lifecycleState' is not null or undefined
                            (0, common_1.assertParamExists)('createLifecycleState', 'lifecycleState', lifecycleState);
                            localVarPath = "/identity-profiles/{identity-profile-id}/lifecycle-states"
                                .replace("{".concat("identity-profile-id", "}"), encodeURIComponent(String(identityProfileId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(lifecycleState, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this endpoint to delete the lifecycle state by its ID.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState: function (identityProfileId, lifecycleStateId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteLifecycleState', 'identityProfileId', identityProfileId);
                            // verify required parameter 'lifecycleStateId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteLifecycleState', 'lifecycleStateId', lifecycleStateId);
                            localVarPath = "/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}"
                                .replace("{".concat("identity-profile-id", "}"), encodeURIComponent(String(identityProfileId)))
                                .replace("{".concat("lifecycle-state-id", "}"), encodeURIComponent(String(lifecycleStateId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState: function (identityProfileId, lifecycleStateId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileId' is not null or undefined
                            (0, common_1.assertParamExists)('getLifecycleState', 'identityProfileId', identityProfileId);
                            // verify required parameter 'lifecycleStateId' is not null or undefined
                            (0, common_1.assertParamExists)('getLifecycleState', 'lifecycleStateId', lifecycleStateId);
                            localVarPath = "/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}"
                                .replace("{".concat("identity-profile-id", "}"), encodeURIComponent(String(identityProfileId)))
                                .replace("{".concat("lifecycle-state-id", "}"), encodeURIComponent(String(lifecycleStateId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this endpoint to list all lifecycle states by their associated identity profiles.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId Identity profile ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleStates: function (identityProfileId, limit, offset, count, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileId' is not null or undefined
                            (0, common_1.assertParamExists)('getLifecycleStates', 'identityProfileId', identityProfileId);
                            localVarPath = "/identity-profiles/{identity-profile-id}/lifecycle-states"
                                .replace("{".concat("identity-profile-id", "}"), encodeURIComponent(String(identityProfileId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile. A token with ORG_ADMIN or API authority and the appropriate user context is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId ID of the identity to update.
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState: function (identityId, setLifecycleStateRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityId' is not null or undefined
                            (0, common_1.assertParamExists)('setLifecycleState', 'identityId', identityId);
                            // verify required parameter 'setLifecycleStateRequest' is not null or undefined
                            (0, common_1.assertParamExists)('setLifecycleState', 'setLifecycleStateRequest', setLifecycleStateRequest);
                            localVarPath = "/identities/{identity-id}/set-lifecycle-state"
                                .replace("{".concat("identity-id", "}"), encodeURIComponent(String(identityId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(setLifecycleStateRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates: function (identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityProfileId' is not null or undefined
                            (0, common_1.assertParamExists)('updateLifecycleStates', 'identityProfileId', identityProfileId);
                            // verify required parameter 'lifecycleStateId' is not null or undefined
                            (0, common_1.assertParamExists)('updateLifecycleStates', 'lifecycleStateId', lifecycleStateId);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('updateLifecycleStates', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}"
                                .replace("{".concat("identity-profile-id", "}"), encodeURIComponent(String(identityProfileId)))
                                .replace("{".concat("lifecycle-state-id", "}"), encodeURIComponent(String(lifecycleStateId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.LifecycleStatesApiAxiosParamCreator = LifecycleStatesApiAxiosParamCreator;
/**
 * LifecycleStatesApi - functional programming interface
 * @export
 */
var LifecycleStatesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.LifecycleStatesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Use this endpoint to create a lifecycle state. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {LifecycleState} lifecycleState Lifecycle state to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState: function (identityProfileId, lifecycleState, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createLifecycleState(identityProfileId, lifecycleState, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this endpoint to delete the lifecycle state by its ID.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState: function (identityProfileId, lifecycleStateId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteLifecycleState(identityProfileId, lifecycleStateId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState: function (identityProfileId, lifecycleStateId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLifecycleState(identityProfileId, lifecycleStateId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this endpoint to list all lifecycle states by their associated identity profiles.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId Identity profile ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleStates: function (identityProfileId, limit, offset, count, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLifecycleStates(identityProfileId, limit, offset, count, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile. A token with ORG_ADMIN or API authority and the appropriate user context is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId ID of the identity to update.
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState: function (identityId, setLifecycleStateRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setLifecycleState(identityId, setLifecycleStateRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates: function (identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.LifecycleStatesApiFp = LifecycleStatesApiFp;
/**
 * LifecycleStatesApi - factory interface
 * @export
 */
var LifecycleStatesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.LifecycleStatesApiFp)(configuration);
    return {
        /**
         * Use this endpoint to create a lifecycle state. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {LifecycleState} lifecycleState Lifecycle state to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState: function (identityProfileId, lifecycleState, axiosOptions) {
            return localVarFp.createLifecycleState(identityProfileId, lifecycleState, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this endpoint to delete the lifecycle state by its ID.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState: function (identityProfileId, lifecycleStateId, axiosOptions) {
            return localVarFp.deleteLifecycleState(identityProfileId, lifecycleStateId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState: function (identityProfileId, lifecycleStateId, axiosOptions) {
            return localVarFp.getLifecycleState(identityProfileId, lifecycleStateId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this endpoint to list all lifecycle states by their associated identity profiles.  A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId Identity profile ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleStates: function (identityProfileId, limit, offset, count, sorters, axiosOptions) {
            return localVarFp.getLifecycleStates(identityProfileId, limit, offset, count, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile. A token with ORG_ADMIN or API authority and the appropriate user context is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId ID of the identity to update.
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState: function (identityId, setLifecycleStateRequest, axiosOptions) {
            return localVarFp.setLifecycleState(identityId, setLifecycleStateRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity profile ID.
         * @param {string} lifecycleStateId Lifecycle state ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates: function (identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions) {
            return localVarFp.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.LifecycleStatesApiFactory = LifecycleStatesApiFactory;
/**
 * LifecycleStatesApi - object-oriented interface
 * @export
 * @class LifecycleStatesApi
 * @extends {BaseAPI}
 */
var LifecycleStatesApi = /** @class */ (function (_super) {
    __extends(LifecycleStatesApi, _super);
    function LifecycleStatesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this endpoint to create a lifecycle state. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Create Lifecycle State
     * @param {LifecycleStatesApiCreateLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    LifecycleStatesApi.prototype.createLifecycleState = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LifecycleStatesApiFp)(this.configuration).createLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleState, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this endpoint to delete the lifecycle state by its ID.  A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Lifecycle State
     * @param {LifecycleStatesApiDeleteLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    LifecycleStatesApi.prototype.deleteLifecycleState = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LifecycleStatesApiFp)(this.configuration).deleteLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this endpoint to get a lifecycle state by its ID and its associated identity profile ID.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get Lifecycle State
     * @param {LifecycleStatesApiGetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    LifecycleStatesApi.prototype.getLifecycleState = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LifecycleStatesApiFp)(this.configuration).getLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this endpoint to list all lifecycle states by their associated identity profiles.  A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists LifecycleStates
     * @param {LifecycleStatesApiGetLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    LifecycleStatesApi.prototype.getLifecycleStates = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LifecycleStatesApiFp)(this.configuration).getLifecycleStates(requestParameters.identityProfileId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to set/update an identity\'s lifecycle state to the one provided and update the corresponding identity profile. A token with ORG_ADMIN or API authority and the appropriate user context is required to call this API.
     * @summary Set Lifecycle State
     * @param {LifecycleStatesApiSetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    LifecycleStatesApi.prototype.setLifecycleState = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LifecycleStatesApiFp)(this.configuration).setLifecycleState(requestParameters.identityId, requestParameters.setLifecycleStateRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this endpoint to update individual lifecycle state fields, using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Update Lifecycle State
     * @param {LifecycleStatesApiUpdateLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    LifecycleStatesApi.prototype.updateLifecycleStates = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LifecycleStatesApiFp)(this.configuration).updateLifecycleStates(requestParameters.identityProfileId, requestParameters.lifecycleStateId, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return LifecycleStatesApi;
}(base_1.BaseAPI));
exports.LifecycleStatesApi = LifecycleStatesApi;
/**
 * MFAConfigurationApi - axios parameter creator
 * @export
 */
var MFAConfigurationApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API removes the configuration for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete MFA method configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteMFAConfig: function (method, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'method' is not null or undefined
                            (0, common_1.assertParamExists)('deleteMFAConfig', 'method', method);
                            localVarPath = "/mfa/{method}/delete"
                                .replace("{".concat("method", "}"), encodeURIComponent(String(method)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Duo MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFADuoConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/mfa/duo-web/config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the KBA configuration for MFA. A token with USER or ORG_ADMIN authority is required to call this API.
         * @summary Configuration of KBA MFA method
         * @param {boolean} [allLanguages] Indicator whether the question text should be returned in all configured languages    * If true, the question text is returned in all languages that it is configured in.    * If false, the question text is returned in the user locale if available, else for the default locale.     * If not passed, it behaves the same way as passing this parameter as false
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAKbaConfig: function (allLanguages, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/mfa/kba/config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (allLanguages !== undefined) {
                                localVarQueryParameter['allLanguages'] = allLanguages;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Okta MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAOktaConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/mfa/okta-verify/config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API sets the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Duo MFA configuration
         * @param {MfaDuoConfig} mfaDuoConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFADuoConfig: function (mfaDuoConfig, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'mfaDuoConfig' is not null or undefined
                            (0, common_1.assertParamExists)('setMFADuoConfig', 'mfaDuoConfig', mfaDuoConfig);
                            localVarPath = "/mfa/duo-web/config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(mfaDuoConfig, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration. A token with USER authority is required to call this API.
         * @summary Set MFA KBA configuration
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAKBAConfig: function (kbaAnswerRequestItem, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'kbaAnswerRequestItem' is not null or undefined
                            (0, common_1.assertParamExists)('setMFAKBAConfig', 'kbaAnswerRequestItem', kbaAnswerRequestItem);
                            localVarPath = "/mfa/kba/config/answers";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(kbaAnswerRequestItem, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API sets the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Okta MFA configuration
         * @param {MfaOktaConfig} mfaOktaConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAOktaConfig: function (mfaOktaConfig, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'mfaOktaConfig' is not null or undefined
                            (0, common_1.assertParamExists)('setMFAOktaConfig', 'mfaOktaConfig', mfaOktaConfig);
                            localVarPath = "/mfa/okta-verify/config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(mfaOktaConfig, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary MFA method\'s test configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testMFAConfig: function (method, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'method' is not null or undefined
                            (0, common_1.assertParamExists)('testMFAConfig', 'method', method);
                            localVarPath = "/mfa/{method}/test"
                                .replace("{".concat("method", "}"), encodeURIComponent(String(method)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.MFAConfigurationApiAxiosParamCreator = MFAConfigurationApiAxiosParamCreator;
/**
 * MFAConfigurationApi - functional programming interface
 * @export
 */
var MFAConfigurationApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.MFAConfigurationApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API removes the configuration for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete MFA method configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteMFAConfig: function (method, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteMFAConfig(method, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Duo MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFADuoConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getMFADuoConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the KBA configuration for MFA. A token with USER or ORG_ADMIN authority is required to call this API.
         * @summary Configuration of KBA MFA method
         * @param {boolean} [allLanguages] Indicator whether the question text should be returned in all configured languages    * If true, the question text is returned in all languages that it is configured in.    * If false, the question text is returned in the user locale if available, else for the default locale.     * If not passed, it behaves the same way as passing this parameter as false
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAKbaConfig: function (allLanguages, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getMFAKbaConfig(allLanguages, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Okta MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAOktaConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getMFAOktaConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API sets the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Duo MFA configuration
         * @param {MfaDuoConfig} mfaDuoConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFADuoConfig: function (mfaDuoConfig, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setMFADuoConfig(mfaDuoConfig, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration. A token with USER authority is required to call this API.
         * @summary Set MFA KBA configuration
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAKBAConfig: function (kbaAnswerRequestItem, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setMFAKBAConfig(kbaAnswerRequestItem, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API sets the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Okta MFA configuration
         * @param {MfaOktaConfig} mfaOktaConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAOktaConfig: function (mfaOktaConfig, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setMFAOktaConfig(mfaOktaConfig, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary MFA method\'s test configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testMFAConfig: function (method, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.testMFAConfig(method, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.MFAConfigurationApiFp = MFAConfigurationApiFp;
/**
 * MFAConfigurationApi - factory interface
 * @export
 */
var MFAConfigurationApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.MFAConfigurationApiFp)(configuration);
    return {
        /**
         * This API removes the configuration for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete MFA method configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteMFAConfig: function (method, axiosOptions) {
            return localVarFp.deleteMFAConfig(method, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Duo MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFADuoConfig: function (axiosOptions) {
            return localVarFp.getMFADuoConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the KBA configuration for MFA. A token with USER or ORG_ADMIN authority is required to call this API.
         * @summary Configuration of KBA MFA method
         * @param {boolean} [allLanguages] Indicator whether the question text should be returned in all configured languages    * If true, the question text is returned in all languages that it is configured in.    * If false, the question text is returned in the user locale if available, else for the default locale.     * If not passed, it behaves the same way as passing this parameter as false
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAKbaConfig: function (allLanguages, axiosOptions) {
            return localVarFp.getMFAKbaConfig(allLanguages, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configuration of Okta MFA method
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMFAOktaConfig: function (axiosOptions) {
            return localVarFp.getMFAOktaConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API sets the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Duo MFA configuration
         * @param {MfaDuoConfig} mfaDuoConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFADuoConfig: function (mfaDuoConfig, axiosOptions) {
            return localVarFp.setMFADuoConfig(mfaDuoConfig, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration. A token with USER authority is required to call this API.
         * @summary Set MFA KBA configuration
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAKBAConfig: function (kbaAnswerRequestItem, axiosOptions) {
            return localVarFp.setMFAKBAConfig(kbaAnswerRequestItem, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API sets the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Set Okta MFA configuration
         * @param {MfaOktaConfig} mfaOktaConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setMFAOktaConfig: function (mfaOktaConfig, axiosOptions) {
            return localVarFp.setMFAOktaConfig(mfaOktaConfig, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
         * @summary MFA method\'s test configuration
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39; and \&#39;duo-web\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testMFAConfig: function (method, axiosOptions) {
            return localVarFp.testMFAConfig(method, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.MFAConfigurationApiFactory = MFAConfigurationApiFactory;
/**
 * MFAConfigurationApi - object-oriented interface
 * @export
 * @class MFAConfigurationApi
 * @extends {BaseAPI}
 */
var MFAConfigurationApi = /** @class */ (function (_super) {
    __extends(MFAConfigurationApi, _super);
    function MFAConfigurationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API removes the configuration for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete MFA method configuration
     * @param {MFAConfigurationApiDeleteMFAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    MFAConfigurationApi.prototype.deleteMFAConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAConfigurationApiFp)(this.configuration).deleteMFAConfig(requestParameters.method, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Configuration of Duo MFA method
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    MFAConfigurationApi.prototype.getMFADuoConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.MFAConfigurationApiFp)(this.configuration).getMFADuoConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the KBA configuration for MFA. A token with USER or ORG_ADMIN authority is required to call this API.
     * @summary Configuration of KBA MFA method
     * @param {MFAConfigurationApiGetMFAKbaConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    MFAConfigurationApi.prototype.getMFAKbaConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.MFAConfigurationApiFp)(this.configuration).getMFAKbaConfig(requestParameters.allLanguages, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Configuration of Okta MFA method
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    MFAConfigurationApi.prototype.getMFAOktaConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.MFAConfigurationApiFp)(this.configuration).getMFAOktaConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API sets the configuration of an Duo MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Set Duo MFA configuration
     * @param {MFAConfigurationApiSetMFADuoConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    MFAConfigurationApi.prototype.setMFADuoConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAConfigurationApiFp)(this.configuration).setMFADuoConfig(requestParameters.mfaDuoConfig, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API sets answers to challenge questions.  Any configured questions omitted from the request are removed from user KBA configuration. A token with USER authority is required to call this API.
     * @summary Set MFA KBA configuration
     * @param {MFAConfigurationApiSetMFAKBAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    MFAConfigurationApi.prototype.setMFAKBAConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAConfigurationApiFp)(this.configuration).setMFAKBAConfig(requestParameters.kbaAnswerRequestItem, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API sets the configuration of an Okta MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Set Okta MFA configuration
     * @param {MFAConfigurationApiSetMFAOktaConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    MFAConfigurationApi.prototype.setMFAOktaConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAConfigurationApiFp)(this.configuration).setMFAOktaConfig(requestParameters.mfaOktaConfig, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API validates that the configuration is valid and will properly authenticate with the MFA provider identified by the method path parameter. A token with ORG_ADMIN authority is required to call this API.
     * @summary MFA method\'s test configuration
     * @param {MFAConfigurationApiTestMFAConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAConfigurationApi
     */
    MFAConfigurationApi.prototype.testMFAConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAConfigurationApiFp)(this.configuration).testMFAConfig(requestParameters.method, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return MFAConfigurationApi;
}(base_1.BaseAPI));
exports.MFAConfigurationApi = MFAConfigurationApi;
/**
 * MFAControllerApi - axios parameter creator
 * @export
 */
var MFAControllerApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API send token request.
         * @summary Create and send user token
         * @param {SendTokenRequest} sendTokenRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSendToken: function (sendTokenRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sendTokenRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createSendToken', 'sendTokenRequest', sendTokenRequest);
                            localVarPath = "/mfa/token/send";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sendTokenRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API poll the VerificationPollRequest for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Polling MFA method by VerificationPollRequest
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39;, \&#39;duo-web\&#39;, \&#39;kba\&#39;,\&#39;token\&#39;, \&#39;rsa\&#39;
         * @param {VerificationPollRequest} verificationPollRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        pingVerificationStatus: function (method, verificationPollRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'method' is not null or undefined
                            (0, common_1.assertParamExists)('pingVerificationStatus', 'method', method);
                            // verify required parameter 'verificationPollRequest' is not null or undefined
                            (0, common_1.assertParamExists)('pingVerificationStatus', 'verificationPollRequest', verificationPollRequest);
                            localVarPath = "/mfa/{method}/poll"
                                .replace("{".concat("method", "}"), encodeURIComponent(String(method)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(verificationPollRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API Authenticates the user via Duo-Web MFA method.
         * @summary Verifying authentication via Duo method
         * @param {DuoVerificationRequest} duoVerificationRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendDuoVerifyRequest: function (duoVerificationRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'duoVerificationRequest' is not null or undefined
                            (0, common_1.assertParamExists)('sendDuoVerifyRequest', 'duoVerificationRequest', duoVerificationRequest);
                            localVarPath = "/mfa/duo-web/verify";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(duoVerificationRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API Authenticate user in KBA MFA method.
         * @summary Authenticate KBA provided MFA method
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendKbaAnswers: function (kbaAnswerRequestItem, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'kbaAnswerRequestItem' is not null or undefined
                            (0, common_1.assertParamExists)('sendKbaAnswers', 'kbaAnswerRequestItem', kbaAnswerRequestItem);
                            localVarPath = "/mfa/kba/authenticate";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(kbaAnswerRequestItem, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
         * @summary Verifying authentication via Okta method
         * @param {OktaVerificationRequest} oktaVerificationRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendOktaVerifyRequest: function (oktaVerificationRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'oktaVerificationRequest' is not null or undefined
                            (0, common_1.assertParamExists)('sendOktaVerifyRequest', 'oktaVerificationRequest', oktaVerificationRequest);
                            localVarPath = "/mfa/okta-verify/verify";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(oktaVerificationRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API Authenticate user in Token MFA method.
         * @summary Authenticate Token provided MFA method
         * @param {TokenAuthRequest} tokenAuthRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendTokenAuthRequest: function (tokenAuthRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'tokenAuthRequest' is not null or undefined
                            (0, common_1.assertParamExists)('sendTokenAuthRequest', 'tokenAuthRequest', tokenAuthRequest);
                            localVarPath = "/mfa/token/authenticate";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tokenAuthRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.MFAControllerApiAxiosParamCreator = MFAControllerApiAxiosParamCreator;
/**
 * MFAControllerApi - functional programming interface
 * @export
 */
var MFAControllerApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.MFAControllerApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API send token request.
         * @summary Create and send user token
         * @param {SendTokenRequest} sendTokenRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSendToken: function (sendTokenRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createSendToken(sendTokenRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API poll the VerificationPollRequest for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Polling MFA method by VerificationPollRequest
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39;, \&#39;duo-web\&#39;, \&#39;kba\&#39;,\&#39;token\&#39;, \&#39;rsa\&#39;
         * @param {VerificationPollRequest} verificationPollRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        pingVerificationStatus: function (method, verificationPollRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.pingVerificationStatus(method, verificationPollRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API Authenticates the user via Duo-Web MFA method.
         * @summary Verifying authentication via Duo method
         * @param {DuoVerificationRequest} duoVerificationRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendDuoVerifyRequest: function (duoVerificationRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.sendDuoVerifyRequest(duoVerificationRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API Authenticate user in KBA MFA method.
         * @summary Authenticate KBA provided MFA method
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendKbaAnswers: function (kbaAnswerRequestItem, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.sendKbaAnswers(kbaAnswerRequestItem, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
         * @summary Verifying authentication via Okta method
         * @param {OktaVerificationRequest} oktaVerificationRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendOktaVerifyRequest: function (oktaVerificationRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.sendOktaVerifyRequest(oktaVerificationRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API Authenticate user in Token MFA method.
         * @summary Authenticate Token provided MFA method
         * @param {TokenAuthRequest} tokenAuthRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendTokenAuthRequest: function (tokenAuthRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.sendTokenAuthRequest(tokenAuthRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.MFAControllerApiFp = MFAControllerApiFp;
/**
 * MFAControllerApi - factory interface
 * @export
 */
var MFAControllerApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.MFAControllerApiFp)(configuration);
    return {
        /**
         * This API send token request.
         * @summary Create and send user token
         * @param {SendTokenRequest} sendTokenRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSendToken: function (sendTokenRequest, axiosOptions) {
            return localVarFp.createSendToken(sendTokenRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API poll the VerificationPollRequest for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
         * @summary Polling MFA method by VerificationPollRequest
         * @param {string} method The name of the MFA method. The currently supported method names are \&#39;okta-verify\&#39;, \&#39;duo-web\&#39;, \&#39;kba\&#39;,\&#39;token\&#39;, \&#39;rsa\&#39;
         * @param {VerificationPollRequest} verificationPollRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        pingVerificationStatus: function (method, verificationPollRequest, axiosOptions) {
            return localVarFp.pingVerificationStatus(method, verificationPollRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API Authenticates the user via Duo-Web MFA method.
         * @summary Verifying authentication via Duo method
         * @param {DuoVerificationRequest} duoVerificationRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendDuoVerifyRequest: function (duoVerificationRequest, axiosOptions) {
            return localVarFp.sendDuoVerifyRequest(duoVerificationRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API Authenticate user in KBA MFA method.
         * @summary Authenticate KBA provided MFA method
         * @param {Array<KbaAnswerRequestItem>} kbaAnswerRequestItem
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendKbaAnswers: function (kbaAnswerRequestItem, axiosOptions) {
            return localVarFp.sendKbaAnswers(kbaAnswerRequestItem, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
         * @summary Verifying authentication via Okta method
         * @param {OktaVerificationRequest} oktaVerificationRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendOktaVerifyRequest: function (oktaVerificationRequest, axiosOptions) {
            return localVarFp.sendOktaVerifyRequest(oktaVerificationRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API Authenticate user in Token MFA method.
         * @summary Authenticate Token provided MFA method
         * @param {TokenAuthRequest} tokenAuthRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendTokenAuthRequest: function (tokenAuthRequest, axiosOptions) {
            return localVarFp.sendTokenAuthRequest(tokenAuthRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.MFAControllerApiFactory = MFAControllerApiFactory;
/**
 * MFAControllerApi - object-oriented interface
 * @export
 * @class MFAControllerApi
 * @extends {BaseAPI}
 */
var MFAControllerApi = /** @class */ (function (_super) {
    __extends(MFAControllerApi, _super);
    function MFAControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API send token request.
     * @summary Create and send user token
     * @param {MFAControllerApiCreateSendTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    MFAControllerApi.prototype.createSendToken = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAControllerApiFp)(this.configuration).createSendToken(requestParameters.sendTokenRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API poll the VerificationPollRequest for the specified MFA method. A token with ORG_ADMIN authority is required to call this API.
     * @summary Polling MFA method by VerificationPollRequest
     * @param {MFAControllerApiPingVerificationStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    MFAControllerApi.prototype.pingVerificationStatus = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAControllerApiFp)(this.configuration).pingVerificationStatus(requestParameters.method, requestParameters.verificationPollRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API Authenticates the user via Duo-Web MFA method.
     * @summary Verifying authentication via Duo method
     * @param {MFAControllerApiSendDuoVerifyRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    MFAControllerApi.prototype.sendDuoVerifyRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAControllerApiFp)(this.configuration).sendDuoVerifyRequest(requestParameters.duoVerificationRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API Authenticate user in KBA MFA method.
     * @summary Authenticate KBA provided MFA method
     * @param {MFAControllerApiSendKbaAnswersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    MFAControllerApi.prototype.sendKbaAnswers = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAControllerApiFp)(this.configuration).sendKbaAnswers(requestParameters.kbaAnswerRequestItem, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API Authenticates the user via Okta-Verify MFA method. Request requires a header called \'slpt-forwarding\', and it must contain a remote IP Address of caller.
     * @summary Verifying authentication via Okta method
     * @param {MFAControllerApiSendOktaVerifyRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    MFAControllerApi.prototype.sendOktaVerifyRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAControllerApiFp)(this.configuration).sendOktaVerifyRequest(requestParameters.oktaVerificationRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API Authenticate user in Token MFA method.
     * @summary Authenticate Token provided MFA method
     * @param {MFAControllerApiSendTokenAuthRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MFAControllerApi
     */
    MFAControllerApi.prototype.sendTokenAuthRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.MFAControllerApiFp)(this.configuration).sendTokenAuthRequest(requestParameters.tokenAuthRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return MFAControllerApi;
}(base_1.BaseAPI));
exports.MFAControllerApi = MFAControllerApi;
/**
 * ManagedClientsApi - axios parameter creator
 * @export
 */
var ManagedClientsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Create a new Managed Client. The API returns a result that includes the Managed Client ID.
         * @summary Create a new Managed Client
         * @param {ManagedClientRequest} managedClientRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedClient: function (managedClientRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'managedClientRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createManagedClient', 'managedClientRequest', managedClientRequest);
                            localVarPath = "/managed-clients";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(managedClientRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Delete an existing Managed Client.
         * @summary Delete a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedClient: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteManagedClient', 'id', id);
                            localVarPath = "/managed-clients/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get a Managed Client.
         * @summary Get a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClient: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getManagedClient', 'id', id);
                            localVarPath = "/managed-clients/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve the Status of a Managed Client by ID.
         * @summary Get Managed Client Status.
         * @param {string} id ID of the Managed Client to get Status of
         * @param {ManagedClientType} type Type of the Managed Client to get Status of
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClientStatus: function (id, type, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getManagedClientStatus', 'id', id);
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('getManagedClientStatus', 'type', type);
                            localVarPath = "/managed-clients/{id}/status"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get a list of Managed Clients.
         * @summary Get Managed Clients
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **clientId**: *eq*  **clusterId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClients: function (offset, limit, count, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/managed-clients";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update an existing Managed Client.
         * @summary Update a Managed Client
         * @param {string} id Managed Client ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedClient: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('updateManagedClient', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('updateManagedClient', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/managed-clients/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ManagedClientsApiAxiosParamCreator = ManagedClientsApiAxiosParamCreator;
/**
 * ManagedClientsApi - functional programming interface
 * @export
 */
var ManagedClientsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ManagedClientsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new Managed Client. The API returns a result that includes the Managed Client ID.
         * @summary Create a new Managed Client
         * @param {ManagedClientRequest} managedClientRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedClient: function (managedClientRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createManagedClient(managedClientRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Delete an existing Managed Client.
         * @summary Delete a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedClient: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteManagedClient(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get a Managed Client.
         * @summary Get a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClient: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getManagedClient(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve the Status of a Managed Client by ID.
         * @summary Get Managed Client Status.
         * @param {string} id ID of the Managed Client to get Status of
         * @param {ManagedClientType} type Type of the Managed Client to get Status of
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClientStatus: function (id, type, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getManagedClientStatus(id, type, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get a list of Managed Clients.
         * @summary Get Managed Clients
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **clientId**: *eq*  **clusterId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClients: function (offset, limit, count, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getManagedClients(offset, limit, count, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update an existing Managed Client.
         * @summary Update a Managed Client
         * @param {string} id Managed Client ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedClient: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateManagedClient(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ManagedClientsApiFp = ManagedClientsApiFp;
/**
 * ManagedClientsApi - factory interface
 * @export
 */
var ManagedClientsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ManagedClientsApiFp)(configuration);
    return {
        /**
         * Create a new Managed Client. The API returns a result that includes the Managed Client ID.
         * @summary Create a new Managed Client
         * @param {ManagedClientRequest} managedClientRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedClient: function (managedClientRequest, axiosOptions) {
            return localVarFp.createManagedClient(managedClientRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete an existing Managed Client.
         * @summary Delete a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedClient: function (id, axiosOptions) {
            return localVarFp.deleteManagedClient(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get a Managed Client.
         * @summary Get a Managed Client
         * @param {string} id Managed Client ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClient: function (id, axiosOptions) {
            return localVarFp.getManagedClient(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve the Status of a Managed Client by ID.
         * @summary Get Managed Client Status.
         * @param {string} id ID of the Managed Client to get Status of
         * @param {ManagedClientType} type Type of the Managed Client to get Status of
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClientStatus: function (id, type, axiosOptions) {
            return localVarFp.getManagedClientStatus(id, type, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get a list of Managed Clients.
         * @summary Get Managed Clients
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*  **name**: *eq*  **clientId**: *eq*  **clusterId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClients: function (offset, limit, count, filters, axiosOptions) {
            return localVarFp.getManagedClients(offset, limit, count, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update an existing Managed Client.
         * @summary Update a Managed Client
         * @param {string} id Managed Client ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedClient: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.updateManagedClient(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ManagedClientsApiFactory = ManagedClientsApiFactory;
/**
 * ManagedClientsApi - object-oriented interface
 * @export
 * @class ManagedClientsApi
 * @extends {BaseAPI}
 */
var ManagedClientsApi = /** @class */ (function (_super) {
    __extends(ManagedClientsApi, _super);
    function ManagedClientsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new Managed Client. The API returns a result that includes the Managed Client ID.
     * @summary Create a new Managed Client
     * @param {ManagedClientsApiCreateManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    ManagedClientsApi.prototype.createManagedClient = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ManagedClientsApiFp)(this.configuration).createManagedClient(requestParameters.managedClientRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Delete an existing Managed Client.
     * @summary Delete a Managed Client
     * @param {ManagedClientsApiDeleteManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    ManagedClientsApi.prototype.deleteManagedClient = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ManagedClientsApiFp)(this.configuration).deleteManagedClient(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get a Managed Client.
     * @summary Get a Managed Client
     * @param {ManagedClientsApiGetManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    ManagedClientsApi.prototype.getManagedClient = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ManagedClientsApiFp)(this.configuration).getManagedClient(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve the Status of a Managed Client by ID.
     * @summary Get Managed Client Status.
     * @param {ManagedClientsApiGetManagedClientStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    ManagedClientsApi.prototype.getManagedClientStatus = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ManagedClientsApiFp)(this.configuration).getManagedClientStatus(requestParameters.id, requestParameters.type, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get a list of Managed Clients.
     * @summary Get Managed Clients
     * @param {ManagedClientsApiGetManagedClientsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    ManagedClientsApi.prototype.getManagedClients = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.ManagedClientsApiFp)(this.configuration).getManagedClients(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update an existing Managed Client.
     * @summary Update a Managed Client
     * @param {ManagedClientsApiUpdateManagedClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClientsApi
     */
    ManagedClientsApi.prototype.updateManagedClient = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ManagedClientsApiFp)(this.configuration).updateManagedClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ManagedClientsApi;
}(base_1.BaseAPI));
exports.ManagedClientsApi = ManagedClientsApi;
/**
 * ManagedClustersApi - axios parameter creator
 * @export
 */
var ManagedClustersApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Create a new Managed Cluster. The API returns a result that includes the Managed Cluster ID.
         * @summary Create a new Managed Cluster
         * @param {ManagedClusterRequest} managedClusterRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedCluster: function (managedClusterRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'managedClusterRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createManagedCluster', 'managedClusterRequest', managedClusterRequest);
                            localVarPath = "/managed-clusters";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(managedClusterRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Delete an existing Managed Cluster.
         * @summary Delete a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {boolean} [removeClients] Flag to determine the need to delete a cluster with clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedCluster: function (id, removeClients, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteManagedCluster', 'id', id);
                            localVarPath = "/managed-clusters/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (removeClients !== undefined) {
                                localVarQueryParameter['removeClients'] = removeClients;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve a ManagedCluster by ID.
         * @summary Get a specified Managed Cluster.
         * @param {string} id ManagedCluster ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedCluster: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getManagedCluster', 'id', id);
                            localVarPath = "/managed-clusters/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve all Managed Clusters for the current Org, based on request context.
         * @summary Retrieve all Managed Clusters.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClusters: function (offset, limit, count, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/managed-clusters";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update an existing Managed Cluster.
         * @summary Update a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedCluster: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('updateManagedCluster', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('updateManagedCluster', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/managed-clusters/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ManagedClustersApiAxiosParamCreator = ManagedClustersApiAxiosParamCreator;
/**
 * ManagedClustersApi - functional programming interface
 * @export
 */
var ManagedClustersApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ManagedClustersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new Managed Cluster. The API returns a result that includes the Managed Cluster ID.
         * @summary Create a new Managed Cluster
         * @param {ManagedClusterRequest} managedClusterRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedCluster: function (managedClusterRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createManagedCluster(managedClusterRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Delete an existing Managed Cluster.
         * @summary Delete a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {boolean} [removeClients] Flag to determine the need to delete a cluster with clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedCluster: function (id, removeClients, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteManagedCluster(id, removeClients, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve a ManagedCluster by ID.
         * @summary Get a specified Managed Cluster.
         * @param {string} id ManagedCluster ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedCluster: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getManagedCluster(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve all Managed Clusters for the current Org, based on request context.
         * @summary Retrieve all Managed Clusters.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClusters: function (offset, limit, count, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getManagedClusters(offset, limit, count, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update an existing Managed Cluster.
         * @summary Update a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedCluster: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateManagedCluster(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ManagedClustersApiFp = ManagedClustersApiFp;
/**
 * ManagedClustersApi - factory interface
 * @export
 */
var ManagedClustersApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ManagedClustersApiFp)(configuration);
    return {
        /**
         * Create a new Managed Cluster. The API returns a result that includes the Managed Cluster ID.
         * @summary Create a new Managed Cluster
         * @param {ManagedClusterRequest} managedClusterRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createManagedCluster: function (managedClusterRequest, axiosOptions) {
            return localVarFp.createManagedCluster(managedClusterRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete an existing Managed Cluster.
         * @summary Delete a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {boolean} [removeClients] Flag to determine the need to delete a cluster with clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedCluster: function (id, removeClients, axiosOptions) {
            return localVarFp.deleteManagedCluster(id, removeClients, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve a ManagedCluster by ID.
         * @summary Get a specified Managed Cluster.
         * @param {string} id ManagedCluster ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedCluster: function (id, axiosOptions) {
            return localVarFp.getManagedCluster(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve all Managed Clusters for the current Org, based on request context.
         * @summary Retrieve all Managed Clusters.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **operational**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getManagedClusters: function (offset, limit, count, filters, axiosOptions) {
            return localVarFp.getManagedClusters(offset, limit, count, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update an existing Managed Cluster.
         * @summary Update a Managed Cluster
         * @param {string} id Managed Cluster ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the object.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedCluster: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.updateManagedCluster(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ManagedClustersApiFactory = ManagedClustersApiFactory;
/**
 * ManagedClustersApi - object-oriented interface
 * @export
 * @class ManagedClustersApi
 * @extends {BaseAPI}
 */
var ManagedClustersApi = /** @class */ (function (_super) {
    __extends(ManagedClustersApi, _super);
    function ManagedClustersApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new Managed Cluster. The API returns a result that includes the Managed Cluster ID.
     * @summary Create a new Managed Cluster
     * @param {ManagedClustersApiCreateManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    ManagedClustersApi.prototype.createManagedCluster = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ManagedClustersApiFp)(this.configuration).createManagedCluster(requestParameters.managedClusterRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Delete an existing Managed Cluster.
     * @summary Delete a Managed Cluster
     * @param {ManagedClustersApiDeleteManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    ManagedClustersApi.prototype.deleteManagedCluster = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ManagedClustersApiFp)(this.configuration).deleteManagedCluster(requestParameters.id, requestParameters.removeClients, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve a ManagedCluster by ID.
     * @summary Get a specified Managed Cluster.
     * @param {ManagedClustersApiGetManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    ManagedClustersApi.prototype.getManagedCluster = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ManagedClustersApiFp)(this.configuration).getManagedCluster(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve all Managed Clusters for the current Org, based on request context.
     * @summary Retrieve all Managed Clusters.
     * @param {ManagedClustersApiGetManagedClustersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    ManagedClustersApi.prototype.getManagedClusters = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.ManagedClustersApiFp)(this.configuration).getManagedClusters(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update an existing Managed Cluster.
     * @summary Update a Managed Cluster
     * @param {ManagedClustersApiUpdateManagedClusterRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedClustersApi
     */
    ManagedClustersApi.prototype.updateManagedCluster = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ManagedClustersApiFp)(this.configuration).updateManagedCluster(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ManagedClustersApi;
}(base_1.BaseAPI));
exports.ManagedClustersApi = ManagedClustersApi;
/**
 * NonEmployeeLifecycleManagementApi - axios parameter creator
 * @export
 */
var NonEmployeeLifecycleManagementApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest: function (id, nonEmployeeApprovalDecision, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('approveNonEmployeeRequest', 'id', id);
                            // verify required parameter 'nonEmployeeApprovalDecision' is not null or undefined
                            (0, common_1.assertParamExists)('approveNonEmployeeRequest', 'nonEmployeeApprovalDecision', nonEmployeeApprovalDecision);
                            localVarPath = "/non-employee-approvals/{id}/approve"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(nonEmployeeApprovalDecision, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord: function (nonEmployeeRequestBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
                            (0, common_1.assertParamExists)('createNonEmployeeRecord', 'nonEmployeeRequestBody', nonEmployeeRequestBody);
                            localVarPath = "/non-employee-records";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(nonEmployeeRequestBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest: function (nonEmployeeRequestBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
                            (0, common_1.assertParamExists)('createNonEmployeeRequest', 'nonEmployeeRequestBody', nonEmployeeRequestBody);
                            localVarPath = "/non-employee-requests";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(nonEmployeeRequestBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource: function (nonEmployeeSourceRequestBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'nonEmployeeSourceRequestBody' is not null or undefined
                            (0, common_1.assertParamExists)('createNonEmployeeSource', 'nonEmployeeSourceRequestBody', nonEmployeeSourceRequestBody);
                            localVarPath = "/non-employee-sources";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(nonEmployeeSourceRequestBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes: function (sourceId, nonEmployeeSchemaAttributeBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('createNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId);
                            // verify required parameter 'nonEmployeeSchemaAttributeBody' is not null or undefined
                            (0, common_1.assertParamExists)('createNonEmployeeSourceSchemaAttributes', 'nonEmployeeSchemaAttributeBody', nonEmployeeSchemaAttributeBody);
                            localVarPath = "/non-employee-sources/{sourceId}/schema-attributes"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(nonEmployeeSchemaAttributeBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNonEmployeeRecord', 'id', id);
                            localVarPath = "/non-employee-records/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordsInBulk: function (deleteNonEmployeeRecordsInBulkRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'deleteNonEmployeeRecordsInBulkRequest' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNonEmployeeRecordsInBulk', 'deleteNonEmployeeRecordsInBulkRequest', deleteNonEmployeeRecordsInBulkRequest);
                            localVarPath = "/non-employee-records/bulk-delete";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deleteNonEmployeeRecordsInBulkRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNonEmployeeRequest', 'id', id);
                            localVarPath = "/non-employee-requests/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute: function (attributeId, sourceId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'attributeId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNonEmployeeSchemaAttribute', 'attributeId', attributeId);
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNonEmployeeSchemaAttribute', 'sourceId', sourceId);
                            localVarPath = "/non-employee-sources/{sourceId}/schema-attributes/{attributeId}"
                                .replace("{".concat("attributeId", "}"), encodeURIComponent(String(attributeId)))
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource: function (sourceId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNonEmployeeSource', 'sourceId', sourceId);
                            localVarPath = "/non-employee-sources/{sourceId}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes: function (sourceId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId);
                            localVarPath = "/non-employee-sources/{sourceId}/schema-attributes"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('exportNonEmployeeRecords', 'id', id);
                            localVarPath = "/non-employee-sources/{id}/non-employees/download"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('exportNonEmployeeSourceSchemaTemplate', 'id', id);
                            localVarPath = "/non-employee-sources/{id}/schema-attributes-template/download"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval: function (id, includeDetail, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getNonEmployeeApproval', 'id', id);
                            localVarPath = "/non-employee-approvals/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (includeDetail !== undefined) {
                                localVarQueryParameter['include-detail'] = includeDetail;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary: function (requestedFor, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'requestedFor' is not null or undefined
                            (0, common_1.assertParamExists)('getNonEmployeeApprovalSummary', 'requestedFor', requestedFor);
                            localVarPath = "/non-employee-approvals/summary/{requested-for}"
                                .replace("{".concat("requested-for", "}"), encodeURIComponent(String(requestedFor)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read`
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getNonEmployeeBulkUploadStatus', 'id', id);
                            localVarPath = "/non-employee-sources/{id}/non-employee-bulk-upload/status"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getNonEmployeeRecord', 'id', id);
                            localVarPath = "/non-employee-records/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getNonEmployeeRequest', 'id', id);
                            localVarPath = "/non-employee-requests/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary: function (requestedFor, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'requestedFor' is not null or undefined
                            (0, common_1.assertParamExists)('getNonEmployeeRequestSummary', 'requestedFor', requestedFor);
                            localVarPath = "/non-employee-requests/summary/{requested-for}"
                                .replace("{".concat("requested-for", "}"), encodeURIComponent(String(requestedFor)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute: function (attributeId, sourceId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'attributeId' is not null or undefined
                            (0, common_1.assertParamExists)('getNonEmployeeSchemaAttribute', 'attributeId', attributeId);
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('getNonEmployeeSchemaAttribute', 'sourceId', sourceId);
                            localVarPath = "/non-employee-sources/{sourceId}/schema-attributes/{attributeId}"
                                .replace("{".concat("attributeId", "}"), encodeURIComponent(String(attributeId)))
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource: function (sourceId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('getNonEmployeeSource', 'sourceId', sourceId);
                            localVarPath = "/non-employee-sources/{sourceId}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes: function (sourceId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('getNonEmployeeSourceSchemaAttributes', 'sourceId', sourceId);
                            localVarPath = "/non-employee-sources/{sourceId}/schema-attributes"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk: function (id, data, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('importNonEmployeeRecordsInBulk', 'id', id);
                            // verify required parameter 'data' is not null or undefined
                            (0, common_1.assertParamExists)('importNonEmployeeRecordsInBulk', 'data', data);
                            localVarPath = "/non-employee-sources/{id}/non-employee-bulk-upload"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (data !== undefined) {
                                localVarFormParams.append('data', data);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApprovals: function (requestedFor, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/non-employee-approvals";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (requestedFor !== undefined) {
                                localVarQueryParameter['requested-for'] = requestedFor;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords: function (limit, offset, count, sorters, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/non-employee-records";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests: function (requestedFor, limit, offset, count, sorters, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'requestedFor' is not null or undefined
                            (0, common_1.assertParamExists)('listNonEmployeeRequests', 'requestedFor', requestedFor);
                            localVarPath = "/non-employee-requests";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (requestedFor !== undefined) {
                                localVarQueryParameter['requested-for'] = requestedFor;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources: function (requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'requestedFor' is not null or undefined
                            (0, common_1.assertParamExists)('listNonEmployeeSources', 'requestedFor', requestedFor);
                            localVarPath = "/non-employee-sources";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (requestedFor !== undefined) {
                                localVarQueryParameter['requested-for'] = requestedFor;
                            }
                            if (nonEmployeeCount !== undefined) {
                                localVarQueryParameter['non-employee-count'] = nonEmployeeCount;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchNonEmployeeRecord', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchNonEmployeeRecord', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/non-employee-records/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update`
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute: function (attributeId, sourceId, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'attributeId' is not null or undefined
                            (0, common_1.assertParamExists)('patchNonEmployeeSchemaAttribute', 'attributeId', attributeId);
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('patchNonEmployeeSchemaAttribute', 'sourceId', sourceId);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchNonEmployeeSchemaAttribute', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/non-employee-sources/{sourceId}/schema-attributes/{attributeId}"
                                .replace("{".concat("attributeId", "}"), encodeURIComponent(String(attributeId)))
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource: function (sourceId, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('patchNonEmployeeSource', 'sourceId', sourceId);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchNonEmployeeSource', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/non-employee-sources/{sourceId}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest: function (id, nonEmployeeRejectApprovalDecision, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('rejectNonEmployeeRequest', 'id', id);
                            // verify required parameter 'nonEmployeeRejectApprovalDecision' is not null or undefined
                            (0, common_1.assertParamExists)('rejectNonEmployeeRequest', 'nonEmployeeRejectApprovalDecision', nonEmployeeRejectApprovalDecision);
                            localVarPath = "/non-employee-approvals/{id}/reject"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(nonEmployeeRejectApprovalDecision, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord: function (id, nonEmployeeRequestBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('updateNonEmployeeRecord', 'id', id);
                            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
                            (0, common_1.assertParamExists)('updateNonEmployeeRecord', 'nonEmployeeRequestBody', nonEmployeeRequestBody);
                            localVarPath = "/non-employee-records/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(nonEmployeeRequestBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.NonEmployeeLifecycleManagementApiAxiosParamCreator = NonEmployeeLifecycleManagementApiAxiosParamCreator;
/**
 * NonEmployeeLifecycleManagementApi - functional programming interface
 * @export
 */
var NonEmployeeLifecycleManagementApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.NonEmployeeLifecycleManagementApiAxiosParamCreator)(configuration);
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest: function (id, nonEmployeeApprovalDecision, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.approveNonEmployeeRequest(id, nonEmployeeApprovalDecision, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord: function (nonEmployeeRequestBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createNonEmployeeRecord(nonEmployeeRequestBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest: function (nonEmployeeRequestBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createNonEmployeeRequest(nonEmployeeRequestBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource: function (nonEmployeeSourceRequestBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createNonEmployeeSource(nonEmployeeSourceRequestBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes: function (sourceId, nonEmployeeSchemaAttributeBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createNonEmployeeSourceSchemaAttributes(sourceId, nonEmployeeSchemaAttributeBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteNonEmployeeRecord(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordsInBulk: function (deleteNonEmployeeRecordsInBulkRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteNonEmployeeRequest(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute: function (attributeId, sourceId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource: function (sourceId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteNonEmployeeSource(sourceId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes: function (sourceId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.exportNonEmployeeRecords(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.exportNonEmployeeSourceSchemaTemplate(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval: function (id, includeDetail, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNonEmployeeApproval(id, includeDetail, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary: function (requestedFor, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNonEmployeeApprovalSummary(requestedFor, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read`
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNonEmployeeBulkUploadStatus(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNonEmployeeRecord(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNonEmployeeRequest(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary: function (requestedFor, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNonEmployeeRequestSummary(requestedFor, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute: function (attributeId, sourceId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource: function (sourceId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNonEmployeeSource(sourceId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes: function (sourceId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk: function (id, data, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.importNonEmployeeRecordsInBulk(id, data, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApprovals: function (requestedFor, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listNonEmployeeApprovals(requestedFor, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords: function (limit, offset, count, sorters, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listNonEmployeeRecords(limit, offset, count, sorters, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests: function (requestedFor, limit, offset, count, sorters, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listNonEmployeeRequests(requestedFor, limit, offset, count, sorters, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources: function (requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listNonEmployeeSources(requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchNonEmployeeRecord(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update`
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute: function (attributeId, sourceId, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchNonEmployeeSchemaAttribute(attributeId, sourceId, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource: function (sourceId, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchNonEmployeeSource(sourceId, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest: function (id, nonEmployeeRejectApprovalDecision, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.rejectNonEmployeeRequest(id, nonEmployeeRejectApprovalDecision, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord: function (id, nonEmployeeRequestBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateNonEmployeeRecord(id, nonEmployeeRequestBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.NonEmployeeLifecycleManagementApiFp = NonEmployeeLifecycleManagementApiFp;
/**
 * NonEmployeeLifecycleManagementApi - factory interface
 * @export
 */
var NonEmployeeLifecycleManagementApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.NonEmployeeLifecycleManagementApiFp)(configuration);
    return {
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveNonEmployeeRequest: function (id, nonEmployeeApprovalDecision, axiosOptions) {
            return localVarFp.approveNonEmployeeRequest(id, nonEmployeeApprovalDecision, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRecord: function (nonEmployeeRequestBody, axiosOptions) {
            return localVarFp.createNonEmployeeRecord(nonEmployeeRequestBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeRequest: function (nonEmployeeRequestBody, axiosOptions) {
            return localVarFp.createNonEmployeeRequest(nonEmployeeRequestBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSource: function (nonEmployeeSourceRequestBody, axiosOptions) {
            return localVarFp.createNonEmployeeSource(nonEmployeeSourceRequestBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createNonEmployeeSourceSchemaAttributes: function (sourceId, nonEmployeeSchemaAttributeBody, axiosOptions) {
            return localVarFp.createNonEmployeeSourceSchemaAttributes(sourceId, nonEmployeeSchemaAttributeBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecord: function (id, axiosOptions) {
            return localVarFp.deleteNonEmployeeRecord(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {DeleteNonEmployeeRecordsInBulkRequest} deleteNonEmployeeRecordsInBulkRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRecordsInBulk: function (deleteNonEmployeeRecordsInBulkRequest, axiosOptions) {
            return localVarFp.deleteNonEmployeeRecordsInBulk(deleteNonEmployeeRecordsInBulkRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeRequest: function (id, axiosOptions) {
            return localVarFp.deleteNonEmployeeRequest(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSchemaAttribute: function (attributeId, sourceId, axiosOptions) {
            return localVarFp.deleteNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSource: function (sourceId, axiosOptions) {
            return localVarFp.deleteNonEmployeeSource(sourceId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteNonEmployeeSourceSchemaAttributes: function (sourceId, axiosOptions) {
            return localVarFp.deleteNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeRecords: function (id, axiosOptions) {
            return localVarFp.exportNonEmployeeRecords(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportNonEmployeeSourceSchemaTemplate: function (id, axiosOptions) {
            return localVarFp.exportNonEmployeeSourceSchemaTemplate(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApproval: function (id, includeDetail, axiosOptions) {
            return localVarFp.getNonEmployeeApproval(id, includeDetail, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeApprovalSummary: function (requestedFor, axiosOptions) {
            return localVarFp.getNonEmployeeApprovalSummary(requestedFor, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read`
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeBulkUploadStatus: function (id, axiosOptions) {
            return localVarFp.getNonEmployeeBulkUploadStatus(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRecord: function (id, axiosOptions) {
            return localVarFp.getNonEmployeeRecord(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequest: function (id, axiosOptions) {
            return localVarFp.getNonEmployeeRequest(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeRequestSummary: function (requestedFor, axiosOptions) {
            return localVarFp.getNonEmployeeRequestSummary(requestedFor, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSchemaAttribute: function (attributeId, sourceId, axiosOptions) {
            return localVarFp.getNonEmployeeSchemaAttribute(attributeId, sourceId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSource: function (sourceId, axiosOptions) {
            return localVarFp.getNonEmployeeSource(sourceId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getNonEmployeeSourceSchemaAttributes: function (sourceId, axiosOptions) {
            return localVarFp.getNonEmployeeSourceSchemaAttributes(sourceId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {any} data
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importNonEmployeeRecordsInBulk: function (id, data, axiosOptions) {
            return localVarFp.importNonEmployeeRecordsInBulk(id, data, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **approvalStatus**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeApprovals: function (requestedFor, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.listNonEmployeeApprovals(requestedFor, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRecords: function (limit, offset, count, sorters, filters, axiosOptions) {
            return localVarFp.listNonEmployeeRecords(limit, offset, count, sorters, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **sourceId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeRequests: function (requestedFor, limit, offset, count, sorters, filters, axiosOptions) {
            return localVarFp.listNonEmployeeRequests(requestedFor, limit, offset, count, sorters, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, sourceId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listNonEmployeeSources: function (requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions) {
            return localVarFp.listNonEmployeeSources(requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeRecord: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchNonEmployeeRecord(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update`
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSchemaAttribute: function (attributeId, sourceId, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchNonEmployeeSchemaAttribute(attributeId, sourceId, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchNonEmployeeSource: function (sourceId, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchNonEmployeeSource(sourceId, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectNonEmployeeRequest: function (id, nonEmployeeRejectApprovalDecision, axiosOptions) {
            return localVarFp.rejectNonEmployeeRequest(id, nonEmployeeRejectApprovalDecision, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateNonEmployeeRecord: function (id, nonEmployeeRequestBody, axiosOptions) {
            return localVarFp.updateNonEmployeeRecord(id, nonEmployeeRequestBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.NonEmployeeLifecycleManagementApiFactory = NonEmployeeLifecycleManagementApiFactory;
/**
 * NonEmployeeLifecycleManagementApi - object-oriented interface
 * @export
 * @class NonEmployeeLifecycleManagementApi
 * @extends {BaseAPI}
 */
var NonEmployeeLifecycleManagementApi = /** @class */ (function (_super) {
    __extends(NonEmployeeLifecycleManagementApi, _super);
    function NonEmployeeLifecycleManagementApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
     * @summary Approve a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiApproveNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.approveNonEmployeeRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).approveNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeApprovalDecision, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will create a non-employee record. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.createNonEmployeeRecord = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).createNonEmployeeRecord(requestParameters.nonEmployeeRequestBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
     * @summary Create Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.createNonEmployeeRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).createNonEmployeeRequest(requestParameters.nonEmployeeRequestBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will create a non-employee source. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.createNonEmployeeSource = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).createNonEmployeeSource(requestParameters.nonEmployeeSourceRequestBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
     * @summary Create a new Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.createNonEmployeeSourceSchemaAttributes = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).createNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, requestParameters.nonEmployeeSchemaAttributeBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.deleteNonEmployeeRecord = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).deleteNonEmployeeRecord(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
     * @summary Delete Multiple Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.deleteNonEmployeeRecordsInBulk = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).deleteNonEmployeeRecordsInBulk(requestParameters.deleteNonEmployeeRecordsInBulkRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.deleteNonEmployeeRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).deleteNonEmployeeRequest(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete`
     * @summary Delete a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.deleteNonEmployeeSchemaAttribute = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).deleteNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
     * @summary Delete Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.deleteNonEmployeeSource = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).deleteNonEmployeeSource(requestParameters.sourceId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
     * @summary Delete all custom schema attributes for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.deleteNonEmployeeSourceSchemaAttributes = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).deleteNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Non-Employee Records to CSV
     * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.exportNonEmployeeRecords = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).exportNonEmployeeRecords(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Source Schema Template
     * @param {NonEmployeeLifecycleManagementApiExportNonEmployeeSourceSchemaTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.exportNonEmployeeSourceSchemaTemplate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).exportNonEmployeeSourceSchemaTemplate(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
     * @summary Get a non-employee approval item detail
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.getNonEmployeeApproval = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).getNonEmployeeApproval(requestParameters.id, requestParameters.includeDetail, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
     * @summary Get Summary of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.getNonEmployeeApprovalSummary = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).getNonEmployeeApprovalSummary(requestParameters.requestedFor, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read`
     * @summary Obtain the status of bulk upload on the source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeBulkUploadStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.getNonEmployeeBulkUploadStatus = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).getNonEmployeeBulkUploadStatus(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a non-employee record. Requires role context of `idn:nesr:read`
     * @summary Get a Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.getNonEmployeeRecord = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).getNonEmployeeRecord(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
     * @summary Get a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.getNonEmployeeRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).getNonEmployeeRequest(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
     * @summary Get Summary of Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeRequestSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.getNonEmployeeRequestSummary = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).getNonEmployeeRequestSummary(requestParameters.requestedFor, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary Get Schema Attribute Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.getNonEmployeeSchemaAttribute = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).getNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
     * @summary Get a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.getNonEmployeeSource = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).getNonEmployeeSource(requestParameters.sourceId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary List Schema Attributes Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetNonEmployeeSourceSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.getNonEmployeeSourceSchemaAttributes = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).getNonEmployeeSourceSchemaAttributes(requestParameters.sourceId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
     * @summary Imports, or Updates, Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiImportNonEmployeeRecordsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.importNonEmployeeRecordsInBulk = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).importNonEmployeeRecordsInBulk(requestParameters.id, requestParameters.data, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
     * @summary Get List of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.listNonEmployeeApprovals = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).listNonEmployeeApprovals(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
     * @summary List Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRecordsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.listNonEmployeeRecords = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).listNonEmployeeRecords(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
     * @summary List Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeRequestsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.listNonEmployeeRequests = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).listNonEmployeeRequests(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
     * @summary List Non-Employee Sources
     * @param {NonEmployeeLifecycleManagementApiListNonEmployeeSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.listNonEmployeeSources = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).listNonEmployeeSources(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.nonEmployeeCount, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Patch Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.patchNonEmployeeRecord = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).patchNonEmployeeRecord(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update`
     * @summary Patch a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.patchNonEmployeeSchemaAttribute = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).patchNonEmployeeSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
     * @summary Patch a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchNonEmployeeSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.patchNonEmployeeSource = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).patchNonEmployeeSource(requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
     * @summary Reject a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiRejectNonEmployeeRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.rejectNonEmployeeRequest = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).rejectNonEmployeeRequest(requestParameters.id, requestParameters.nonEmployeeRejectApprovalDecision, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Update Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiUpdateNonEmployeeRecordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    NonEmployeeLifecycleManagementApi.prototype.updateNonEmployeeRecord = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.NonEmployeeLifecycleManagementApiFp)(this.configuration).updateNonEmployeeRecord(requestParameters.id, requestParameters.nonEmployeeRequestBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return NonEmployeeLifecycleManagementApi;
}(base_1.BaseAPI));
exports.NonEmployeeLifecycleManagementApi = NonEmployeeLifecycleManagementApi;
/**
 * OAuthClientsApi - axios parameter creator
 * @export
 */
var OAuthClientsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient: function (createOAuthClientRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'createOAuthClientRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createOauthClient', 'createOAuthClientRequest', createOAuthClientRequest);
                            localVarPath = "/oauth-clients";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createOAuthClientRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteOauthClient', 'id', id);
                            localVarPath = "/oauth-clients/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getOauthClient', 'id', id);
                            localVarPath = "/oauth-clients/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients: function (filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/oauth-clients";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchOauthClient', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchOauthClient', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/oauth-clients/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.OAuthClientsApiAxiosParamCreator = OAuthClientsApiAxiosParamCreator;
/**
 * OAuthClientsApi - functional programming interface
 * @export
 */
var OAuthClientsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.OAuthClientsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient: function (createOAuthClientRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createOauthClient(createOAuthClientRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteOauthClient(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getOauthClient(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients: function (filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listOauthClients(filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchOauthClient(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.OAuthClientsApiFp = OAuthClientsApiFp;
/**
 * OAuthClientsApi - factory interface
 * @export
 */
var OAuthClientsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.OAuthClientsApiFp)(configuration);
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient: function (createOAuthClientRequest, axiosOptions) {
            return localVarFp.createOauthClient(createOAuthClientRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient: function (id, axiosOptions) {
            return localVarFp.deleteOauthClient(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient: function (id, axiosOptions) {
            return localVarFp.getOauthClient(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients: function (filters, axiosOptions) {
            return localVarFp.listOauthClients(filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchOauthClient(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.OAuthClientsApiFactory = OAuthClientsApiFactory;
/**
 * OAuthClientsApi - object-oriented interface
 * @export
 * @class OAuthClientsApi
 * @extends {BaseAPI}
 */
var OAuthClientsApi = /** @class */ (function (_super) {
    __extends(OAuthClientsApi, _super);
    function OAuthClientsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This creates an OAuth client.
     * @summary Create OAuth Client
     * @param {OAuthClientsApiCreateOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    OAuthClientsApi.prototype.createOauthClient = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.OAuthClientsApiFp)(this.configuration).createOauthClient(requestParameters.createOAuthClientRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This deletes an OAuth client.
     * @summary Delete OAuth Client
     * @param {OAuthClientsApiDeleteOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    OAuthClientsApi.prototype.deleteOauthClient = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.OAuthClientsApiFp)(this.configuration).deleteOauthClient(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets details of an OAuth client.
     * @summary Get OAuth Client
     * @param {OAuthClientsApiGetOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    OAuthClientsApi.prototype.getOauthClient = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.OAuthClientsApiFp)(this.configuration).getOauthClient(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a list of OAuth clients.
     * @summary List OAuth Clients
     * @param {OAuthClientsApiListOauthClientsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    OAuthClientsApi.prototype.listOauthClients = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.OAuthClientsApiFp)(this.configuration).listOauthClients(requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This performs a targeted update to the field(s) of an OAuth client.
     * @summary Patch OAuth Client
     * @param {OAuthClientsApiPatchOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    OAuthClientsApi.prototype.patchOauthClient = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.OAuthClientsApiFp)(this.configuration).patchOauthClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return OAuthClientsApi;
}(base_1.BaseAPI));
exports.OAuthClientsApi = OAuthClientsApi;
/**
 * PasswordConfigurationApi - axios parameter creator
 * @export
 */
var PasswordConfigurationApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig: function (passwordOrgConfig, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'passwordOrgConfig' is not null or undefined
                            (0, common_1.assertParamExists)('createPasswordOrgConfig', 'passwordOrgConfig', passwordOrgConfig);
                            localVarPath = "/password-org-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(passwordOrgConfig, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/password-org-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordOrgConfig: function (passwordOrgConfig, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'passwordOrgConfig' is not null or undefined
                            (0, common_1.assertParamExists)('putPasswordOrgConfig', 'passwordOrgConfig', passwordOrgConfig);
                            localVarPath = "/password-org-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(passwordOrgConfig, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.PasswordConfigurationApiAxiosParamCreator = PasswordConfigurationApiAxiosParamCreator;
/**
 * PasswordConfigurationApi - functional programming interface
 * @export
 */
var PasswordConfigurationApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PasswordConfigurationApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig: function (passwordOrgConfig, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createPasswordOrgConfig(passwordOrgConfig, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPasswordOrgConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordOrgConfig: function (passwordOrgConfig, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putPasswordOrgConfig(passwordOrgConfig, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PasswordConfigurationApiFp = PasswordConfigurationApiFp;
/**
 * PasswordConfigurationApi - factory interface
 * @export
 */
var PasswordConfigurationApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PasswordConfigurationApiFp)(configuration);
    return {
        /**
         * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Create Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordOrgConfig: function (passwordOrgConfig, axiosOptions) {
            return localVarFp.createPasswordOrgConfig(passwordOrgConfig, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
         * @summary Get Password Org Config
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordOrgConfig: function (axiosOptions) {
            return localVarFp.getPasswordOrgConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
         * @summary Update Password Org Config
         * @param {PasswordOrgConfig} passwordOrgConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordOrgConfig: function (passwordOrgConfig, axiosOptions) {
            return localVarFp.putPasswordOrgConfig(passwordOrgConfig, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PasswordConfigurationApiFactory = PasswordConfigurationApiFactory;
/**
 * PasswordConfigurationApi - object-oriented interface
 * @export
 * @class PasswordConfigurationApi
 * @extends {BaseAPI}
 */
var PasswordConfigurationApi = /** @class */ (function (_super) {
    __extends(PasswordConfigurationApi, _super);
    function PasswordConfigurationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API creates the password org config. Unspecified fields will use default value. To be able to use the custom password instructions, you must set the `customInstructionsEnabled` field to \"true\". Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Create Password Org Config
     * @param {PasswordConfigurationApiCreatePasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    PasswordConfigurationApi.prototype.createPasswordOrgConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordConfigurationApiFp)(this.configuration).createPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the password org config . Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:read\'
     * @summary Get Password Org Config
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    PasswordConfigurationApi.prototype.getPasswordOrgConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.PasswordConfigurationApiFp)(this.configuration).getPasswordOrgConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API updates the password org config for specified fields. Other fields will keep original value. You must set the `customInstructionsEnabled` field to \"true\" to be able to use custom password instructions.  Requires ORG_ADMIN, API role or authorization scope of \'idn:password-org-config:write\'
     * @summary Update Password Org Config
     * @param {PasswordConfigurationApiPutPasswordOrgConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordConfigurationApi
     */
    PasswordConfigurationApi.prototype.putPasswordOrgConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordConfigurationApiFp)(this.configuration).putPasswordOrgConfig(requestParameters.passwordOrgConfig, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PasswordConfigurationApi;
}(base_1.BaseAPI));
exports.PasswordConfigurationApi = PasswordConfigurationApi;
/**
 * PasswordDictionaryApi - axios parameter creator
 * @export
 */
var PasswordDictionaryApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/password-dictionary";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Update Password Dictionary
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordDictionary: function (file, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/password-dictionary";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (file !== undefined) {
                                localVarFormParams.append('file', file);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.PasswordDictionaryApiAxiosParamCreator = PasswordDictionaryApiAxiosParamCreator;
/**
 * PasswordDictionaryApi - functional programming interface
 * @export
 */
var PasswordDictionaryApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PasswordDictionaryApiAxiosParamCreator)(configuration);
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPasswordDictionary(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Update Password Dictionary
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordDictionary: function (file, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putPasswordDictionary(file, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PasswordDictionaryApiFp = PasswordDictionaryApiFp;
/**
 * PasswordDictionaryApi - factory interface
 * @export
 */
var PasswordDictionaryApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PasswordDictionaryApiFp)(configuration);
    return {
        /**
         * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Get Password Dictionary
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordDictionary: function (axiosOptions) {
            return localVarFp.getPasswordDictionary(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
         * @summary Update Password Dictionary
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPasswordDictionary: function (file, axiosOptions) {
            return localVarFp.putPasswordDictionary(file, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PasswordDictionaryApiFactory = PasswordDictionaryApiFactory;
/**
 * PasswordDictionaryApi - object-oriented interface
 * @export
 * @class PasswordDictionaryApi
 * @extends {BaseAPI}
 */
var PasswordDictionaryApi = /** @class */ (function (_super) {
    __extends(PasswordDictionaryApi, _super);
    function PasswordDictionaryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This gets password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
     * @summary Get Password Dictionary
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryApi
     */
    PasswordDictionaryApi.prototype.getPasswordDictionary = function (axiosOptions) {
        var _this = this;
        return (0, exports.PasswordDictionaryApiFp)(this.configuration).getPasswordDictionary(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This updates password dictionary for the organization. A token with ORG_ADMIN authority is required to call this API. The password dictionary file can contain lines that are: 1. comment lines - the first character is \'#\', can be 128 Unicode codepoints in length, and are ignored during processing 2. empty lines 3. locale line - the first line that starts with \"locale=\" is considered to be locale line, the rest are treated as normal content lines 4. line containing the password dictionary word - it must start with non-whitespace character and only non-whitespace characters are allowed;         maximum length of the line is 128 Unicode codepoints   Password dictionary file may not contain more than 2,500 lines (not counting whitespace lines, comment lines and locale line).   Password dict file must contain UTF-8 characters only.  # Sample password text file  ```  # Password dictionary small test file  locale=en_US  # Password dictionary prohibited words  qwerty abcd aaaaa password qazxsws  ```
     * @summary Update Password Dictionary
     * @param {PasswordDictionaryApiPutPasswordDictionaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordDictionaryApi
     */
    PasswordDictionaryApi.prototype.putPasswordDictionary = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.PasswordDictionaryApiFp)(this.configuration).putPasswordDictionary(requestParameters.file, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PasswordDictionaryApi;
}(base_1.BaseAPI));
exports.PasswordDictionaryApi = PasswordDictionaryApi;
/**
 * PasswordManagementApi - axios parameter creator
 * @export
 */
var PasswordManagementApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getPasswordChangeStatus', 'id', id);
                            localVarPath = "/password-change-status/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned.
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo: function (passwordInfoQueryDTO, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'passwordInfoQueryDTO' is not null or undefined
                            (0, common_1.assertParamExists)('queryPasswordInfo', 'passwordInfoQueryDTO', passwordInfoQueryDTO);
                            localVarPath = "/query-password-info";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(passwordInfoQueryDTO, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword: function (passwordChangeRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'passwordChangeRequest' is not null or undefined
                            (0, common_1.assertParamExists)('setPassword', 'passwordChangeRequest', passwordChangeRequest);
                            localVarPath = "/set-password";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(passwordChangeRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.PasswordManagementApiAxiosParamCreator = PasswordManagementApiAxiosParamCreator;
/**
 * PasswordManagementApi - functional programming interface
 * @export
 */
var PasswordManagementApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PasswordManagementApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPasswordChangeStatus(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned.
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo: function (passwordInfoQueryDTO, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.queryPasswordInfo(passwordInfoQueryDTO, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword: function (passwordChangeRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setPassword(passwordChangeRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PasswordManagementApiFp = PasswordManagementApiFp;
/**
 * PasswordManagementApi - factory interface
 * @export
 */
var PasswordManagementApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PasswordManagementApiFp)(configuration);
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus: function (id, axiosOptions) {
            return localVarFp.getPasswordChangeStatus(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned.
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo: function (passwordInfoQueryDTO, axiosOptions) {
            return localVarFp.queryPasswordInfo(passwordInfoQueryDTO, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword: function (passwordChangeRequest, axiosOptions) {
            return localVarFp.setPassword(passwordChangeRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PasswordManagementApiFactory = PasswordManagementApiFactory;
/**
 * PasswordManagementApi - object-oriented interface
 * @export
 * @class PasswordManagementApi
 * @extends {BaseAPI}
 */
var PasswordManagementApi = /** @class */ (function (_super) {
    __extends(PasswordManagementApi, _super);
    function PasswordManagementApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
     * @summary Get Password Change Request Status
     * @param {PasswordManagementApiGetPasswordChangeStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    PasswordManagementApi.prototype.getPasswordChangeStatus = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordManagementApiFp)(this.configuration).getPasswordChangeStatus(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned.
     * @summary Query Password Info
     * @param {PasswordManagementApiQueryPasswordInfoRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    PasswordManagementApi.prototype.queryPasswordInfo = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordManagementApiFp)(this.configuration).queryPasswordInfo(requestParameters.passwordInfoQueryDTO, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API is used to set a password for an identity.   An identity can change their own password (as well as any of their accounts\' passwords) if they use a token generated by their ISC user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password or the password of any of the identity\'s accounts.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type.  >**Note: If you want to set an identity\'s source account password, you must enable `PASSWORD` as one of the source\'s features. You can use the [PATCH Source endpoint](https://developer.sailpoint.com/docs/api/v3/update-source) to add the `PASSWORD` feature.**  You can use this endpoint to generate an `encryptedPassword` (RSA encrypted using publicKey).  To do so, follow these steps:  1. Use [Query Password Info](https://developer.sailpoint.com/idn/api/v3/query-password-info) to get the following information: `identityId`, `sourceId`, `publicKeyId`, `publicKey`, `accounts`, and `policies`.   2. Choose an account from the previous response that you will provide as an `accountId` in your request to set an encrypted password.   3. Use [Set Identity\'s Password](https://developer.sailpoint.com/idn/api/v3/set-password) and provide the information you got from your earlier query. Then add this code to your request to get the encrypted password:  ```java import javax.crypto.Cipher; import java.security.KeyFactory; import java.security.PublicKey; import java.security.spec.X509EncodedKeySpec; import java util.Base64;  String encrypt(String publicKey, String toEncrypt) throws Exception {   byte[] publicKeyBytes = Base64.getDecoder().decode(publicKey);   byte[] encryptedBytes = encryptRsa(publicKeyBytes, toEncrypt.getBytes(\"UTF-8\"));   return Base64.getEncoder().encodeToString(encryptedBytes); }  private byte[] encryptRsa(byte[] publicKeyBytes, byte[] toEncryptBytes) throws Exception {   PublicKey key = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(publicKeyBytes));   String transformation = \"RSA/ECB/PKCS1Padding\";   Cipher cipher = Cipher.getInstance(transformation);   cipher.init(1, key);   return cipher.doFinal(toEncryptBytes); } ```      In this example, `toEncrypt` refers to the plain text password you are setting and then encrypting, and the `publicKey` refers to the publicKey you got from the first request you sent.   You can then use [Get Password Change Request Status](https://developer.sailpoint.com/idn/api/v3/get-password-change-status) to check the password change request status. To do so, you must provide the `requestId` from your earlier request to set the password.
     * @summary Set Identity\'s Password
     * @param {PasswordManagementApiSetPasswordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    PasswordManagementApi.prototype.setPassword = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordManagementApiFp)(this.configuration).setPassword(requestParameters.passwordChangeRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PasswordManagementApi;
}(base_1.BaseAPI));
exports.PasswordManagementApi = PasswordManagementApi;
/**
 * PasswordPoliciesApi - axios parameter creator
 * @export
 */
var PasswordPoliciesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API creates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Policy
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordPolicy: function (passwordPolicyV3Dto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'passwordPolicyV3Dto' is not null or undefined
                            (0, common_1.assertParamExists)('createPasswordPolicy', 'passwordPolicyV3Dto', passwordPolicyV3Dto);
                            localVarPath = "/password-policies";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(passwordPolicyV3Dto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API deletes the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Policy by ID
         * @param {string} id The ID of password policy to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordPolicy: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deletePasswordPolicy', 'id', id);
                            localVarPath = "/password-policies/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the password policy for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Policy by ID
         * @param {string} id The ID of password policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordPolicyById: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getPasswordPolicyById', 'id', id);
                            localVarPath = "/password-policies/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets list of all Password Policies. Requires role of ORG_ADMIN
         * @summary List Password Policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPasswordPolicies: function (limit, offset, count, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/password-policies";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API updates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Policy by ID
         * @param {string} id The ID of password policy to update.
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordPolicy: function (id, passwordPolicyV3Dto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('setPasswordPolicy', 'id', id);
                            // verify required parameter 'passwordPolicyV3Dto' is not null or undefined
                            (0, common_1.assertParamExists)('setPasswordPolicy', 'passwordPolicyV3Dto', passwordPolicyV3Dto);
                            localVarPath = "/password-policies/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(passwordPolicyV3Dto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.PasswordPoliciesApiAxiosParamCreator = PasswordPoliciesApiAxiosParamCreator;
/**
 * PasswordPoliciesApi - functional programming interface
 * @export
 */
var PasswordPoliciesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PasswordPoliciesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API creates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Policy
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordPolicy: function (passwordPolicyV3Dto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createPasswordPolicy(passwordPolicyV3Dto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API deletes the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Policy by ID
         * @param {string} id The ID of password policy to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordPolicy: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deletePasswordPolicy(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the password policy for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Policy by ID
         * @param {string} id The ID of password policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordPolicyById: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPasswordPolicyById(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets list of all Password Policies. Requires role of ORG_ADMIN
         * @summary List Password Policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPasswordPolicies: function (limit, offset, count, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listPasswordPolicies(limit, offset, count, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API updates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Policy by ID
         * @param {string} id The ID of password policy to update.
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordPolicy: function (id, passwordPolicyV3Dto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setPasswordPolicy(id, passwordPolicyV3Dto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PasswordPoliciesApiFp = PasswordPoliciesApiFp;
/**
 * PasswordPoliciesApi - factory interface
 * @export
 */
var PasswordPoliciesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PasswordPoliciesApiFp)(configuration);
    return {
        /**
         * This API creates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Policy
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordPolicy: function (passwordPolicyV3Dto, axiosOptions) {
            return localVarFp.createPasswordPolicy(passwordPolicyV3Dto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API deletes the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Policy by ID
         * @param {string} id The ID of password policy to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordPolicy: function (id, axiosOptions) {
            return localVarFp.deletePasswordPolicy(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the password policy for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Policy by ID
         * @param {string} id The ID of password policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordPolicyById: function (id, axiosOptions) {
            return localVarFp.getPasswordPolicyById(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets list of all Password Policies. Requires role of ORG_ADMIN
         * @summary List Password Policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPasswordPolicies: function (limit, offset, count, axiosOptions) {
            return localVarFp.listPasswordPolicies(limit, offset, count, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API updates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Policy by ID
         * @param {string} id The ID of password policy to update.
         * @param {PasswordPolicyV3Dto} passwordPolicyV3Dto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordPolicy: function (id, passwordPolicyV3Dto, axiosOptions) {
            return localVarFp.setPasswordPolicy(id, passwordPolicyV3Dto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PasswordPoliciesApiFactory = PasswordPoliciesApiFactory;
/**
 * PasswordPoliciesApi - object-oriented interface
 * @export
 * @class PasswordPoliciesApi
 * @extends {BaseAPI}
 */
var PasswordPoliciesApi = /** @class */ (function (_super) {
    __extends(PasswordPoliciesApi, _super);
    function PasswordPoliciesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API creates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Password Policy
     * @param {PasswordPoliciesApiCreatePasswordPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    PasswordPoliciesApi.prototype.createPasswordPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordPoliciesApiFp)(this.configuration).createPasswordPolicy(requestParameters.passwordPolicyV3Dto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API deletes the specified password policy. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Password Policy by ID
     * @param {PasswordPoliciesApiDeletePasswordPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    PasswordPoliciesApi.prototype.deletePasswordPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordPoliciesApiFp)(this.configuration).deletePasswordPolicy(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the password policy for the specified ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Policy by ID
     * @param {PasswordPoliciesApiGetPasswordPolicyByIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    PasswordPoliciesApi.prototype.getPasswordPolicyById = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordPoliciesApiFp)(this.configuration).getPasswordPolicyById(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets list of all Password Policies. Requires role of ORG_ADMIN
     * @summary List Password Policies
     * @param {PasswordPoliciesApiListPasswordPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    PasswordPoliciesApi.prototype.listPasswordPolicies = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.PasswordPoliciesApiFp)(this.configuration).listPasswordPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API updates the specified password policy. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Password Policy by ID
     * @param {PasswordPoliciesApiSetPasswordPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordPoliciesApi
     */
    PasswordPoliciesApi.prototype.setPasswordPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordPoliciesApiFp)(this.configuration).setPasswordPolicy(requestParameters.id, requestParameters.passwordPolicyV3Dto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PasswordPoliciesApi;
}(base_1.BaseAPI));
exports.PasswordPoliciesApi = PasswordPoliciesApi;
/**
 * PasswordSyncGroupsApi - axios parameter creator
 * @export
 */
var PasswordSyncGroupsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup: function (passwordSyncGroup, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'passwordSyncGroup' is not null or undefined
                            (0, common_1.assertParamExists)('createPasswordSyncGroup', 'passwordSyncGroup', passwordSyncGroup);
                            localVarPath = "/password-sync-groups";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(passwordSyncGroup, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deletePasswordSyncGroup', 'id', id);
                            localVarPath = "/password-sync-groups/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getPasswordSyncGroup', 'id', id);
                            localVarPath = "/password-sync-groups/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups: function (limit, offset, count, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/password-sync-groups";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup: function (id, passwordSyncGroup, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('updatePasswordSyncGroup', 'id', id);
                            // verify required parameter 'passwordSyncGroup' is not null or undefined
                            (0, common_1.assertParamExists)('updatePasswordSyncGroup', 'passwordSyncGroup', passwordSyncGroup);
                            localVarPath = "/password-sync-groups/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(passwordSyncGroup, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.PasswordSyncGroupsApiAxiosParamCreator = PasswordSyncGroupsApiAxiosParamCreator;
/**
 * PasswordSyncGroupsApi - functional programming interface
 * @export
 */
var PasswordSyncGroupsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PasswordSyncGroupsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup: function (passwordSyncGroup, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createPasswordSyncGroup(passwordSyncGroup, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deletePasswordSyncGroup(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPasswordSyncGroup(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups: function (limit, offset, count, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPasswordSyncGroups(limit, offset, count, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup: function (id, passwordSyncGroup, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updatePasswordSyncGroup(id, passwordSyncGroup, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PasswordSyncGroupsApiFp = PasswordSyncGroupsApiFp;
/**
 * PasswordSyncGroupsApi - factory interface
 * @export
 */
var PasswordSyncGroupsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PasswordSyncGroupsApiFp)(configuration);
    return {
        /**
         * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Password Sync Group
         * @param {PasswordSyncGroup} passwordSyncGroup
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPasswordSyncGroup: function (passwordSyncGroup, axiosOptions) {
            return localVarFp.createPasswordSyncGroup(passwordSyncGroup, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Password Sync Group by ID
         * @param {string} id The ID of password sync group to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePasswordSyncGroup: function (id, axiosOptions) {
            return localVarFp.deletePasswordSyncGroup(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group by ID
         * @param {string} id The ID of password sync group to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroup: function (id, axiosOptions) {
            return localVarFp.getPasswordSyncGroup(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get Password Sync Group List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordSyncGroups: function (limit, offset, count, axiosOptions) {
            return localVarFp.getPasswordSyncGroups(limit, offset, count, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Password Sync Group by ID
         * @param {string} id The ID of password sync group to update.
         * @param {PasswordSyncGroup} passwordSyncGroup
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordSyncGroup: function (id, passwordSyncGroup, axiosOptions) {
            return localVarFp.updatePasswordSyncGroup(id, passwordSyncGroup, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PasswordSyncGroupsApiFactory = PasswordSyncGroupsApiFactory;
/**
 * PasswordSyncGroupsApi - object-oriented interface
 * @export
 * @class PasswordSyncGroupsApi
 * @extends {BaseAPI}
 */
var PasswordSyncGroupsApi = /** @class */ (function (_super) {
    __extends(PasswordSyncGroupsApi, _super);
    function PasswordSyncGroupsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API creates a password sync group based on the specifications provided. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Password Sync Group
     * @param {PasswordSyncGroupsApiCreatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    PasswordSyncGroupsApi.prototype.createPasswordSyncGroup = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordSyncGroupsApiFp)(this.configuration).createPasswordSyncGroup(requestParameters.passwordSyncGroup, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API deletes the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Password Sync Group by ID
     * @param {PasswordSyncGroupsApiDeletePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    PasswordSyncGroupsApi.prototype.deletePasswordSyncGroup = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordSyncGroupsApiFp)(this.configuration).deletePasswordSyncGroup(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the sync group for the specified ID. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Sync Group by ID
     * @param {PasswordSyncGroupsApiGetPasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    PasswordSyncGroupsApi.prototype.getPasswordSyncGroup = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordSyncGroupsApiFp)(this.configuration).getPasswordSyncGroup(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a list of password sync groups. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get Password Sync Group List
     * @param {PasswordSyncGroupsApiGetPasswordSyncGroupsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    PasswordSyncGroupsApi.prototype.getPasswordSyncGroups = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.PasswordSyncGroupsApiFp)(this.configuration).getPasswordSyncGroups(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API updates the specified password sync group. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Password Sync Group by ID
     * @param {PasswordSyncGroupsApiUpdatePasswordSyncGroupRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordSyncGroupsApi
     */
    PasswordSyncGroupsApi.prototype.updatePasswordSyncGroup = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PasswordSyncGroupsApiFp)(this.configuration).updatePasswordSyncGroup(requestParameters.id, requestParameters.passwordSyncGroup, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PasswordSyncGroupsApi;
}(base_1.BaseAPI));
exports.PasswordSyncGroupsApi = PasswordSyncGroupsApi;
/**
 * PersonalAccessTokensApi - axios parameter creator
 * @export
 */
var PersonalAccessTokensApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken: function (createPersonalAccessTokenRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'createPersonalAccessTokenRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createPersonalAccessToken', 'createPersonalAccessTokenRequest', createPersonalAccessTokenRequest);
                            localVarPath = "/personal-access-tokens";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPersonalAccessTokenRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deletePersonalAccessToken', 'id', id);
                            localVarPath = "/personal-access-tokens/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens: function (ownerId, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/personal-access-tokens";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (ownerId !== undefined) {
                                localVarQueryParameter['owner-id'] = ownerId;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token. Changing scopes for a Personal Access Token does not impact existing bearer tokens. You will need to create a new bearer token to have the new scopes. Please note that it can take up to 20 minutes for scope changes to be seen on new bearer tokens.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchPersonalAccessToken', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchPersonalAccessToken', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/personal-access-tokens/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.PersonalAccessTokensApiAxiosParamCreator = PersonalAccessTokensApiAxiosParamCreator;
/**
 * PersonalAccessTokensApi - functional programming interface
 * @export
 */
var PersonalAccessTokensApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PersonalAccessTokensApiAxiosParamCreator)(configuration);
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken: function (createPersonalAccessTokenRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createPersonalAccessToken(createPersonalAccessTokenRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deletePersonalAccessToken(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens: function (ownerId, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listPersonalAccessTokens(ownerId, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token. Changing scopes for a Personal Access Token does not impact existing bearer tokens. You will need to create a new bearer token to have the new scopes. Please note that it can take up to 20 minutes for scope changes to be seen on new bearer tokens.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchPersonalAccessToken(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PersonalAccessTokensApiFp = PersonalAccessTokensApiFp;
/**
 * PersonalAccessTokensApi - factory interface
 * @export
 */
var PersonalAccessTokensApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PersonalAccessTokensApiFp)(configuration);
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken: function (createPersonalAccessTokenRequest, axiosOptions) {
            return localVarFp.createPersonalAccessToken(createPersonalAccessTokenRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken: function (id, axiosOptions) {
            return localVarFp.deletePersonalAccessToken(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **lastUsed**: *le, isnull*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens: function (ownerId, filters, axiosOptions) {
            return localVarFp.listPersonalAccessTokens(ownerId, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token. Changing scopes for a Personal Access Token does not impact existing bearer tokens. You will need to create a new bearer token to have the new scopes. Please note that it can take up to 20 minutes for scope changes to be seen on new bearer tokens.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchPersonalAccessToken(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PersonalAccessTokensApiFactory = PersonalAccessTokensApiFactory;
/**
 * PersonalAccessTokensApi - object-oriented interface
 * @export
 * @class PersonalAccessTokensApi
 * @extends {BaseAPI}
 */
var PersonalAccessTokensApi = /** @class */ (function (_super) {
    __extends(PersonalAccessTokensApi, _super);
    function PersonalAccessTokensApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This creates a personal access token.
     * @summary Create Personal Access Token
     * @param {PersonalAccessTokensApiCreatePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    PersonalAccessTokensApi.prototype.createPersonalAccessToken = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PersonalAccessTokensApiFp)(this.configuration).createPersonalAccessToken(requestParameters.createPersonalAccessTokenRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This deletes a personal access token.
     * @summary Delete Personal Access Token
     * @param {PersonalAccessTokensApiDeletePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    PersonalAccessTokensApi.prototype.deletePersonalAccessToken = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PersonalAccessTokensApiFp)(this.configuration).deletePersonalAccessToken(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
     * @summary List Personal Access Tokens
     * @param {PersonalAccessTokensApiListPersonalAccessTokensRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    PersonalAccessTokensApi.prototype.listPersonalAccessTokens = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.PersonalAccessTokensApiFp)(this.configuration).listPersonalAccessTokens(requestParameters.ownerId, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This performs a targeted update to the field(s) of a Personal Access Token. Changing scopes for a Personal Access Token does not impact existing bearer tokens. You will need to create a new bearer token to have the new scopes. Please note that it can take up to 20 minutes for scope changes to be seen on new bearer tokens.
     * @summary Patch Personal Access Token
     * @param {PersonalAccessTokensApiPatchPersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    PersonalAccessTokensApi.prototype.patchPersonalAccessToken = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PersonalAccessTokensApiFp)(this.configuration).patchPersonalAccessToken(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PersonalAccessTokensApi;
}(base_1.BaseAPI));
exports.PersonalAccessTokensApi = PersonalAccessTokensApi;
/**
 * PublicIdentitiesApi - axios parameter creator
 * @export
 */
var PublicIdentitiesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities: function (limit, offset, count, filters, addCoreFilters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/public-identities";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (addCoreFilters !== undefined) {
                                localVarQueryParameter['add-core-filters'] = addCoreFilters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.PublicIdentitiesApiAxiosParamCreator = PublicIdentitiesApiAxiosParamCreator;
/**
 * PublicIdentitiesApi - functional programming interface
 * @export
 */
var PublicIdentitiesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PublicIdentitiesApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities: function (limit, offset, count, filters, addCoreFilters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPublicIdentities(limit, offset, count, filters, addCoreFilters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PublicIdentitiesApiFp = PublicIdentitiesApiFp;
/**
 * PublicIdentitiesApi - factory interface
 * @export
 */
var PublicIdentitiesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PublicIdentitiesApiFp)(configuration);
    return {
        /**
         *
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities: function (limit, offset, count, filters, addCoreFilters, sorters, axiosOptions) {
            return localVarFp.getPublicIdentities(limit, offset, count, filters, addCoreFilters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PublicIdentitiesApiFactory = PublicIdentitiesApiFactory;
/**
 * PublicIdentitiesApi - object-oriented interface
 * @export
 * @class PublicIdentitiesApi
 * @extends {BaseAPI}
 */
var PublicIdentitiesApi = /** @class */ (function (_super) {
    __extends(PublicIdentitiesApi, _super);
    function PublicIdentitiesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get a list of public identities
     * @param {PublicIdentitiesApiGetPublicIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesApi
     */
    PublicIdentitiesApi.prototype.getPublicIdentities = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.PublicIdentitiesApiFp)(this.configuration).getPublicIdentities(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.addCoreFilters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PublicIdentitiesApi;
}(base_1.BaseAPI));
exports.PublicIdentitiesApi = PublicIdentitiesApi;
/**
 * PublicIdentitiesConfigApi - axios parameter creator
 * @export
 */
var PublicIdentitiesConfigApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/public-identities-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig: function (publicIdentityConfig, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'publicIdentityConfig' is not null or undefined
                            (0, common_1.assertParamExists)('updatePublicIdentityConfig', 'publicIdentityConfig', publicIdentityConfig);
                            localVarPath = "/public-identities-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(publicIdentityConfig, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.PublicIdentitiesConfigApiAxiosParamCreator = PublicIdentitiesConfigApiAxiosParamCreator;
/**
 * PublicIdentitiesConfigApi - functional programming interface
 * @export
 */
var PublicIdentitiesConfigApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PublicIdentitiesConfigApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPublicIdentityConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig: function (publicIdentityConfig, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updatePublicIdentityConfig(publicIdentityConfig, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PublicIdentitiesConfigApiFp = PublicIdentitiesConfigApiFp;
/**
 * PublicIdentitiesConfigApi - factory interface
 * @export
 */
var PublicIdentitiesConfigApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PublicIdentitiesConfigApiFp)(configuration);
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig: function (axiosOptions) {
            return localVarFp.getPublicIdentityConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig: function (publicIdentityConfig, axiosOptions) {
            return localVarFp.updatePublicIdentityConfig(publicIdentityConfig, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PublicIdentitiesConfigApiFactory = PublicIdentitiesConfigApiFactory;
/**
 * PublicIdentitiesConfigApi - object-oriented interface
 * @export
 * @class PublicIdentitiesConfigApi
 * @extends {BaseAPI}
 */
var PublicIdentitiesConfigApi = /** @class */ (function (_super) {
    __extends(PublicIdentitiesConfigApi, _super);
    function PublicIdentitiesConfigApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
     * @summary Get the Public Identities Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    PublicIdentitiesConfigApi.prototype.getPublicIdentityConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.PublicIdentitiesConfigApiFp)(this.configuration).getPublicIdentityConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
     * @summary Update the Public Identities Configuration
     * @param {PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    PublicIdentitiesConfigApi.prototype.updatePublicIdentityConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PublicIdentitiesConfigApiFp)(this.configuration).updatePublicIdentityConfig(requestParameters.publicIdentityConfig, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PublicIdentitiesConfigApi;
}(base_1.BaseAPI));
exports.PublicIdentitiesConfigApi = PublicIdentitiesConfigApi;
/**
 * ReportsDataExtractionApi - axios parameter creator
 * @export
 */
var ReportsDataExtractionApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {string} id ID of the running Report to cancel
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('cancelReport', 'id', id);
                            localVarPath = "/reports/{id}/cancel"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {'csv' | 'pdf'} fileFormat Output format of the requested report file
         * @param {string} [name] preferred Report file name, by default will be used report name from task result.
         * @param {boolean} [auditable] Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReport: function (taskResultId, fileFormat, name, auditable, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'taskResultId' is not null or undefined
                            (0, common_1.assertParamExists)('getReport', 'taskResultId', taskResultId);
                            // verify required parameter 'fileFormat' is not null or undefined
                            (0, common_1.assertParamExists)('getReport', 'fileFormat', fileFormat);
                            localVarPath = "/reports/{taskResultId}"
                                .replace("{".concat("taskResultId", "}"), encodeURIComponent(String(taskResultId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (fileFormat !== undefined) {
                                localVarQueryParameter['fileFormat'] = fileFormat;
                            }
                            if (name !== undefined) {
                                localVarQueryParameter['name'] = name;
                            }
                            if (auditable !== undefined) {
                                localVarQueryParameter['auditable'] = auditable;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {boolean} [completed] state of task result to apply ordering when results are fetching from the DB
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReportResult: function (taskResultId, completed, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'taskResultId' is not null or undefined
                            (0, common_1.assertParamExists)('getReportResult', 'taskResultId', taskResultId);
                            localVarPath = "/reports/{taskResultId}/result"
                                .replace("{".concat("taskResultId", "}"), encodeURIComponent(String(taskResultId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (completed !== undefined) {
                                localVarQueryParameter['completed'] = completed;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportDetails} reportDetails
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startReport: function (reportDetails, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'reportDetails' is not null or undefined
                            (0, common_1.assertParamExists)('startReport', 'reportDetails', reportDetails);
                            localVarPath = "/reports/run";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(reportDetails, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ReportsDataExtractionApiAxiosParamCreator = ReportsDataExtractionApiAxiosParamCreator;
/**
 * ReportsDataExtractionApi - functional programming interface
 * @export
 */
var ReportsDataExtractionApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ReportsDataExtractionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {string} id ID of the running Report to cancel
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.cancelReport(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {'csv' | 'pdf'} fileFormat Output format of the requested report file
         * @param {string} [name] preferred Report file name, by default will be used report name from task result.
         * @param {boolean} [auditable] Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReport: function (taskResultId, fileFormat, name, auditable, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getReport(taskResultId, fileFormat, name, auditable, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {boolean} [completed] state of task result to apply ordering when results are fetching from the DB
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReportResult: function (taskResultId, completed, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getReportResult(taskResultId, completed, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportDetails} reportDetails
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startReport: function (reportDetails, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startReport(reportDetails, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ReportsDataExtractionApiFp = ReportsDataExtractionApiFp;
/**
 * ReportsDataExtractionApi - factory interface
 * @export
 */
var ReportsDataExtractionApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ReportsDataExtractionApiFp)(configuration);
    return {
        /**
         * Cancels a running report.
         * @summary Cancel Report
         * @param {string} id ID of the running Report to cancel
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: function (id, axiosOptions) {
            return localVarFp.cancelReport(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets a report in file format.
         * @summary Get Report File
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {'csv' | 'pdf'} fileFormat Output format of the requested report file
         * @param {string} [name] preferred Report file name, by default will be used report name from task result.
         * @param {boolean} [auditable] Enables auditing for current report download. Will create an audit event and sent it to the REPORT cloud-audit kafka topic.  Event will be created if there is any result present by requested taskResultId.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReport: function (taskResultId, fileFormat, name, auditable, axiosOptions) {
            return localVarFp.getReport(taskResultId, fileFormat, name, auditable, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
         * @summary Get Report Result
         * @param {string} taskResultId Unique identifier of the task result which handled report
         * @param {boolean} [completed] state of task result to apply ordering when results are fetching from the DB
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getReportResult: function (taskResultId, completed, axiosOptions) {
            return localVarFp.getReportResult(taskResultId, completed, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
         * @summary Run Report
         * @param {ReportDetails} reportDetails
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startReport: function (reportDetails, axiosOptions) {
            return localVarFp.startReport(reportDetails, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ReportsDataExtractionApiFactory = ReportsDataExtractionApiFactory;
/**
 * ReportsDataExtractionApi - object-oriented interface
 * @export
 * @class ReportsDataExtractionApi
 * @extends {BaseAPI}
 */
var ReportsDataExtractionApi = /** @class */ (function (_super) {
    __extends(ReportsDataExtractionApi, _super);
    function ReportsDataExtractionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Cancels a running report.
     * @summary Cancel Report
     * @param {ReportsDataExtractionApiCancelReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    ReportsDataExtractionApi.prototype.cancelReport = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ReportsDataExtractionApiFp)(this.configuration).cancelReport(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Gets a report in file format.
     * @summary Get Report File
     * @param {ReportsDataExtractionApiGetReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    ReportsDataExtractionApi.prototype.getReport = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ReportsDataExtractionApiFp)(this.configuration).getReport(requestParameters.taskResultId, requestParameters.fileFormat, requestParameters.name, requestParameters.auditable, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get the report results for a report that was run or is running. Returns empty report result in case there are no active task definitions with used in payload task definition name.
     * @summary Get Report Result
     * @param {ReportsDataExtractionApiGetReportResultRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    ReportsDataExtractionApi.prototype.getReportResult = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ReportsDataExtractionApiFp)(this.configuration).getReportResult(requestParameters.taskResultId, requestParameters.completed, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Runs a report according to input report details. If non-concurrent task is already running then it returns, otherwise new task creates and returns.
     * @summary Run Report
     * @param {ReportsDataExtractionApiStartReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsDataExtractionApi
     */
    ReportsDataExtractionApi.prototype.startReport = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ReportsDataExtractionApiFp)(this.configuration).startReport(requestParameters.reportDetails, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ReportsDataExtractionApi;
}(base_1.BaseAPI));
exports.ReportsDataExtractionApi = ReportsDataExtractionApi;
/**
 * RequestableObjectsApi - axios parameter creator
 * @export
 */
var RequestableObjectsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects: function (identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/requestable-objects";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (identityId !== undefined) {
                                localVarQueryParameter['identity-id'] = identityId;
                            }
                            if (types) {
                                localVarQueryParameter['types'] = types.join(base_1.COLLECTION_FORMATS.csv);
                            }
                            if (term !== undefined) {
                                localVarQueryParameter['term'] = term;
                            }
                            if (statuses) {
                                localVarQueryParameter['statuses'] = statuses.join(base_1.COLLECTION_FORMATS.csv);
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.RequestableObjectsApiAxiosParamCreator = RequestableObjectsApiAxiosParamCreator;
/**
 * RequestableObjectsApi - functional programming interface
 * @export
 */
var RequestableObjectsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.RequestableObjectsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects: function (identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.RequestableObjectsApiFp = RequestableObjectsApiFp;
/**
 * RequestableObjectsApi - factory interface
 * @export
 */
var RequestableObjectsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.RequestableObjectsApiFp)(configuration);
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects: function (identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.RequestableObjectsApiFactory = RequestableObjectsApiFactory;
/**
 * RequestableObjectsApi - object-oriented interface
 * @export
 * @class RequestableObjectsApi
 * @extends {BaseAPI}
 */
var RequestableObjectsApi = /** @class */ (function (_super) {
    __extends(RequestableObjectsApi, _super);
    function RequestableObjectsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
     * @summary Requestable Objects List
     * @param {RequestableObjectsApiListRequestableObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestableObjectsApi
     */
    RequestableObjectsApi.prototype.listRequestableObjects = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.RequestableObjectsApiFp)(this.configuration).listRequestableObjects(requestParameters.identityId, requestParameters.types, requestParameters.term, requestParameters.statuses, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return RequestableObjectsApi;
}(base_1.BaseAPI));
exports.RequestableObjectsApi = RequestableObjectsApi;
/**
 * RolesApi - axios parameter creator
 * @export
 */
var RolesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API creates a role.  You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.   In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole: function (role, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'role' is not null or undefined
                            (0, common_1.assertParamExists)('createRole', 'role', role);
                            localVarPath = "/roles";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(role, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this endpoint. In addition, a token with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequest} roleBulkDeleteRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBulkRoles: function (roleBulkDeleteRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'roleBulkDeleteRequest' is not null or undefined
                            (0, common_1.assertParamExists)('deleteBulkRoles', 'roleBulkDeleteRequest', roleBulkDeleteRequest);
                            localVarPath = "/roles/bulk-delete";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(roleBulkDeleteRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API deletes a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteRole', 'id', id);
                            localVarPath = "/roles/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getRole', 'id', id);
                            localVarPath = "/roles/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getRoleAssignedIdentities', 'id', id);
                            localVarPath = "/roles/{id}/assigned-identities"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: function (forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/roles";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (forSubadmin !== undefined) {
                                localVarQueryParameter['for-subadmin'] = forSubadmin;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            if (forSegmentIds !== undefined) {
                                localVarQueryParameter['for-segment-ids'] = forSegmentIds;
                            }
                            if (includeUnsegmented !== undefined) {
                                localVarQueryParameter['include-unsegmented'] = includeUnsegmented;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:  * name * description * enabled * owner * accessProfiles * membership * requestable * accessRequestConfig * revokeRequestConfig * segments  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchRole', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchRole', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/roles/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.RolesApiAxiosParamCreator = RolesApiAxiosParamCreator;
/**
 * RolesApi - functional programming interface
 * @export
 */
var RolesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.RolesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API creates a role.  You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.   In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole: function (role, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createRole(role, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this endpoint. In addition, a token with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequest} roleBulkDeleteRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBulkRoles: function (roleBulkDeleteRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteBulkRoles(roleBulkDeleteRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API deletes a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteRole(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getRole(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getRoleAssignedIdentities(id, limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: function (forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listRoles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:  * name * description * enabled * owner * accessProfiles * membership * requestable * accessRequestConfig * revokeRequestConfig * segments  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchRole(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.RolesApiFp = RolesApiFp;
/**
 * RolesApi - factory interface
 * @export
 */
var RolesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.RolesApiFp)(configuration);
    return {
        /**
         * This API creates a role.  You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.   In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
         * @summary Create a Role
         * @param {Role} role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createRole: function (role, axiosOptions) {
            return localVarFp.createRole(role, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this endpoint. In addition, a token with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
         * @summary Delete Role(s)
         * @param {RoleBulkDeleteRequest} roleBulkDeleteRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteBulkRoles: function (roleBulkDeleteRequest, axiosOptions) {
            return localVarFp.deleteBulkRoles(roleBulkDeleteRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API deletes a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Delete a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: function (id, axiosOptions) {
            return localVarFp.deleteRole(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
         * @summary Get a Role
         * @param {string} id ID of the Role
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRole: function (id, axiosOptions) {
            return localVarFp.getRole(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary List Identities assigned a Role
         * @param {string} id ID of the Role for which the assigned Identities are to be listed
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **aliasName**: *eq, sw*  **email**: *eq, sw*  **name**: *eq, sw, co*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, aliasName, email**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignedIdentities: function (id, limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.getRoleAssignedIdentities(id, limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary List Roles
         * @param {string} [forSubadmin] If provided, filters the returned list according to what is visible to the indicated ROLE_SUBADMIN Identity. The value of the parameter is either an Identity ID, or the special value **me**, which is shorthand for the calling Identity\&#39;s ID. A 400 Bad Request error is returned if the **for-subadmin** parameter is specified for an Identity that is not a subadmin.
         * @param {number} [limit] Note that for this API the maximum value for limit is 50. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, sw*  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*  **owner.id**: *eq, in*  **requestable**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name, created, modified**
         * @param {string} [forSegmentIds] If present and not empty, additionally filters Roles to those which are assigned to the Segment(s) with the specified IDs.  If segmentation is currently unavailable, specifying this parameter results in an error.
         * @param {boolean} [includeUnsegmented] Whether or not the response list should contain unsegmented Roles. If *for-segment-ids* is absent or empty, specifying *include-unsegmented* as false results in an error.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: function (forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions) {
            return localVarFp.listRoles(forSubadmin, limit, offset, count, filters, sorters, forSegmentIds, includeUnsegmented, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:  * name * description * enabled * owner * accessProfiles * membership * requestable * accessRequestConfig * revokeRequestConfig * segments  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time.
         * @summary Patch a specified Role
         * @param {string} id ID of the Role to patch
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchRole(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.RolesApiFactory = RolesApiFactory;
/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
var RolesApi = /** @class */ (function (_super) {
    __extends(RolesApi, _super);
    function RolesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API creates a role.  You must have a token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority to call this API.   In addition, a ROLE_SUBADMIN may not create a role including an access profile if that access profile is associated with a source the ROLE_SUBADMIN is not associated with themselves.   The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles. However, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.
     * @summary Create a Role
     * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    RolesApi.prototype.createRole = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.RolesApiFp)(this.configuration).createRole(requestParameters.role, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint initiates a bulk deletion of one or more roles. When the request is successful, the endpoint returns the bulk delete\'s task result ID.  To follow the task, you can use [Get Task Status by ID](https://developer.sailpoint.com/docs/api/beta/get-task-status), which will return the task result\'s status and information.  This endpoint can only bulk delete up to a limit of 50 roles per request.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this endpoint. In addition, a token with ROLE_SUBADMIN authority can only call this endpoint if all roles included in the request are associated with sources with management workgroups the ROLE_SUBADMIN is a member of.
     * @summary Delete Role(s)
     * @param {RolesApiDeleteBulkRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    RolesApi.prototype.deleteBulkRoles = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.RolesApiFp)(this.configuration).deleteBulkRoles(requestParameters.roleBulkDeleteRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API deletes a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Delete a Role
     * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    RolesApi.prototype.deleteRole = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.RolesApiFp)(this.configuration).deleteRole(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a Role by its ID.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all Access Profiles included in the Role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.
     * @summary Get a Role
     * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    RolesApi.prototype.getRole = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.RolesApiFp)(this.configuration).getRole(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary List Identities assigned a Role
     * @param {RolesApiGetRoleAssignedIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    RolesApi.prototype.getRoleAssignedIdentities = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.RolesApiFp)(this.configuration).getRoleAssignedIdentities(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a list of Roles.  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary List Roles
     * @param {RolesApiListRolesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    RolesApi.prototype.listRoles = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.RolesApiFp)(this.configuration).listRoles(requestParameters.forSubadmin, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSegmentIds, requestParameters.includeUnsegmented, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API updates an existing role using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.  The following fields are patchable:  * name * description * enabled * owner * accessProfiles * membership * requestable * accessRequestConfig * revokeRequestConfig * segments  A token with API, ORG_ADMIN, ROLE_ADMIN, or ROLE_SUBADMIN authority is required to call this API. In addition, a token with ROLE_SUBADMIN authority may only call this API if all access profiles included in the role are associated to Sources with management workgroups of which the ROLE_SUBADMIN is a member.  The maximum supported length for the description field is 2000 characters. Longer descriptions will be preserved for existing roles, however, any new roles as well as any updates to existing descriptions will be limited to 2000 characters.  When you use this API to modify a role\'s membership identities, you can only modify up to a limit of 500 membership identities at a time.
     * @summary Patch a specified Role
     * @param {RolesApiPatchRoleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    RolesApi.prototype.patchRole = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.RolesApiFp)(this.configuration).patchRole(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return RolesApi;
}(base_1.BaseAPI));
exports.RolesApi = RolesApi;
/**
 * SODPoliciesApi - axios parameter creator
 * @export
 */
var SODPoliciesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy: function (sodPolicy, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sodPolicy' is not null or undefined
                            (0, common_1.assertParamExists)('createSodPolicy', 'sodPolicy', sodPolicy);
                            localVarPath = "/sod-policies";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sodPolicy, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy: function (id, logical, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteSodPolicy', 'id', id);
                            localVarPath = "/sod-policies/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (logical !== undefined) {
                                localVarQueryParameter['logical'] = logical;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteSodPolicySchedule', 'id', id);
                            localVarPath = "/sod-policies/{id}/schedule"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomViolationReport: function (reportResultId, fileName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'reportResultId' is not null or undefined
                            (0, common_1.assertParamExists)('getCustomViolationReport', 'reportResultId', reportResultId);
                            // verify required parameter 'fileName' is not null or undefined
                            (0, common_1.assertParamExists)('getCustomViolationReport', 'fileName', fileName);
                            localVarPath = "/sod-violation-report/{reportResultId}/download/{fileName}"
                                .replace("{".concat("reportResultId", "}"), encodeURIComponent(String(reportResultId)))
                                .replace("{".concat("fileName", "}"), encodeURIComponent(String(fileName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultViolationReport: function (reportResultId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'reportResultId' is not null or undefined
                            (0, common_1.assertParamExists)('getDefaultViolationReport', 'reportResultId', reportResultId);
                            localVarPath = "/sod-violation-report/{reportResultId}/download"
                                .replace("{".concat("reportResultId", "}"), encodeURIComponent(String(reportResultId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/sod-violation-report";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getSodPolicy', 'id', id);
                            localVarPath = "/sod-policies/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getSodPolicySchedule', 'id', id);
                            localVarPath = "/sod-policies/{id}/schedule"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus: function (reportResultId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'reportResultId' is not null or undefined
                            (0, common_1.assertParamExists)('getSodViolationReportRunStatus', 'reportResultId', reportResultId);
                            localVarPath = "/sod-policies/sod-violation-report-status/{reportResultId}"
                                .replace("{".concat("reportResultId", "}"), encodeURIComponent(String(reportResultId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getSodViolationReportStatus', 'id', id);
                            localVarPath = "/sod-policies/{id}/violation-report"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in*  **state**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, description**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies: function (limit, offset, count, filters, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/sod-policies";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception.
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchSodPolicy', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchSodPolicy', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/sod-policies/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPolicySchedule: function (id, sodPolicySchedule, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('putPolicySchedule', 'id', id);
                            // verify required parameter 'sodPolicySchedule' is not null or undefined
                            (0, common_1.assertParamExists)('putPolicySchedule', 'sodPolicySchedule', sodPolicySchedule);
                            localVarPath = "/sod-policies/{id}/schedule"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sodPolicySchedule, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSodPolicy: function (id, sodPolicy, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('putSodPolicy', 'id', id);
                            // verify required parameter 'sodPolicy' is not null or undefined
                            (0, common_1.assertParamExists)('putSodPolicy', 'sodPolicy', sodPolicy);
                            localVarPath = "/sod-policies/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sodPolicy, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startEvaluateSodPolicy: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('startEvaluateSodPolicy', 'id', id);
                            localVarPath = "/sod-policies/{id}/evaluate"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodAllPoliciesForOrg: function (multiPolicyRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/sod-violation-report/run";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(multiPolicyRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodPolicy: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('startSodPolicy', 'id', id);
                            localVarPath = "/sod-policies/{id}/violation-report/run"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SODPoliciesApiAxiosParamCreator = SODPoliciesApiAxiosParamCreator;
/**
 * SODPoliciesApi - functional programming interface
 * @export
 */
var SODPoliciesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SODPoliciesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy: function (sodPolicy, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createSodPolicy(sodPolicy, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy: function (id, logical, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteSodPolicy(id, logical, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteSodPolicySchedule(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomViolationReport: function (reportResultId, fileName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCustomViolationReport(reportResultId, fileName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultViolationReport: function (reportResultId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDefaultViolationReport(reportResultId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSodAllReportRunStatus(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSodPolicy(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSodPolicySchedule(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus: function (reportResultId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSodViolationReportRunStatus(reportResultId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSodViolationReportStatus(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in*  **state**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, description**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies: function (limit, offset, count, filters, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listSodPolicies(limit, offset, count, filters, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception.
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchSodPolicy(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPolicySchedule: function (id, sodPolicySchedule, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putPolicySchedule(id, sodPolicySchedule, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSodPolicy: function (id, sodPolicy, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putSodPolicy(id, sodPolicy, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startEvaluateSodPolicy: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startEvaluateSodPolicy(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodAllPoliciesForOrg: function (multiPolicyRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startSodAllPoliciesForOrg(multiPolicyRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodPolicy: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startSodPolicy(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SODPoliciesApiFp = SODPoliciesApiFp;
/**
 * SODPoliciesApi - factory interface
 * @export
 */
var SODPoliciesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SODPoliciesApiFp)(configuration);
    return {
        /**
         * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
         * @summary Create SOD policy
         * @param {SodPolicy} sodPolicy
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSodPolicy: function (sodPolicy, axiosOptions) {
            return localVarFp.createSodPolicy(sodPolicy, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Delete SOD policy by ID
         * @param {string} id The ID of the SOD Policy to delete.
         * @param {boolean} [logical] Indicates whether this is a soft delete (logical true) or a hard delete.  Soft delete marks the policy as deleted and just save it with this status. It could be fully deleted or recovered further.  Hard delete vise versa permanently delete SOD request during this call.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicy: function (id, logical, axiosOptions) {
            return localVarFp.deleteSodPolicy(id, logical, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This deletes schedule for a specified SOD policy by ID.
         * @summary Delete SOD policy schedule
         * @param {string} id The ID of the SOD policy the schedule must be deleted for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSodPolicySchedule: function (id, axiosOptions) {
            return localVarFp.deleteSodPolicySchedule(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This allows to download a specified named violation report for a given report reference.
         * @summary Download custom violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {string} fileName Custom Name for the  file.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCustomViolationReport: function (reportResultId, fileName, axiosOptions) {
            return localVarFp.getCustomViolationReport(reportResultId, fileName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This allows to download a violation report for a given report reference.
         * @summary Download violation report
         * @param {string} reportResultId The ID of the report reference to download.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultViolationReport: function (reportResultId, axiosOptions) {
            return localVarFp.getDefaultViolationReport(reportResultId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint gets the status for a violation report for all policy run.
         * @summary Get multi-report run task status
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodAllReportRunStatus: function (axiosOptions) {
            return localVarFp.getSodAllReportRunStatus(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Get SOD policy by ID
         * @param {string} id The ID of the SOD Policy to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicy: function (id, axiosOptions) {
            return localVarFp.getSodPolicy(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint gets a specified SOD policy\'s schedule.
         * @summary Get SOD policy schedule
         * @param {string} id The ID of the SOD policy schedule to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodPolicySchedule: function (id, axiosOptions) {
            return localVarFp.getSodPolicySchedule(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get violation report run status
         * @param {string} reportResultId The ID of the report reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportRunStatus: function (reportResultId, axiosOptions) {
            return localVarFp.getSodViolationReportRunStatus(reportResultId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets the status for a violation report run task that has already been invoked.
         * @summary Get SOD violation report status
         * @param {string} id The ID of the violation report to retrieve status for.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSodViolationReportStatus: function (id, axiosOptions) {
            return localVarFp.getSodViolationReportStatus(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets list of all SOD policies. Requires role of ORG_ADMIN
         * @summary List SOD policies
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in*  **state**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id, name, created, modified, description**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSodPolicies: function (limit, offset, count, filters, sorters, axiosOptions) {
            return localVarFp.listSodPolicies(limit, offset, count, filters, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception.
         * @summary Patch SOD policy by ID
         * @param {string} id The ID of the SOD policy being modified.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of SOD Policy update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * ownerRef * externalPolicyReference * compensatingControls * correctionAdvice * state * tags * violationOwnerAssignmentConfig * scheduled * conflictingAccessCriteria
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSodPolicy: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchSodPolicy(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This updates schedule for a specified SOD policy.
         * @summary Update SOD Policy schedule
         * @param {string} id The ID of the SOD policy to update its schedule.
         * @param {SodPolicySchedule} sodPolicySchedule
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putPolicySchedule: function (id, sodPolicySchedule, axiosOptions) {
            return localVarFp.putPolicySchedule(id, sodPolicySchedule, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This updates a specified SOD policy. Requires role of ORG_ADMIN.
         * @summary Update SOD policy by ID
         * @param {string} id The ID of the SOD policy to update.
         * @param {SodPolicy} sodPolicy
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSodPolicy: function (id, sodPolicy, axiosOptions) {
            return localVarFp.putSodPolicy(id, sodPolicy, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
         * @summary Evaluate one policy by ID
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startEvaluateSodPolicy: function (id, axiosOptions) {
            return localVarFp.startEvaluateSodPolicy(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
         * @summary Runs all policies for org
         * @param {MultiPolicyRequest} [multiPolicyRequest]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodAllPoliciesForOrg: function (multiPolicyRequest, axiosOptions) {
            return localVarFp.startSodAllPoliciesForOrg(multiPolicyRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
         * @summary Runs SOD policy violation report
         * @param {string} id The SOD policy ID to run.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startSodPolicy: function (id, axiosOptions) {
            return localVarFp.startSodPolicy(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SODPoliciesApiFactory = SODPoliciesApiFactory;
/**
 * SODPoliciesApi - object-oriented interface
 * @export
 * @class SODPoliciesApi
 * @extends {BaseAPI}
 */
var SODPoliciesApi = /** @class */ (function (_super) {
    __extends(SODPoliciesApi, _super);
    function SODPoliciesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This creates both General and Conflicting Access Based policy, with a limit of 50 entitlements for each (left & right) criteria for Conflicting Access Based SOD policy. Requires role of ORG_ADMIN.
     * @summary Create SOD policy
     * @param {SODPoliciesApiCreateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.createSodPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).createSodPolicy(requestParameters.sodPolicy, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This deletes a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Delete SOD policy by ID
     * @param {SODPoliciesApiDeleteSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.deleteSodPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).deleteSodPolicy(requestParameters.id, requestParameters.logical, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This deletes schedule for a specified SOD policy by ID.
     * @summary Delete SOD policy schedule
     * @param {SODPoliciesApiDeleteSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.deleteSodPolicySchedule = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).deleteSodPolicySchedule(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This allows to download a specified named violation report for a given report reference.
     * @summary Download custom violation report
     * @param {SODPoliciesApiGetCustomViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.getCustomViolationReport = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).getCustomViolationReport(requestParameters.reportResultId, requestParameters.fileName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This allows to download a violation report for a given report reference.
     * @summary Download violation report
     * @param {SODPoliciesApiGetDefaultViolationReportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.getDefaultViolationReport = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).getDefaultViolationReport(requestParameters.reportResultId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint gets the status for a violation report for all policy run.
     * @summary Get multi-report run task status
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.getSodAllReportRunStatus = function (axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).getSodAllReportRunStatus(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Get SOD policy by ID
     * @param {SODPoliciesApiGetSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.getSodPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).getSodPolicy(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint gets a specified SOD policy\'s schedule.
     * @summary Get SOD policy schedule
     * @param {SODPoliciesApiGetSodPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.getSodPolicySchedule = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).getSodPolicySchedule(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets the status for a violation report run task that has already been invoked.
     * @summary Get violation report run status
     * @param {SODPoliciesApiGetSodViolationReportRunStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.getSodViolationReportRunStatus = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).getSodViolationReportRunStatus(requestParameters.reportResultId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets the status for a violation report run task that has already been invoked.
     * @summary Get SOD violation report status
     * @param {SODPoliciesApiGetSodViolationReportStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.getSodViolationReportStatus = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).getSodViolationReportStatus(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets list of all SOD policies. Requires role of ORG_ADMIN
     * @summary List SOD policies
     * @param {SODPoliciesApiListSodPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.listSodPolicies = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.SODPoliciesApiFp)(this.configuration).listSodPolicies(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Allows updating SOD Policy fields other than [\"id\",\"created\",\"creatorId\",\"policyQuery\",\"type\"] using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Requires role of ORG_ADMIN. This endpoint can only patch CONFLICTING_ACCESS_BASED type policies. Do not use this endpoint to patch general policies - doing so will build an API exception.
     * @summary Patch SOD policy by ID
     * @param {SODPoliciesApiPatchSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.patchSodPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).patchSodPolicy(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This updates schedule for a specified SOD policy.
     * @summary Update SOD Policy schedule
     * @param {SODPoliciesApiPutPolicyScheduleRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.putPolicySchedule = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).putPolicySchedule(requestParameters.id, requestParameters.sodPolicySchedule, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This updates a specified SOD policy. Requires role of ORG_ADMIN.
     * @summary Update SOD policy by ID
     * @param {SODPoliciesApiPutSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.putSodPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).putSodPolicy(requestParameters.id, requestParameters.sodPolicy, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Runs the scheduled report for the policy retrieved by passed policy ID.  The report schedule is fetched from the policy retrieved by ID.
     * @summary Evaluate one policy by ID
     * @param {SODPoliciesApiStartEvaluateSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.startEvaluateSodPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).startEvaluateSodPolicy(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Runs multi-policy report for the org. If a policy reports more than 5000 violations, the report mentions that the violation limit was exceeded for that policy. If the request is empty, the report runs for all policies. Otherwise, the report runs for only the filtered policy list provided.
     * @summary Runs all policies for org
     * @param {SODPoliciesApiStartSodAllPoliciesForOrgRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.startSodAllPoliciesForOrg = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.SODPoliciesApiFp)(this.configuration).startSodAllPoliciesForOrg(requestParameters.multiPolicyRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This invokes processing of violation report for given SOD policy. If the policy reports more than 5000 violations, the report returns with violation limit exceeded message.
     * @summary Runs SOD policy violation report
     * @param {SODPoliciesApiStartSodPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODPoliciesApi
     */
    SODPoliciesApi.prototype.startSodPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODPoliciesApiFp)(this.configuration).startSodPolicy(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SODPoliciesApi;
}(base_1.BaseAPI));
exports.SODPoliciesApi = SODPoliciesApi;
/**
 * SODViolationsApi - axios parameter creator
 * @export
 */
var SODViolationsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startPredictSodViolations: function (identityWithNewAccess, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityWithNewAccess' is not null or undefined
                            (0, common_1.assertParamExists)('startPredictSodViolations', 'identityWithNewAccess', identityWithNewAccess);
                            localVarPath = "/sod-violations/predict";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(identityWithNewAccess, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startViolationCheck: function (identityWithNewAccess1, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'identityWithNewAccess1' is not null or undefined
                            (0, common_1.assertParamExists)('startViolationCheck', 'identityWithNewAccess1', identityWithNewAccess1);
                            localVarPath = "/sod-violations/check";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(identityWithNewAccess1, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SODViolationsApiAxiosParamCreator = SODViolationsApiAxiosParamCreator;
/**
 * SODViolationsApi - functional programming interface
 * @export
 */
var SODViolationsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SODViolationsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startPredictSodViolations: function (identityWithNewAccess, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startPredictSodViolations(identityWithNewAccess, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startViolationCheck: function (identityWithNewAccess1, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startViolationCheck(identityWithNewAccess1, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SODViolationsApiFp = SODViolationsApiFp;
/**
 * SODViolationsApi - factory interface
 * @export
 */
var SODViolationsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SODViolationsApiFp)(configuration);
    return {
        /**
         * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Predict SOD violations for identity.
         * @param {IdentityWithNewAccess} identityWithNewAccess
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startPredictSodViolations: function (identityWithNewAccess, axiosOptions) {
            return localVarFp.startPredictSodViolations(identityWithNewAccess, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Check SOD violations
         * @param {IdentityWithNewAccess1} identityWithNewAccess1
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startViolationCheck: function (identityWithNewAccess1, axiosOptions) {
            return localVarFp.startViolationCheck(identityWithNewAccess1, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SODViolationsApiFactory = SODViolationsApiFactory;
/**
 * SODViolationsApi - object-oriented interface
 * @export
 * @class SODViolationsApi
 * @extends {BaseAPI}
 */
var SODViolationsApi = /** @class */ (function (_super) {
    __extends(SODViolationsApi, _super);
    function SODViolationsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API is used to check if granting some additional accesses would cause the subject to be in violation of any SOD policies. Returns the violations that would be caused.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Predict SOD violations for identity.
     * @param {SODViolationsApiStartPredictSodViolationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsApi
     */
    SODViolationsApi.prototype.startPredictSodViolations = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODViolationsApiFp)(this.configuration).startPredictSodViolations(requestParameters.identityWithNewAccess, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API initiates a SOD policy verification asynchronously.  A token with ORG_ADMIN authority is required to call this API.
     * @summary Check SOD violations
     * @param {SODViolationsApiStartViolationCheckRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SODViolationsApi
     */
    SODViolationsApi.prototype.startViolationCheck = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SODViolationsApiFp)(this.configuration).startViolationCheck(requestParameters.identityWithNewAccess1, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SODViolationsApi;
}(base_1.BaseAPI));
exports.SODViolationsApi = SODViolationsApi;
/**
 * SavedSearchApi - axios parameter creator
 * @export
 */
var SavedSearchApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Creates a new saved search.
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch: function (createSavedSearchRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'createSavedSearchRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createSavedSearch', 'createSavedSearchRequest', createSavedSearchRequest);
                            localVarPath = "/saved-searches";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createSavedSearchRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Deletes the specified saved search.
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteSavedSearch', 'id', id);
                            localVarPath = "/saved-searches/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Executes the specified saved search.
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        executeSavedSearch: function (id, searchArguments, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('executeSavedSearch', 'id', id);
                            // verify required parameter 'searchArguments' is not null or undefined
                            (0, common_1.assertParamExists)('executeSavedSearch', 'searchArguments', searchArguments);
                            localVarPath = "/saved-searches/{id}/execute"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(searchArguments, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns the specified saved search.
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearch: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getSavedSearch', 'id', id);
                            localVarPath = "/saved-searches/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns a list of saved searches.
         * @summary A list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearches: function (offset, limit, count, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/saved-searches";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.**
         * @summary Updates an existing saved search
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSavedSearch: function (id, savedSearch, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('putSavedSearch', 'id', id);
                            // verify required parameter 'savedSearch' is not null or undefined
                            (0, common_1.assertParamExists)('putSavedSearch', 'savedSearch', savedSearch);
                            localVarPath = "/saved-searches/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(savedSearch, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SavedSearchApiAxiosParamCreator = SavedSearchApiAxiosParamCreator;
/**
 * SavedSearchApi - functional programming interface
 * @export
 */
var SavedSearchApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SavedSearchApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a new saved search.
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch: function (createSavedSearchRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createSavedSearch(createSavedSearchRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes the specified saved search.
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteSavedSearch(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Executes the specified saved search.
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        executeSavedSearch: function (id, searchArguments, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.executeSavedSearch(id, searchArguments, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns the specified saved search.
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearch: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSavedSearch(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of saved searches.
         * @summary A list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearches: function (offset, limit, count, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listSavedSearches(offset, limit, count, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.**
         * @summary Updates an existing saved search
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSavedSearch: function (id, savedSearch, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putSavedSearch(id, savedSearch, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SavedSearchApiFp = SavedSearchApiFp;
/**
 * SavedSearchApi - factory interface
 * @export
 */
var SavedSearchApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SavedSearchApiFp)(configuration);
    return {
        /**
         * Creates a new saved search.
         * @summary Create a saved search
         * @param {CreateSavedSearchRequest} createSavedSearchRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch: function (createSavedSearchRequest, axiosOptions) {
            return localVarFp.createSavedSearch(createSavedSearchRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes the specified saved search.
         * @summary Delete document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch: function (id, axiosOptions) {
            return localVarFp.deleteSavedSearch(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Executes the specified saved search.
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        executeSavedSearch: function (id, searchArguments, axiosOptions) {
            return localVarFp.executeSavedSearch(id, searchArguments, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns the specified saved search.
         * @summary Return saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearch: function (id, axiosOptions) {
            return localVarFp.getSavedSearch(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of saved searches.
         * @summary A list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearches: function (offset, limit, count, filters, axiosOptions) {
            return localVarFp.listSavedSearches(offset, limit, count, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.**
         * @summary Updates an existing saved search
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSavedSearch: function (id, savedSearch, axiosOptions) {
            return localVarFp.putSavedSearch(id, savedSearch, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SavedSearchApiFactory = SavedSearchApiFactory;
/**
 * SavedSearchApi - object-oriented interface
 * @export
 * @class SavedSearchApi
 * @extends {BaseAPI}
 */
var SavedSearchApi = /** @class */ (function (_super) {
    __extends(SavedSearchApi, _super);
    function SavedSearchApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a new saved search.
     * @summary Create a saved search
     * @param {SavedSearchApiCreateSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    SavedSearchApi.prototype.createSavedSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SavedSearchApiFp)(this.configuration).createSavedSearch(requestParameters.createSavedSearchRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes the specified saved search.
     * @summary Delete document by ID
     * @param {SavedSearchApiDeleteSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    SavedSearchApi.prototype.deleteSavedSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SavedSearchApiFp)(this.configuration).deleteSavedSearch(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Executes the specified saved search.
     * @summary Execute a saved search by ID
     * @param {SavedSearchApiExecuteSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    SavedSearchApi.prototype.executeSavedSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SavedSearchApiFp)(this.configuration).executeSavedSearch(requestParameters.id, requestParameters.searchArguments, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns the specified saved search.
     * @summary Return saved search by ID
     * @param {SavedSearchApiGetSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    SavedSearchApi.prototype.getSavedSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SavedSearchApiFp)(this.configuration).getSavedSearch(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of saved searches.
     * @summary A list of Saved Searches
     * @param {SavedSearchApiListSavedSearchesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    SavedSearchApi.prototype.listSavedSearches = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.SavedSearchApiFp)(this.configuration).listSavedSearches(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Updates an existing saved search.   >**NOTE: You cannot update the `owner` of the saved search.**
     * @summary Updates an existing saved search
     * @param {SavedSearchApiPutSavedSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    SavedSearchApi.prototype.putSavedSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SavedSearchApiFp)(this.configuration).putSavedSearch(requestParameters.id, requestParameters.savedSearch, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SavedSearchApi;
}(base_1.BaseAPI));
exports.SavedSearchApi = SavedSearchApi;
/**
 * ScheduledSearchApi - axios parameter creator
 * @export
 */
var ScheduledSearchApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Creates a new scheduled search.
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledSearch: function (createScheduledSearchRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'createScheduledSearchRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createScheduledSearch', 'createScheduledSearchRequest', createScheduledSearchRequest);
                            localVarPath = "/scheduled-searches";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createScheduledSearchRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Deletes the specified scheduled search.
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledSearch: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteScheduledSearch', 'id', id);
                            localVarPath = "/scheduled-searches/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledSearch: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getScheduledSearch', 'id', id);
                            localVarPath = "/scheduled-searches/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns a list of scheduled searches.
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledSearch: function (offset, limit, count, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/scheduled-searches";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search.
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeScheduledSearch: function (id, typedReference, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('unsubscribeScheduledSearch', 'id', id);
                            // verify required parameter 'typedReference' is not null or undefined
                            (0, common_1.assertParamExists)('unsubscribeScheduledSearch', 'typedReference', typedReference);
                            localVarPath = "/scheduled-searches/{id}/unsubscribe"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(typedReference, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Updates an existing scheduled search.
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledSearch: function (id, scheduledSearch, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('updateScheduledSearch', 'id', id);
                            // verify required parameter 'scheduledSearch' is not null or undefined
                            (0, common_1.assertParamExists)('updateScheduledSearch', 'scheduledSearch', scheduledSearch);
                            localVarPath = "/scheduled-searches/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(scheduledSearch, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ScheduledSearchApiAxiosParamCreator = ScheduledSearchApiAxiosParamCreator;
/**
 * ScheduledSearchApi - functional programming interface
 * @export
 */
var ScheduledSearchApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ScheduledSearchApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a new scheduled search.
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledSearch: function (createScheduledSearchRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createScheduledSearch(createScheduledSearchRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes the specified scheduled search.
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledSearch: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteScheduledSearch(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledSearch: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getScheduledSearch(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns a list of scheduled searches.
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledSearch: function (offset, limit, count, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listScheduledSearch(offset, limit, count, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search.
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeScheduledSearch: function (id, typedReference, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unsubscribeScheduledSearch(id, typedReference, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Updates an existing scheduled search.
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledSearch: function (id, scheduledSearch, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateScheduledSearch(id, scheduledSearch, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ScheduledSearchApiFp = ScheduledSearchApiFp;
/**
 * ScheduledSearchApi - factory interface
 * @export
 */
var ScheduledSearchApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ScheduledSearchApiFp)(configuration);
    return {
        /**
         * Creates a new scheduled search.
         * @summary Create a new scheduled search
         * @param {CreateScheduledSearchRequest} createScheduledSearchRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledSearch: function (createScheduledSearchRequest, axiosOptions) {
            return localVarFp.createScheduledSearch(createScheduledSearchRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes the specified scheduled search.
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledSearch: function (id, axiosOptions) {
            return localVarFp.deleteScheduledSearch(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getScheduledSearch: function (id, axiosOptions) {
            return localVarFp.getScheduledSearch(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a list of scheduled searches.
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **owner.id**: *eq*  **savedSearchId**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledSearch: function (offset, limit, count, filters, axiosOptions) {
            return localVarFp.listScheduledSearch(offset, limit, count, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search.
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeScheduledSearch: function (id, typedReference, axiosOptions) {
            return localVarFp.unsubscribeScheduledSearch(id, typedReference, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates an existing scheduled search.
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledSearch: function (id, scheduledSearch, axiosOptions) {
            return localVarFp.updateScheduledSearch(id, scheduledSearch, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ScheduledSearchApiFactory = ScheduledSearchApiFactory;
/**
 * ScheduledSearchApi - object-oriented interface
 * @export
 * @class ScheduledSearchApi
 * @extends {BaseAPI}
 */
var ScheduledSearchApi = /** @class */ (function (_super) {
    __extends(ScheduledSearchApi, _super);
    function ScheduledSearchApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a new scheduled search.
     * @summary Create a new scheduled search
     * @param {ScheduledSearchApiCreateScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    ScheduledSearchApi.prototype.createScheduledSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ScheduledSearchApiFp)(this.configuration).createScheduledSearch(requestParameters.createScheduledSearchRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes the specified scheduled search.
     * @summary Delete a Scheduled Search
     * @param {ScheduledSearchApiDeleteScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    ScheduledSearchApi.prototype.deleteScheduledSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ScheduledSearchApiFp)(this.configuration).deleteScheduledSearch(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns the specified scheduled search.
     * @summary Get a Scheduled Search
     * @param {ScheduledSearchApiGetScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    ScheduledSearchApi.prototype.getScheduledSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ScheduledSearchApiFp)(this.configuration).getScheduledSearch(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns a list of scheduled searches.
     * @summary List scheduled searches
     * @param {ScheduledSearchApiListScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    ScheduledSearchApi.prototype.listScheduledSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.ScheduledSearchApiFp)(this.configuration).listScheduledSearch(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Unsubscribes a recipient from the specified scheduled search.
     * @summary Unsubscribe a recipient from Scheduled Search
     * @param {ScheduledSearchApiUnsubscribeScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    ScheduledSearchApi.prototype.unsubscribeScheduledSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ScheduledSearchApiFp)(this.configuration).unsubscribeScheduledSearch(requestParameters.id, requestParameters.typedReference, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Updates an existing scheduled search.
     * @summary Update an existing Scheduled Search
     * @param {ScheduledSearchApiUpdateScheduledSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    ScheduledSearchApi.prototype.updateScheduledSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ScheduledSearchApiFp)(this.configuration).updateScheduledSearch(requestParameters.id, requestParameters.scheduledSearch, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ScheduledSearchApi;
}(base_1.BaseAPI));
exports.ScheduledSearchApi = ScheduledSearchApi;
/**
 * SearchApi - axios parameter creator
 * @export
 */
var SearchApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging.
         * @summary Perform a Search Query Aggregation
         * @param {Search} search
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate: function (search, offset, limit, count, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'search' is not null or undefined
                            (0, common_1.assertParamExists)('searchAggregate', 'search', search);
                            localVarPath = "/search/aggregate";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(search, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount: function (search, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'search' is not null or undefined
                            (0, common_1.assertParamExists)('searchCount', 'search', search);
                            localVarPath = "/search/count";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(search, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*.
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet: function (index, id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'index' is not null or undefined
                            (0, common_1.assertParamExists)('searchGet', 'index', index);
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('searchGet', 'id', id);
                            localVarPath = "/search/{index}/{id}"
                                .replace("{".concat("index", "}"), encodeURIComponent(String(index)))
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging.
         * @summary Perform Search
         * @param {Search} search
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost: function (search, offset, limit, count, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'search' is not null or undefined
                            (0, common_1.assertParamExists)('searchPost', 'search', search);
                            localVarPath = "/search";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(search, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SearchApiAxiosParamCreator = SearchApiAxiosParamCreator;
/**
 * SearchApi - functional programming interface
 * @export
 */
var SearchApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SearchApiAxiosParamCreator)(configuration);
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging.
         * @summary Perform a Search Query Aggregation
         * @param {Search} search
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate: function (search, offset, limit, count, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.searchAggregate(search, offset, limit, count, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount: function (search, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.searchCount(search, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*.
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet: function (index, id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.searchGet(index, id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging.
         * @summary Perform Search
         * @param {Search} search
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost: function (search, offset, limit, count, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.searchPost(search, offset, limit, count, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SearchApiFp = SearchApiFp;
/**
 * SearchApi - factory interface
 * @export
 */
var SearchApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SearchApiFp)(configuration);
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging.
         * @summary Perform a Search Query Aggregation
         * @param {Search} search
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate: function (search, offset, limit, count, axiosOptions) {
            return localVarFp.searchAggregate(search, offset, limit, count, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount: function (search, axiosOptions) {
            return localVarFp.searchCount(search, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *entitlements*, *events*, *identities*, and *roles*.
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet: function (index, id, axiosOptions) {
            return localVarFp.searchGet(index, id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging.
         * @summary Perform Search
         * @param {Search} search
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost: function (search, offset, limit, count, axiosOptions) {
            return localVarFp.searchPost(search, offset, limit, count, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SearchApiFactory = SearchApiFactory;
/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
var SearchApi = /** @class */ (function (_super) {
    __extends(SearchApi, _super);
    function SearchApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging.
     * @summary Perform a Search Query Aggregation
     * @param {SearchApiSearchAggregateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    SearchApi.prototype.searchAggregate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SearchApiFp)(this.configuration).searchAggregate(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
     * @summary Count Documents Satisfying a Query
     * @param {SearchApiSearchCountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    SearchApi.prototype.searchCount = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SearchApiFp)(this.configuration).searchCount(requestParameters.search, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Fetches a single document from the specified index, using the specified document ID.
     * @summary Get a Document by ID
     * @param {SearchApiSearchGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    SearchApi.prototype.searchGet = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SearchApiFp)(this.configuration).searchGet(requestParameters.index, requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging.
     * @summary Perform Search
     * @param {SearchApiSearchPostRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    SearchApi.prototype.searchPost = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SearchApiFp)(this.configuration).searchPost(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SearchApi;
}(base_1.BaseAPI));
exports.SearchApi = SearchApi;
/**
 * SearchAttributeConfigurationApi - axios parameter creator
 * @export
 */
var SearchAttributeConfigurationApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names.  It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configure/create search attributes in IdentityNow.
         * @param {SearchAttributeConfig} searchAttributeConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSearchAttributeConfig: function (searchAttributeConfig, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'searchAttributeConfig' is not null or undefined
                            (0, common_1.assertParamExists)('createSearchAttributeConfig', 'searchAttributeConfig', searchAttributeConfig);
                            localVarPath = "/accounts/search-attribute-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(searchAttributeConfig, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API accepts an extended search attribute name and deletes the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete search attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearchAttributeConfig: function (name, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'name' is not null or undefined
                            (0, common_1.assertParamExists)('deleteSearchAttributeConfig', 'name', name);
                            localVarPath = "/accounts/search-attribute-config/{name}"
                                .replace("{".concat("name", "}"), encodeURIComponent(String(name)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API retrieves a list of extended search attribute/application associates currently configured in IdentityNow. A token with ORG_ADMIN authority is required to call this API.
         * @summary Retrieve attribute list in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAttributeConfig: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/accounts/search-attribute-config";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API accepts an extended search attribute name and retrieves the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get specific attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSearchAttributeConfig: function (name, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'name' is not null or undefined
                            (0, common_1.assertParamExists)('getSingleSearchAttributeConfig', 'name', name);
                            localVarPath = "/accounts/search-attribute-config/{name}"
                                .replace("{".concat("name", "}"), encodeURIComponent(String(name)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API updates an existing Search Attribute Configuration. The following fields are patchable: **name**, **displayName**, **applicationAttributes** A token with ORG_ADMIN authority is required to call this API.
         * @summary Update search attribute in IdentityNow.
         * @param {string} name Name of the Search Attribute Configuration to patch.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSearchAttributeConfig: function (name, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'name' is not null or undefined
                            (0, common_1.assertParamExists)('patchSearchAttributeConfig', 'name', name);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchSearchAttributeConfig', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/accounts/search-attribute-config/{name}"
                                .replace("{".concat("name", "}"), encodeURIComponent(String(name)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SearchAttributeConfigurationApiAxiosParamCreator = SearchAttributeConfigurationApiAxiosParamCreator;
/**
 * SearchAttributeConfigurationApi - functional programming interface
 * @export
 */
var SearchAttributeConfigurationApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SearchAttributeConfigurationApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names.  It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configure/create search attributes in IdentityNow.
         * @param {SearchAttributeConfig} searchAttributeConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSearchAttributeConfig: function (searchAttributeConfig, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createSearchAttributeConfig(searchAttributeConfig, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API accepts an extended search attribute name and deletes the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete search attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearchAttributeConfig: function (name, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteSearchAttributeConfig(name, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API retrieves a list of extended search attribute/application associates currently configured in IdentityNow. A token with ORG_ADMIN authority is required to call this API.
         * @summary Retrieve attribute list in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAttributeConfig: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSearchAttributeConfig(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API accepts an extended search attribute name and retrieves the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get specific attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSearchAttributeConfig: function (name, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSingleSearchAttributeConfig(name, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API updates an existing Search Attribute Configuration. The following fields are patchable: **name**, **displayName**, **applicationAttributes** A token with ORG_ADMIN authority is required to call this API.
         * @summary Update search attribute in IdentityNow.
         * @param {string} name Name of the Search Attribute Configuration to patch.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSearchAttributeConfig: function (name, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchSearchAttributeConfig(name, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SearchAttributeConfigurationApiFp = SearchAttributeConfigurationApiFp;
/**
 * SearchAttributeConfigurationApi - factory interface
 * @export
 */
var SearchAttributeConfigurationApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SearchAttributeConfigurationApiFp)(configuration);
    return {
        /**
         * This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names.  It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig. A token with ORG_ADMIN authority is required to call this API.
         * @summary Configure/create search attributes in IdentityNow.
         * @param {SearchAttributeConfig} searchAttributeConfig
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSearchAttributeConfig: function (searchAttributeConfig, axiosOptions) {
            return localVarFp.createSearchAttributeConfig(searchAttributeConfig, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API accepts an extended search attribute name and deletes the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete search attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearchAttributeConfig: function (name, axiosOptions) {
            return localVarFp.deleteSearchAttributeConfig(name, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API retrieves a list of extended search attribute/application associates currently configured in IdentityNow. A token with ORG_ADMIN authority is required to call this API.
         * @summary Retrieve attribute list in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAttributeConfig: function (axiosOptions) {
            return localVarFp.getSearchAttributeConfig(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API accepts an extended search attribute name and retrieves the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Get specific attribute in IdentityNow.
         * @param {string} name Name of the extended search attribute configuration to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSearchAttributeConfig: function (name, axiosOptions) {
            return localVarFp.getSingleSearchAttributeConfig(name, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API updates an existing Search Attribute Configuration. The following fields are patchable: **name**, **displayName**, **applicationAttributes** A token with ORG_ADMIN authority is required to call this API.
         * @summary Update search attribute in IdentityNow.
         * @param {string} name Name of the Search Attribute Configuration to patch.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSearchAttributeConfig: function (name, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchSearchAttributeConfig(name, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SearchAttributeConfigurationApiFactory = SearchAttributeConfigurationApiFactory;
/**
 * SearchAttributeConfigurationApi - object-oriented interface
 * @export
 * @class SearchAttributeConfigurationApi
 * @extends {BaseAPI}
 */
var SearchAttributeConfigurationApi = /** @class */ (function (_super) {
    __extends(SearchAttributeConfigurationApi, _super);
    function SearchAttributeConfigurationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API accepts an attribute name, an attribute display name and a list of name/value pair associates of application IDs to attribute names.  It will then validate the inputs and configure/create and attribute promotion configuration in the Link ObjectConfig. A token with ORG_ADMIN authority is required to call this API.
     * @summary Configure/create search attributes in IdentityNow.
     * @param {SearchAttributeConfigurationApiCreateSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationApi
     */
    SearchAttributeConfigurationApi.prototype.createSearchAttributeConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SearchAttributeConfigurationApiFp)(this.configuration).createSearchAttributeConfig(requestParameters.searchAttributeConfig, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API accepts an extended search attribute name and deletes the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete search attribute in IdentityNow.
     * @param {SearchAttributeConfigurationApiDeleteSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationApi
     */
    SearchAttributeConfigurationApi.prototype.deleteSearchAttributeConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SearchAttributeConfigurationApiFp)(this.configuration).deleteSearchAttributeConfig(requestParameters.name, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API retrieves a list of extended search attribute/application associates currently configured in IdentityNow. A token with ORG_ADMIN authority is required to call this API.
     * @summary Retrieve attribute list in IdentityNow.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationApi
     */
    SearchAttributeConfigurationApi.prototype.getSearchAttributeConfig = function (axiosOptions) {
        var _this = this;
        return (0, exports.SearchAttributeConfigurationApiFp)(this.configuration).getSearchAttributeConfig(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API accepts an extended search attribute name and retrieves the corresponding extended attribute configuration. A token with ORG_ADMIN authority is required to call this API.
     * @summary Get specific attribute in IdentityNow.
     * @param {SearchAttributeConfigurationApiGetSingleSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationApi
     */
    SearchAttributeConfigurationApi.prototype.getSingleSearchAttributeConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SearchAttributeConfigurationApiFp)(this.configuration).getSingleSearchAttributeConfig(requestParameters.name, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API updates an existing Search Attribute Configuration. The following fields are patchable: **name**, **displayName**, **applicationAttributes** A token with ORG_ADMIN authority is required to call this API.
     * @summary Update search attribute in IdentityNow.
     * @param {SearchAttributeConfigurationApiPatchSearchAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchAttributeConfigurationApi
     */
    SearchAttributeConfigurationApi.prototype.patchSearchAttributeConfig = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SearchAttributeConfigurationApiFp)(this.configuration).patchSearchAttributeConfig(requestParameters.name, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SearchAttributeConfigurationApi;
}(base_1.BaseAPI));
exports.SearchAttributeConfigurationApi = SearchAttributeConfigurationApi;
/**
 * SegmentsApi - axios parameter creator
 * @export
 */
var SegmentsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment: function (segment, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'segment' is not null or undefined
                            (0, common_1.assertParamExists)('createSegment', 'segment', segment);
                            localVarPath = "/segments";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(segment, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The segment ID to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteSegment', 'id', id);
                            localVarPath = "/segments/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Segment by ID
         * @param {string} id The segment ID to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getSegment', 'id', id);
                            localVarPath = "/segments/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments: function (limit, offset, count, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/segments";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Segment
         * @param {string} id The segment ID to modify.
         * @param {Array<object>} requestBody A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment: function (id, requestBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchSegment', 'id', id);
                            // verify required parameter 'requestBody' is not null or undefined
                            (0, common_1.assertParamExists)('patchSegment', 'requestBody', requestBody);
                            localVarPath = "/segments/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(requestBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SegmentsApiAxiosParamCreator = SegmentsApiAxiosParamCreator;
/**
 * SegmentsApi - functional programming interface
 * @export
 */
var SegmentsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SegmentsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment: function (segment, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createSegment(segment, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The segment ID to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteSegment(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Segment by ID
         * @param {string} id The segment ID to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSegment(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments: function (limit, offset, count, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listSegments(limit, offset, count, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Segment
         * @param {string} id The segment ID to modify.
         * @param {Array<object>} requestBody A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment: function (id, requestBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchSegment(id, requestBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SegmentsApiFp = SegmentsApiFp;
/**
 * SegmentsApi - factory interface
 * @export
 */
var SegmentsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SegmentsApiFp)(configuration);
    return {
        /**
         * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Segment
         * @param {Segment} segment
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSegment: function (segment, axiosOptions) {
            return localVarFp.createSegment(segment, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Delete Segment by ID
         * @param {string} id The segment ID to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSegment: function (id, axiosOptions) {
            return localVarFp.deleteSegment(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get Segment by ID
         * @param {string} id The segment ID to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: function (id, axiosOptions) {
            return localVarFp.getSegment(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
         * @summary List Segments
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSegments: function (limit, offset, count, axiosOptions) {
            return localVarFp.listSegments(limit, offset, count, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Segment
         * @param {string} id The segment ID to modify.
         * @param {Array<object>} requestBody A list of segment update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * description * owner * visibilityCriteria * active
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSegment: function (id, requestBody, axiosOptions) {
            return localVarFp.patchSegment(id, requestBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SegmentsApiFactory = SegmentsApiFactory;
/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
var SegmentsApi = /** @class */ (function (_super) {
    __extends(SegmentsApi, _super);
    function SegmentsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API creates a segment.  >**Note:** Segment definitions may take time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Create Segment
     * @param {SegmentsApiCreateSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    SegmentsApi.prototype.createSegment = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SegmentsApiFp)(this.configuration).createSegment(requestParameters.segment, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API deletes the segment specified by the given ID. >**Note:** that segment deletion may take some time to become effective. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Delete Segment by ID
     * @param {SegmentsApiDeleteSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    SegmentsApi.prototype.deleteSegment = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SegmentsApiFp)(this.configuration).deleteSegment(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the segment specified by the given ID. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get Segment by ID
     * @param {SegmentsApiGetSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    SegmentsApi.prototype.getSegment = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SegmentsApiFp)(this.configuration).getSegment(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a list of all segments.  A token with ORG_ADMIN or API authority is required to call this API.
     * @summary List Segments
     * @param {SegmentsApiListSegmentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    SegmentsApi.prototype.listSegments = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.SegmentsApiFp)(this.configuration).listSegments(requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to update segment fields by using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. >**Note:** Changes to a segment may take some time to propagate to all identities. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Update Segment
     * @param {SegmentsApiPatchSegmentRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    SegmentsApi.prototype.patchSegment = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SegmentsApiFp)(this.configuration).patchSegment(requestParameters.id, requestParameters.requestBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SegmentsApi;
}(base_1.BaseAPI));
exports.SegmentsApi = SegmentsApi;
/**
 * ServiceDeskIntegrationApi - axios parameter creator
 * @export
 */
var ServiceDeskIntegrationApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration: function (serviceDeskIntegrationDto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
                            (0, common_1.assertParamExists)('createServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto);
                            localVarPath = "/service-desk-integrations";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(serviceDeskIntegrationDto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteServiceDeskIntegration', 'id', id);
                            localVarPath = "/service-desk-integrations/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getServiceDeskIntegration', 'id', id);
                            localVarPath = "/service-desk-integrations/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate: function (scriptName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'scriptName' is not null or undefined
                            (0, common_1.assertParamExists)('getServiceDeskIntegrationTemplate', 'scriptName', scriptName);
                            localVarPath = "/service-desk-integrations/templates/{scriptName}"
                                .replace("{".concat("scriptName", "}"), encodeURIComponent(String(scriptName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/service-desk-integrations/types";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrations: function (offset, limit, sorters, filters, count, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/service-desk-integrations";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/service-desk-integrations/status-check-configuration";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {PatchServiceDeskIntegrationRequest} patchServiceDeskIntegrationRequest A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Only &#x60;replace&#x60; operations are accepted by this endpoint.  A 403 Forbidden Error indicates that you attempted to PATCH a operation that is not allowed.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration: function (id, patchServiceDeskIntegrationRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchServiceDeskIntegration', 'id', id);
                            // verify required parameter 'patchServiceDeskIntegrationRequest' is not null or undefined
                            (0, common_1.assertParamExists)('patchServiceDeskIntegration', 'patchServiceDeskIntegrationRequest', patchServiceDeskIntegrationRequest);
                            localVarPath = "/service-desk-integrations/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(patchServiceDeskIntegrationRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration: function (id, serviceDeskIntegrationDto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('putServiceDeskIntegration', 'id', id);
                            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
                            (0, common_1.assertParamExists)('putServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto);
                            localVarPath = "/service-desk-integrations/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(serviceDeskIntegrationDto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails: function (queuedCheckConfigDetails, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'queuedCheckConfigDetails' is not null or undefined
                            (0, common_1.assertParamExists)('updateStatusCheckDetails', 'queuedCheckConfigDetails', queuedCheckConfigDetails);
                            localVarPath = "/service-desk-integrations/status-check-configuration";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(queuedCheckConfigDetails, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ServiceDeskIntegrationApiAxiosParamCreator = ServiceDeskIntegrationApiAxiosParamCreator;
/**
 * ServiceDeskIntegrationApi - functional programming interface
 * @export
 */
var ServiceDeskIntegrationApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ServiceDeskIntegrationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration: function (serviceDeskIntegrationDto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createServiceDeskIntegration(serviceDeskIntegrationDto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteServiceDeskIntegration(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getServiceDeskIntegration(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate: function (scriptName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getServiceDeskIntegrationTemplate(scriptName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getServiceDeskIntegrationTypes(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrations: function (offset, limit, sorters, filters, count, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getServiceDeskIntegrations(offset, limit, sorters, filters, count, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getStatusCheckDetails(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {PatchServiceDeskIntegrationRequest} patchServiceDeskIntegrationRequest A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Only &#x60;replace&#x60; operations are accepted by this endpoint.  A 403 Forbidden Error indicates that you attempted to PATCH a operation that is not allowed.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration: function (id, patchServiceDeskIntegrationRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchServiceDeskIntegration(id, patchServiceDeskIntegrationRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration: function (id, serviceDeskIntegrationDto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putServiceDeskIntegration(id, serviceDeskIntegrationDto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails: function (queuedCheckConfigDetails, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateStatusCheckDetails(queuedCheckConfigDetails, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ServiceDeskIntegrationApiFp = ServiceDeskIntegrationApiFp;
/**
 * ServiceDeskIntegrationApi - factory interface
 * @export
 */
var ServiceDeskIntegrationApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ServiceDeskIntegrationApiFp)(configuration);
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration: function (serviceDeskIntegrationDto, axiosOptions) {
            return localVarFp.createServiceDeskIntegration(serviceDeskIntegrationDto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration: function (id, axiosOptions) {
            return localVarFp.deleteServiceDeskIntegration(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration: function (id, axiosOptions) {
            return localVarFp.getServiceDeskIntegration(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate: function (scriptName, axiosOptions) {
            return localVarFp.getServiceDeskIntegrationTemplate(scriptName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes: function (axiosOptions) {
            return localVarFp.getServiceDeskIntegrationTypes(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrations: function (offset, limit, sorters, filters, count, axiosOptions) {
            return localVarFp.getServiceDeskIntegrations(offset, limit, sorters, filters, count, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails: function (axiosOptions) {
            return localVarFp.getStatusCheckDetails(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {PatchServiceDeskIntegrationRequest} patchServiceDeskIntegrationRequest A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Only &#x60;replace&#x60; operations are accepted by this endpoint.  A 403 Forbidden Error indicates that you attempted to PATCH a operation that is not allowed.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration: function (id, patchServiceDeskIntegrationRequest, axiosOptions) {
            return localVarFp.patchServiceDeskIntegration(id, patchServiceDeskIntegrationRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putServiceDeskIntegration: function (id, serviceDeskIntegrationDto, axiosOptions) {
            return localVarFp.putServiceDeskIntegration(id, serviceDeskIntegrationDto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails: function (queuedCheckConfigDetails, axiosOptions) {
            return localVarFp.updateStatusCheckDetails(queuedCheckConfigDetails, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ServiceDeskIntegrationApiFactory = ServiceDeskIntegrationApiFactory;
/**
 * ServiceDeskIntegrationApi - object-oriented interface
 * @export
 * @class ServiceDeskIntegrationApi
 * @extends {BaseAPI}
 */
var ServiceDeskIntegrationApi = /** @class */ (function (_super) {
    __extends(ServiceDeskIntegrationApi, _super);
    function ServiceDeskIntegrationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Create new Service Desk integration
     * @param {ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    ServiceDeskIntegrationApi.prototype.createServiceDeskIntegration = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ServiceDeskIntegrationApiFp)(this.configuration).createServiceDeskIntegration(requestParameters.serviceDeskIntegrationDto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Delete a Service Desk integration
     * @param {ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    ServiceDeskIntegrationApi.prototype.deleteServiceDeskIntegration = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ServiceDeskIntegrationApiFp)(this.configuration).deleteServiceDeskIntegration(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get a Service Desk integration
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    ServiceDeskIntegrationApi.prototype.getServiceDeskIntegration = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ServiceDeskIntegrationApiFp)(this.configuration).getServiceDeskIntegration(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk integration template by scriptName.
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    ServiceDeskIntegrationApi.prototype.getServiceDeskIntegrationTemplate = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ServiceDeskIntegrationApiFp)(this.configuration).getServiceDeskIntegrationTemplate(requestParameters.scriptName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk Integration Types List.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    ServiceDeskIntegrationApi.prototype.getServiceDeskIntegrationTypes = function (axiosOptions) {
        var _this = this;
        return (0, exports.ServiceDeskIntegrationApiFp)(this.configuration).getServiceDeskIntegrationTypes(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary List existing Service Desk Integrations
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    ServiceDeskIntegrationApi.prototype.getServiceDeskIntegrations = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.ServiceDeskIntegrationApiFp)(this.configuration).getServiceDeskIntegrations(requestParameters.offset, requestParameters.limit, requestParameters.sorters, requestParameters.filters, requestParameters.count, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get the time check configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    ServiceDeskIntegrationApi.prototype.getStatusCheckDetails = function (axiosOptions) {
        var _this = this;
        return (0, exports.ServiceDeskIntegrationApiFp)(this.configuration).getStatusCheckDetails(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update an existing ServiceDeskIntegration by ID with a PATCH request.
     * @summary Service Desk Integration Update PATCH
     * @param {ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    ServiceDeskIntegrationApi.prototype.patchServiceDeskIntegration = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ServiceDeskIntegrationApiFp)(this.configuration).patchServiceDeskIntegration(requestParameters.id, requestParameters.patchServiceDeskIntegrationRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update a Service Desk integration
     * @param {ServiceDeskIntegrationApiPutServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    ServiceDeskIntegrationApi.prototype.putServiceDeskIntegration = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ServiceDeskIntegrationApiFp)(this.configuration).putServiceDeskIntegration(requestParameters.id, requestParameters.serviceDeskIntegrationDto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update the time check configuration
     * @param {ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    ServiceDeskIntegrationApi.prototype.updateStatusCheckDetails = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ServiceDeskIntegrationApiFp)(this.configuration).updateStatusCheckDetails(requestParameters.queuedCheckConfigDetails, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ServiceDeskIntegrationApi;
}(base_1.BaseAPI));
exports.ServiceDeskIntegrationApi = ServiceDeskIntegrationApi;
/**
 * SourceUsagesApi - axios parameter creator
 * @export
 */
var SourceUsagesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {string} sourceId ID of IDN source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusBySourceId: function (sourceId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('getStatusBySourceId', 'sourceId', sourceId);
                            localVarPath = "/source-usages/{sourceId}/status"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {string} sourceId ID of IDN source
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesBySourceId: function (sourceId, limit, offset, count, sorters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('getUsagesBySourceId', 'sourceId', sourceId);
                            localVarPath = "/source-usages/{sourceId}/summaries"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SourceUsagesApiAxiosParamCreator = SourceUsagesApiAxiosParamCreator;
/**
 * SourceUsagesApi - functional programming interface
 * @export
 */
var SourceUsagesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SourceUsagesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {string} sourceId ID of IDN source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusBySourceId: function (sourceId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getStatusBySourceId(sourceId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {string} sourceId ID of IDN source
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesBySourceId: function (sourceId, limit, offset, count, sorters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUsagesBySourceId(sourceId, limit, offset, count, sorters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SourceUsagesApiFp = SourceUsagesApiFp;
/**
 * SourceUsagesApi - factory interface
 * @export
 */
var SourceUsagesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SourceUsagesApiFp)(configuration);
    return {
        /**
         * This API returns the status of the source usage insights setup by IDN source ID.
         * @summary Finds status of source usage
         * @param {string} sourceId ID of IDN source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusBySourceId: function (sourceId, axiosOptions) {
            return localVarFp.getStatusBySourceId(sourceId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a summary of source usage insights for past 12 months.
         * @summary Returns source usage insights
         * @param {string} sourceId ID of IDN source
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **date**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUsagesBySourceId: function (sourceId, limit, offset, count, sorters, axiosOptions) {
            return localVarFp.getUsagesBySourceId(sourceId, limit, offset, count, sorters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SourceUsagesApiFactory = SourceUsagesApiFactory;
/**
 * SourceUsagesApi - object-oriented interface
 * @export
 * @class SourceUsagesApi
 * @extends {BaseAPI}
 */
var SourceUsagesApi = /** @class */ (function (_super) {
    __extends(SourceUsagesApi, _super);
    function SourceUsagesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API returns the status of the source usage insights setup by IDN source ID.
     * @summary Finds status of source usage
     * @param {SourceUsagesApiGetStatusBySourceIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceUsagesApi
     */
    SourceUsagesApi.prototype.getStatusBySourceId = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourceUsagesApiFp)(this.configuration).getStatusBySourceId(requestParameters.sourceId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a summary of source usage insights for past 12 months.
     * @summary Returns source usage insights
     * @param {SourceUsagesApiGetUsagesBySourceIdRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceUsagesApi
     */
    SourceUsagesApi.prototype.getUsagesBySourceId = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourceUsagesApiFp)(this.configuration).getUsagesBySourceId(requestParameters.sourceId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SourceUsagesApi;
}(base_1.BaseAPI));
exports.SourceUsagesApi = SourceUsagesApi;
/**
 * SourcesApi - axios parameter creator
 * @export
 */
var SourcesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy: function (sourceId, provisioningPolicyDto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('createProvisioningPolicy', 'sourceId', sourceId);
                            // verify required parameter 'provisioningPolicyDto' is not null or undefined
                            (0, common_1.assertParamExists)('createProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto);
                            localVarPath = "/sources/{sourceId}/provisioning-policies"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(provisioningPolicyDto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource: function (source, provisionAsCsv, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'source' is not null or undefined
                            (0, common_1.assertParamExists)('createSource', 'source', source);
                            localVarPath = "/sources";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (provisionAsCsv !== undefined) {
                                localVarQueryParameter['provisionAsCsv'] = provisionAsCsv;
                            }
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(source, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC).
         * @summary Create Schema on Source
         * @param {string} sourceId Source ID.
         * @param {Schema} schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema: function (sourceId, schema, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('createSourceSchema', 'sourceId', sourceId);
                            // verify required parameter 'schema' is not null or undefined
                            (0, common_1.assertParamExists)('createSourceSchema', 'schema', schema);
                            localVarPath = "/sources/{sourceId}/schemas"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(schema, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy: function (sourceId, usageType, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteProvisioningPolicy', 'sourceId', sourceId);
                            // verify required parameter 'usageType' is not null or undefined
                            (0, common_1.assertParamExists)('deleteProvisioningPolicy', 'usageType', usageType);
                            localVarPath = "/sources/{sourceId}/provisioning-policies/{usageType}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)))
                                .replace("{".concat("usageType", "}"), encodeURIComponent(String(usageType)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}` A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Delete Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteSource', 'id', id);
                            localVarPath = "/sources/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema: function (sourceId, schemaId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteSourceSchema', 'sourceId', sourceId);
                            // verify required parameter 'schemaId' is not null or undefined
                            (0, common_1.assertParamExists)('deleteSourceSchema', 'schemaId', schemaId);
                            localVarPath = "/sources/{sourceId}/schemas/{schemaId}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)))
                                .replace("{".concat("schemaId", "}"), encodeURIComponent(String(schemaId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsSchema: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getAccountsSchema', 'id', id);
                            localVarPath = "/sources/{id}/schemas/accounts"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsSchema: function (id, schemaName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getEntitlementsSchema', 'id', id);
                            localVarPath = "/sources/{id}/schemas/entitlements"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (schemaName !== undefined) {
                                localVarQueryParameter['schemaName'] = schemaName;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy: function (sourceId, usageType, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('getProvisioningPolicy', 'sourceId', sourceId);
                            // verify required parameter 'usageType' is not null or undefined
                            (0, common_1.assertParamExists)('getProvisioningPolicy', 'usageType', usageType);
                            localVarPath = "/sources/{sourceId}/provisioning-policies/{usageType}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)))
                                .replace("{".concat("usageType", "}"), encodeURIComponent(String(usageType)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to get a source by a specified ID in Identity Security Cloud (ISC). A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getSource', 'id', id);
                            localVarPath = "/sources/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth: function (sourceId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('getSourceHealth', 'sourceId', sourceId);
                            localVarPath = "/sources/{sourceId}/source-health"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get the Source Schema by ID in IdentityNow.
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema: function (sourceId, schemaId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('getSourceSchema', 'sourceId', sourceId);
                            // verify required parameter 'schemaId' is not null or undefined
                            (0, common_1.assertParamExists)('getSourceSchema', 'schemaId', schemaId);
                            localVarPath = "/sources/{sourceId}/schemas/{schemaId}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)))
                                .replace("{".concat("schemaId", "}"), encodeURIComponent(String(schemaId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC).
         * @summary List Schemas on Source
         * @param {string} sourceId Source ID.
         * @param {'group' | 'user'} [includeTypes] If this is set to &#x60;group&#x60;, the API filters the account schema and only returns only group schemas. If this is set to &#x60;user&#x60;, the API returns the account schema for the source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchemas: function (sourceId, includeTypes, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('getSourceSchemas', 'sourceId', sourceId);
                            localVarPath = "/sources/{sourceId}/schemas"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (includeTypes !== undefined) {
                                localVarQueryParameter['include-types'] = includeTypes;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importAccountsSchema: function (id, file, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('importAccountsSchema', 'id', id);
                            localVarPath = "/sources/{id}/schemas/accounts"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (file !== undefined) {
                                localVarFormParams.append('file', file);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorFile: function (sourceId, file, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('importConnectorFile', 'sourceId', sourceId);
                            localVarPath = "/sources/{sourceId}/upload-connector-file"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (file !== undefined) {
                                localVarFormParams.append('file', file);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importEntitlementsSchema: function (id, schemaName, file, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, localVarFormParams, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('importEntitlementsSchema', 'id', id);
                            localVarPath = "/sources/{id}/schemas/entitlements"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (schemaName !== undefined) {
                                localVarQueryParameter['schemaName'] = schemaName;
                            }
                            if (file !== undefined) {
                                localVarFormParams.append('file', file);
                            }
                            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = localVarFormParams;
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies: function (sourceId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('listProvisioningPolicies', 'sourceId', sourceId);
                            localVarPath = "/sources/{sourceId}/provisioning-policies"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **modified**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*  **category**: *co, eq, ge, gt, in, le, lt, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources: function (limit, offset, count, filters, sorters, forSubadmin, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/sources";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            if (sorters !== undefined) {
                                localVarQueryParameter['sorters'] = sorters;
                            }
                            if (forSubadmin !== undefined) {
                                localVarQueryParameter['for-subadmin'] = forSubadmin;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {ProvisioningPolicyDto} provisioningPolicyDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy: function (sourceId, usageType, provisioningPolicyDto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('putProvisioningPolicy', 'sourceId', sourceId);
                            // verify required parameter 'usageType' is not null or undefined
                            (0, common_1.assertParamExists)('putProvisioningPolicy', 'usageType', usageType);
                            // verify required parameter 'provisioningPolicyDto' is not null or undefined
                            (0, common_1.assertParamExists)('putProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto);
                            localVarPath = "/sources/{sourceId}/provisioning-policies/{usageType}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)))
                                .replace("{".concat("usageType", "}"), encodeURIComponent(String(usageType)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(provisioningPolicyDto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Source (Full)
         * @param {string} id Source ID.
         * @param {Source} source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource: function (id, source, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('putSource', 'id', id);
                            // verify required parameter 'source' is not null or undefined
                            (0, common_1.assertParamExists)('putSource', 'source', source);
                            localVarPath = "/sources/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(source, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error.
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema: function (sourceId, schemaId, schema, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('putSourceSchema', 'sourceId', sourceId);
                            // verify required parameter 'schemaId' is not null or undefined
                            (0, common_1.assertParamExists)('putSourceSchema', 'schemaId', schemaId);
                            // verify required parameter 'schema' is not null or undefined
                            (0, common_1.assertParamExists)('putSourceSchema', 'schema', schema);
                            localVarPath = "/sources/{sourceId}/schemas/{schemaId}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)))
                                .replace("{".concat("schemaId", "}"), encodeURIComponent(String(schemaId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(schema, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk: function (sourceId, provisioningPolicyDto, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('updateProvisioningPoliciesInBulk', 'sourceId', sourceId);
                            // verify required parameter 'provisioningPolicyDto' is not null or undefined
                            (0, common_1.assertParamExists)('updateProvisioningPoliciesInBulk', 'provisioningPolicyDto', provisioningPolicyDto);
                            localVarPath = "/sources/{sourceId}/provisioning-policies/bulk-update"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(provisioningPolicyDto, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy: function (sourceId, usageType, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('updateProvisioningPolicy', 'sourceId', sourceId);
                            // verify required parameter 'usageType' is not null or undefined
                            (0, common_1.assertParamExists)('updateProvisioningPolicy', 'usageType', usageType);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('updateProvisioningPolicy', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/sources/{sourceId}/provisioning-policies/{usageType}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)))
                                .replace("{".concat("usageType", "}"), encodeURIComponent(String(usageType)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API.
         * @summary Update Source (Partial)
         * @param {string} id Source ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in Identity Security Cloud (ISC).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('updateSource', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('updateSource', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/sources/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ```
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema: function (sourceId, schemaId, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sourceId' is not null or undefined
                            (0, common_1.assertParamExists)('updateSourceSchema', 'sourceId', sourceId);
                            // verify required parameter 'schemaId' is not null or undefined
                            (0, common_1.assertParamExists)('updateSourceSchema', 'schemaId', schemaId);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('updateSourceSchema', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/sources/{sourceId}/schemas/{schemaId}"
                                .replace("{".concat("sourceId", "}"), encodeURIComponent(String(sourceId)))
                                .replace("{".concat("schemaId", "}"), encodeURIComponent(String(schemaId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SourcesApiAxiosParamCreator = SourcesApiAxiosParamCreator;
/**
 * SourcesApi - functional programming interface
 * @export
 */
var SourcesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SourcesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy: function (sourceId, provisioningPolicyDto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createProvisioningPolicy(sourceId, provisioningPolicyDto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource: function (source, provisionAsCsv, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createSource(source, provisionAsCsv, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC).
         * @summary Create Schema on Source
         * @param {string} sourceId Source ID.
         * @param {Schema} schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema: function (sourceId, schema, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createSourceSchema(sourceId, schema, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy: function (sourceId, usageType, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteProvisioningPolicy(sourceId, usageType, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}` A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Delete Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteSource(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema: function (sourceId, schemaId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteSourceSchema(sourceId, schemaId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsSchema: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAccountsSchema(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsSchema: function (id, schemaName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEntitlementsSchema(id, schemaName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy: function (sourceId, usageType, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProvisioningPolicy(sourceId, usageType, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to get a source by a specified ID in Identity Security Cloud (ISC). A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSource(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth: function (sourceId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSourceHealth(sourceId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get the Source Schema by ID in IdentityNow.
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema: function (sourceId, schemaId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSourceSchema(sourceId, schemaId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC).
         * @summary List Schemas on Source
         * @param {string} sourceId Source ID.
         * @param {'group' | 'user'} [includeTypes] If this is set to &#x60;group&#x60;, the API filters the account schema and only returns only group schemas. If this is set to &#x60;user&#x60;, the API returns the account schema for the source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchemas: function (sourceId, includeTypes, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSourceSchemas(sourceId, includeTypes, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importAccountsSchema: function (id, file, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.importAccountsSchema(id, file, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorFile: function (sourceId, file, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.importConnectorFile(sourceId, file, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importEntitlementsSchema: function (id, schemaName, file, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.importEntitlementsSchema(id, schemaName, file, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies: function (sourceId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listProvisioningPolicies(sourceId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **modified**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*  **category**: *co, eq, ge, gt, in, le, lt, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources: function (limit, offset, count, filters, sorters, forSubadmin, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {ProvisioningPolicyDto} provisioningPolicyDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy: function (sourceId, usageType, provisioningPolicyDto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putProvisioningPolicy(sourceId, usageType, provisioningPolicyDto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Source (Full)
         * @param {string} id Source ID.
         * @param {Source} source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource: function (id, source, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putSource(id, source, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error.
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema: function (sourceId, schemaId, schema, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putSourceSchema(sourceId, schemaId, schema, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk: function (sourceId, provisioningPolicyDto, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateProvisioningPoliciesInBulk(sourceId, provisioningPolicyDto, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy: function (sourceId, usageType, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API.
         * @summary Update Source (Partial)
         * @param {string} id Source ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in Identity Security Cloud (ISC).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateSource(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ```
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema: function (sourceId, schemaId, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateSourceSchema(sourceId, schemaId, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SourcesApiFp = SourcesApiFp;
/**
 * SourcesApi - factory interface
 * @export
 */
var SourcesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SourcesApiFp)(configuration);
    return {
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy: function (sourceId, provisioningPolicyDto, axiosOptions) {
            return localVarFp.createProvisioningPolicy(sourceId, provisioningPolicyDto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source
         * @param {boolean} [provisionAsCsv] If this parameter is &#x60;true&#x60;, it configures the source as a Delimited File (CSV) source. Setting this to &#x60;true&#x60; will automatically set the &#x60;type&#x60; of the source to &#x60;DelimitedFile&#x60;.  You must use this query parameter to create a Delimited File source as you would in the UI.  If you don\&#39;t set this query parameter and you attempt to set the &#x60;type&#x60; attribute directly, the request won\&#39;t correctly generate the source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource: function (source, provisionAsCsv, axiosOptions) {
            return localVarFp.createSource(source, provisionAsCsv, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC).
         * @summary Create Schema on Source
         * @param {string} sourceId Source ID.
         * @param {Schema} schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSourceSchema: function (sourceId, schema, axiosOptions) {
            return localVarFp.createSourceSchema(sourceId, schema, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy: function (sourceId, usageType, axiosOptions) {
            return localVarFp.deleteProvisioningPolicy(sourceId, usageType, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}` A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Delete Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: function (id, axiosOptions) {
            return localVarFp.deleteSource(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSourceSchema: function (sourceId, schemaId, axiosOptions) {
            return localVarFp.deleteSourceSchema(sourceId, schemaId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsSchema: function (id, axiosOptions) {
            return localVarFp.getAccountsSchema(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getEntitlementsSchema: function (id, schemaName, axiosOptions) {
            return localVarFp.getEntitlementsSchema(id, schemaName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy: function (sourceId, usageType, axiosOptions) {
            return localVarFp.getProvisioningPolicy(sourceId, usageType, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to get a source by a specified ID in Identity Security Cloud (ISC). A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id Source ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource: function (id, axiosOptions) {
            return localVarFp.getSource(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary Fetches source health by id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth: function (sourceId, axiosOptions) {
            return localVarFp.getSourceHealth(sourceId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the Source Schema by ID in IdentityNow.
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchema: function (sourceId, schemaId, axiosOptions) {
            return localVarFp.getSourceSchema(sourceId, schemaId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC).
         * @summary List Schemas on Source
         * @param {string} sourceId Source ID.
         * @param {'group' | 'user'} [includeTypes] If this is set to &#x60;group&#x60;, the API filters the account schema and only returns only group schemas. If this is set to &#x60;user&#x60;, the API returns the account schema for the source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceSchemas: function (sourceId, includeTypes, axiosOptions) {
            return localVarFp.getSourceSchemas(sourceId, includeTypes, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importAccountsSchema: function (id, file, axiosOptions) {
            return localVarFp.importAccountsSchema(id, file, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorFile: function (sourceId, file, axiosOptions) {
            return localVarFp.importConnectorFile(sourceId, file, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importEntitlementsSchema: function (id, schemaName, file, axiosOptions) {
            return localVarFp.importEntitlementsSchema(id, schemaName, file, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies: function (sourceId, axiosOptions) {
            return localVarFp.listProvisioningPolicies(sourceId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **name**: *co, eq, in, sw, ge, gt, ne, isnull*  **type**: *eq, in, ge, gt, ne, isnull, sw*  **owner.id**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **features**: *ca, co*  **created**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **modified**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **managementWorkgroup.id**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **description**: *eq, sw*  **authoritative**: *eq, ne, isnull*  **healthy**: *isnull*  **status**: *eq, in, ge, gt, le, lt, ne, isnull, sw*  **connectionType**: *eq, ge, gt, in, le, lt, ne, isnull, sw*  **connectorName**: *eq, ge, gt, in, ne, isnull, sw*  **category**: *co, eq, ge, gt, in, le, lt, ne, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status, id, description, owner.id, accountCorrelationConfig.id, accountCorrelationConfig.name, managerCorrelationRule.type, managerCorrelationRule.id, managerCorrelationRule.name, authoritative, managementWorkgroup.id, connectorName, connectionType**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources: function (limit, offset, count, filters, sorters, forSubadmin, axiosOptions) {
            return localVarFp.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {ProvisioningPolicyDto} provisioningPolicyDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putProvisioningPolicy: function (sourceId, usageType, provisioningPolicyDto, axiosOptions) {
            return localVarFp.putProvisioningPolicy(sourceId, usageType, provisioningPolicyDto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Source (Full)
         * @param {string} id Source ID.
         * @param {Source} source
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSource: function (id, source, axiosOptions) {
            return localVarFp.putSource(id, source, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error.
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putSourceSchema: function (sourceId, schemaId, schema, axiosOptions) {
            return localVarFp.putSourceSchema(sourceId, schemaId, schema, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPoliciesInBulk: function (sourceId, provisioningPolicyDto, axiosOptions) {
            return localVarFp.updateProvisioningPoliciesInBulk(sourceId, provisioningPolicyDto, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of provisioning policy usage.  In IdentityNow, a source can support various provisioning operations. For example, when a joiner is added to a source, this may trigger both CREATE and UPDATE provisioning operations.  Each usage type is considered a provisioning policy.  A source can have any number of these provisioning policies defined.  These are the common usage types:  CREATE - This usage type relates to \&#39;Create Account Profile\&#39;, the provisioning template for the account to be created. For example, this would be used for a joiner on a source.   UPDATE - This usage type relates to \&#39;Update Account Profile\&#39;, the provisioning template for the \&#39;Update\&#39; connector operations. For example, this would be used for an attribute sync on a source. ENABLE - This usage type relates to \&#39;Enable Account Profile\&#39;, the provisioning template for the account to be enabled. For example, this could be used for a joiner on a source once the joiner\&#39;s account is created.  DISABLE - This usage type relates to \&#39;Disable Account Profile\&#39;, the provisioning template for the account to be disabled. For example, this could be used when a leaver is removed temporarily from a source.  You can use these four usage types for all your provisioning policy needs.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy: function (sourceId, usageType, jsonPatchOperation, axiosOptions) {
            return localVarFp.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API.
         * @summary Update Source (Partial)
         * @param {string} id Source ID.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in Identity Security Cloud (ISC).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.updateSource(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ```
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSourceSchema: function (sourceId, schemaId, jsonPatchOperation, axiosOptions) {
            return localVarFp.updateSourceSchema(sourceId, schemaId, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SourcesApiFactory = SourcesApiFactory;
/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
var SourcesApi = /** @class */ (function (_super) {
    __extends(SourcesApi, _super);
    function SourcesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Provisioning Policy
     * @param {SourcesApiCreateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.createProvisioningPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).createProvisioningPolicy(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Creates a source in IdentityNow.
     * @param {SourcesApiCreateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.createSource = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).createSource(requestParameters.source, requestParameters.provisionAsCsv, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to create a new schema on the specified source in Identity Security Cloud (ISC).
     * @summary Create Schema on Source
     * @param {SourcesApiCreateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.createSourceSchema = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).createSourceSchema(requestParameters.sourceId, requestParameters.schema, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Provisioning Policy by UsageType
     * @param {SourcesApiDeleteProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.deleteProvisioningPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).deleteProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to delete a specific source in Identity Security Cloud (ISC). The API removes all the accounts on the source first, and then it deletes the source. You can retrieve the actual task execution status with this method: GET `/task-status/{id}` A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Delete Source by ID
     * @param {SourcesApiDeleteSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.deleteSource = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).deleteSource(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Delete Source Schema by ID
     * @param {SourcesApiDeleteSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.deleteSourceSchema = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).deleteSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source accounts schema template
     * @param {SourcesApiGetAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.getAccountsSchema = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).getAccountsSchema(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source entitlements schema template
     * @param {SourcesApiGetEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.getEntitlementsSchema = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).getEntitlementsSchema(requestParameters.id, requestParameters.schemaName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Provisioning Policy by UsageType
     * @param {SourcesApiGetProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.getProvisioningPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).getProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to get a source by a specified ID in Identity Security Cloud (ISC). A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Source by ID
     * @param {SourcesApiGetSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.getSource = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).getSource(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint fetches source health by source\'s id
     * @summary Fetches source health by id
     * @param {SourcesApiGetSourceHealthRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.getSourceHealth = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).getSourceHealth(requestParameters.sourceId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get the Source Schema by ID in IdentityNow.
     * @summary Get Source Schema by ID
     * @param {SourcesApiGetSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.getSourceSchema = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).getSourceSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to list the schemas that exist on the specified source in Identity Security Cloud (ISC).
     * @summary List Schemas on Source
     * @param {SourcesApiGetSourceSchemasRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.getSourceSchemas = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).getSourceSchemas(requestParameters.sourceId, requestParameters.includeTypes, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source accounts schema template
     * @param {SourcesApiImportAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.importAccountsSchema = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).importAccountsSchema(requestParameters.id, requestParameters.file, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
     * @summary Upload connector file to source
     * @param {SourcesApiImportConnectorFileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.importConnectorFile = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).importConnectorFile(requestParameters.sourceId, requestParameters.file, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`{SourceName}`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source entitlements schema template
     * @param {SourcesApiImportEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.importEntitlementsSchema = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).importEntitlementsSchema(requestParameters.id, requestParameters.schemaName, requestParameters.file, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists ProvisioningPolicies
     * @param {SourcesApiListProvisioningPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.listProvisioningPolicies = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).listProvisioningPolicies(requestParameters.sourceId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary Lists all sources in IdentityNow.
     * @param {SourcesApiListSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.listSources = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.SourcesApiFp)(this.configuration).listSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSubadmin, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Update Provisioning Policy by UsageType
     * @param {SourcesApiPutProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.putProvisioningPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).putProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.provisioningPolicyDto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to update a source in Identity Security Cloud (ISC), using a full object representation. This means that when you use this API, it completely replaces the existing source configuration.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Update Source (Full)
     * @param {SourcesApiPutSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.putSource = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).putSource(requestParameters.id, requestParameters.source, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error.
     * @summary Update Source Schema (Full)
     * @param {SourcesApiPutSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.putSourceSchema = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).putSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.schema, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Bulk Update Provisioning Policies
     * @param {SourcesApiUpdateProvisioningPoliciesInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.updateProvisioningPoliciesInBulk = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).updateProvisioningPoliciesInBulk(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. Transforms can be used in the provisioning policy to create a new attribute that you only need during provisioning. Refer to [Transforms in Provisioning Policies](https://developer.sailpoint.com/idn/docs/transforms/guides/transforms-in-provisioning-policies) for more information. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Partial update of Provisioning Policy
     * @param {SourcesApiUpdateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.updateProvisioningPolicy = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).updateProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to partially update a source in Identity Security Cloud (ISC), using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  These fields are immutable, so they cannot be changed:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API.
     * @summary Update Source (Partial)
     * @param {SourcesApiUpdateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.updateSource = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).updateSource(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-source-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ```
     * @summary Update Source Schema (Partial)
     * @param {SourcesApiUpdateSourceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    SourcesApi.prototype.updateSourceSchema = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SourcesApiFp)(this.configuration).updateSourceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SourcesApi;
}(base_1.BaseAPI));
exports.SourcesApi = SourcesApi;
/**
 * TaggedObjectsApi - axios parameter creator
 * @export
 */
var TaggedObjectsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject: function (type, id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('deleteTaggedObject', 'type', type);
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteTaggedObject', 'id', id);
                            localVarPath = "/tagged-objects/{type}/{id}"
                                .replace("{".concat("type", "}"), encodeURIComponent(String(type)))
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkRemoveTaggedObject} bulkRemoveTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsToManyObject: function (bulkRemoveTaggedObject, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bulkRemoveTaggedObject' is not null or undefined
                            (0, common_1.assertParamExists)('deleteTagsToManyObject', 'bulkRemoveTaggedObject', bulkRemoveTaggedObject);
                            localVarPath = "/tagged-objects/bulk-remove";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(bulkRemoveTaggedObject, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject: function (type, id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('getTaggedObject', 'type', type);
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getTaggedObject', 'id', id);
                            localVarPath = "/tagged-objects/{type}/{id}"
                                .replace("{".concat("type", "}"), encodeURIComponent(String(type)))
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects: function (limit, offset, count, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/tagged-objects";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects by Type
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType: function (type, limit, offset, count, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('listTaggedObjectsByType', 'type', type);
                            localVarPath = "/tagged-objects/{type}"
                                .replace("{".concat("type", "}"), encodeURIComponent(String(type)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTaggedObject: function (type, id, taggedObject, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('putTaggedObject', 'type', type);
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('putTaggedObject', 'id', id);
                            // verify required parameter 'taggedObject' is not null or undefined
                            (0, common_1.assertParamExists)('putTaggedObject', 'taggedObject', taggedObject);
                            localVarPath = "/tagged-objects/{type}/{id}"
                                .replace("{".concat("type", "}"), encodeURIComponent(String(type)))
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(taggedObject, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject: function (taggedObject, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'taggedObject' is not null or undefined
                            (0, common_1.assertParamExists)('setTagToObject', 'taggedObject', taggedObject);
                            localVarPath = "/tagged-objects";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(taggedObject, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkAddTaggedObject} bulkAddTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagsToManyObjects: function (bulkAddTaggedObject, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'bulkAddTaggedObject' is not null or undefined
                            (0, common_1.assertParamExists)('setTagsToManyObjects', 'bulkAddTaggedObject', bulkAddTaggedObject);
                            localVarPath = "/tagged-objects/bulk-add";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(bulkAddTaggedObject, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.TaggedObjectsApiAxiosParamCreator = TaggedObjectsApiAxiosParamCreator;
/**
 * TaggedObjectsApi - functional programming interface
 * @export
 */
var TaggedObjectsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.TaggedObjectsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject: function (type, id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteTaggedObject(type, id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkRemoveTaggedObject} bulkRemoveTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsToManyObject: function (bulkRemoveTaggedObject, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteTagsToManyObject(bulkRemoveTaggedObject, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject: function (type, id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getTaggedObject(type, id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects: function (limit, offset, count, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listTaggedObjects(limit, offset, count, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects by Type
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType: function (type, limit, offset, count, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listTaggedObjectsByType(type, limit, offset, count, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTaggedObject: function (type, id, taggedObject, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putTaggedObject(type, id, taggedObject, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject: function (taggedObject, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setTagToObject(taggedObject, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkAddTaggedObject} bulkAddTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagsToManyObjects: function (bulkAddTaggedObject, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setTagsToManyObjects(bulkAddTaggedObject, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.TaggedObjectsApiFp = TaggedObjectsApiFp;
/**
 * TaggedObjectsApi - factory interface
 * @export
 */
var TaggedObjectsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.TaggedObjectsApiFp)(configuration);
    return {
        /**
         * This deletes a tagged object for the specified type.
         * @summary Delete Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to delete.
         * @param {string} id The ID of the object reference to delete.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaggedObject: function (type, id, axiosOptions) {
            return localVarFp.deleteTaggedObject(type, id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Remove Tags from Multiple Objects
         * @param {BulkRemoveTaggedObject} bulkRemoveTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsToManyObject: function (bulkRemoveTaggedObject, axiosOptions) {
            return localVarFp.deleteTagsToManyObject(bulkRemoveTaggedObject, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a tagged object for the specified type.
         * @summary Get Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {string} id The ID of the object reference to retrieve.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTaggedObject: function (type, id, axiosOptions) {
            return localVarFp.getTaggedObject(type, id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq, in*  **objectRef.type**: *eq, in*  **tagName**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjects: function (limit, offset, count, filters, axiosOptions) {
            return localVarFp.listTaggedObjects(limit, offset, count, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
         * @summary List Tagged Objects by Type
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to retrieve.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **objectRef.id**: *eq*  **objectRef.type**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTaggedObjectsByType: function (type, limit, offset, count, filters, axiosOptions) {
            return localVarFp.listTaggedObjectsByType(type, limit, offset, count, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This updates a tagged object for the specified type.
         * @summary Update Tagged Object
         * @param {'ACCESS_PROFILE' | 'APPLICATION' | 'CAMPAIGN' | 'ENTITLEMENT' | 'IDENTITY' | 'ROLE' | 'SOD_POLICY' | 'SOURCE'} type The type of tagged object to update.
         * @param {string} id The ID of the object reference to update.
         * @param {TaggedObject} taggedObject
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putTaggedObject: function (type, id, taggedObject, axiosOptions) {
            return localVarFp.putTaggedObject(type, id, taggedObject, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This adds a tag to an object.  Any authenticated token may be used to call this API.
         * @summary Add Tag to Object
         * @param {TaggedObject} taggedObject
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagToObject: function (taggedObject, axiosOptions) {
            return localVarFp.setTagToObject(taggedObject, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Tag Multiple Objects
         * @param {BulkAddTaggedObject} bulkAddTaggedObject Supported object types are ACCESS_PROFILE, APPLICATION, CAMPAIGN, ENTITLEMENT, IDENTITY, ROLE, SOD_POLICY, SOURCE.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setTagsToManyObjects: function (bulkAddTaggedObject, axiosOptions) {
            return localVarFp.setTagsToManyObjects(bulkAddTaggedObject, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.TaggedObjectsApiFactory = TaggedObjectsApiFactory;
/**
 * TaggedObjectsApi - object-oriented interface
 * @export
 * @class TaggedObjectsApi
 * @extends {BaseAPI}
 */
var TaggedObjectsApi = /** @class */ (function (_super) {
    __extends(TaggedObjectsApi, _super);
    function TaggedObjectsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This deletes a tagged object for the specified type.
     * @summary Delete Tagged Object
     * @param {TaggedObjectsApiDeleteTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    TaggedObjectsApi.prototype.deleteTaggedObject = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TaggedObjectsApiFp)(this.configuration).deleteTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API removes tags from multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Remove Tags from Multiple Objects
     * @param {TaggedObjectsApiDeleteTagsToManyObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    TaggedObjectsApi.prototype.deleteTagsToManyObject = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TaggedObjectsApiFp)(this.configuration).deleteTagsToManyObject(requestParameters.bulkRemoveTaggedObject, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a tagged object for the specified type.
     * @summary Get Tagged Object
     * @param {TaggedObjectsApiGetTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    TaggedObjectsApi.prototype.getTaggedObject = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TaggedObjectsApiFp)(this.configuration).getTaggedObject(requestParameters.type, requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a list of all tagged objects.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects
     * @param {TaggedObjectsApiListTaggedObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    TaggedObjectsApi.prototype.listTaggedObjects = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.TaggedObjectsApiFp)(this.configuration).listTaggedObjects(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns a list of all tagged objects by type.  Any authenticated token may be used to call this API.
     * @summary List Tagged Objects by Type
     * @param {TaggedObjectsApiListTaggedObjectsByTypeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    TaggedObjectsApi.prototype.listTaggedObjectsByType = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TaggedObjectsApiFp)(this.configuration).listTaggedObjectsByType(requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This updates a tagged object for the specified type.
     * @summary Update Tagged Object
     * @param {TaggedObjectsApiPutTaggedObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    TaggedObjectsApi.prototype.putTaggedObject = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TaggedObjectsApiFp)(this.configuration).putTaggedObject(requestParameters.type, requestParameters.id, requestParameters.taggedObject, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This adds a tag to an object.  Any authenticated token may be used to call this API.
     * @summary Add Tag to Object
     * @param {TaggedObjectsApiSetTagToObjectRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    TaggedObjectsApi.prototype.setTagToObject = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TaggedObjectsApiFp)(this.configuration).setTagToObject(requestParameters.taggedObject, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API adds tags to multiple objects.  A token with API, CERT_ADMIN, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Tag Multiple Objects
     * @param {TaggedObjectsApiSetTagsToManyObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggedObjectsApi
     */
    TaggedObjectsApi.prototype.setTagsToManyObjects = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TaggedObjectsApiFp)(this.configuration).setTagsToManyObjects(requestParameters.bulkAddTaggedObject, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return TaggedObjectsApi;
}(base_1.BaseAPI));
exports.TaggedObjectsApi = TaggedObjectsApi;
/**
 * TransformsApi - axios parameter creator
 * @export
 */
var TransformsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform: function (transform, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'transform' is not null or undefined
                            (0, common_1.assertParamExists)('createTransform', 'transform', transform);
                            localVarPath = "/transforms";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transform, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteTransform', 'id', id);
                            localVarPath = "/transforms/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getTransform', 'id', id);
                            localVarPath = "/transforms/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms: function (offset, limit, count, name, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/transforms";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (name !== undefined) {
                                localVarQueryParameter['name'] = name;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform: function (id, transform, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('updateTransform', 'id', id);
                            localVarPath = "/transforms/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transform, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.TransformsApiAxiosParamCreator = TransformsApiAxiosParamCreator;
/**
 * TransformsApi - functional programming interface
 * @export
 */
var TransformsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.TransformsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform: function (transform, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createTransform(transform, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteTransform(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getTransform(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms: function (offset, limit, count, name, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listTransforms(offset, limit, count, name, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform: function (id, transform, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateTransform(id, transform, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.TransformsApiFp = TransformsApiFp;
/**
 * TransformsApi - factory interface
 * @export
 */
var TransformsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.TransformsApiFp)(configuration);
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform: function (transform, axiosOptions) {
            return localVarFp.createTransform(transform, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform: function (id, axiosOptions) {
            return localVarFp.deleteTransform(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform: function (id, axiosOptions) {
            return localVarFp.getTransform(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **internal**: *eq*  **name**: *eq, sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listTransforms: function (offset, limit, count, name, filters, axiosOptions) {
            return localVarFp.listTransforms(offset, limit, count, name, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object. Must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields, but \&quot;name\&quot; and \&quot;type\&quot; must not be modified.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform: function (id, transform, axiosOptions) {
            return localVarFp.updateTransform(id, transform, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.TransformsApiFactory = TransformsApiFactory;
/**
 * TransformsApi - object-oriented interface
 * @export
 * @class TransformsApi
 * @extends {BaseAPI}
 */
var TransformsApi = /** @class */ (function (_super) {
    __extends(TransformsApi, _super);
    function TransformsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
     * @summary Create transform
     * @param {TransformsApiCreateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    TransformsApi.prototype.createTransform = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TransformsApiFp)(this.configuration).createTransform(requestParameters.transform, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
     * @summary Delete a transform
     * @param {TransformsApiDeleteTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    TransformsApi.prototype.deleteTransform = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TransformsApiFp)(this.configuration).deleteTransform(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
     * @summary Transform by ID
     * @param {TransformsApiGetTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    TransformsApi.prototype.getTransform = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TransformsApiFp)(this.configuration).getTransform(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
     * @summary List transforms
     * @param {TransformsApiListTransformsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    TransformsApi.prototype.listTransforms = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.TransformsApiFp)(this.configuration).listTransforms(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.name, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
     * @summary Update a transform
     * @param {TransformsApiUpdateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    TransformsApi.prototype.updateTransform = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.TransformsApiFp)(this.configuration).updateTransform(requestParameters.id, requestParameters.transform, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return TransformsApi;
}(base_1.BaseAPI));
exports.TransformsApi = TransformsApi;
/**
 * VendorConnectorMappingsApi - axios parameter creator
 * @export
 */
var VendorConnectorMappingsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Creates a new mapping between a SaaS vendor and an IDN connector to establish correlation paths.
         * @summary Create a vendor connector mapping
         * @param {VendorConnectorMapping} vendorConnectorMapping
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createVendorConnectorMapping: function (vendorConnectorMapping, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'vendorConnectorMapping' is not null or undefined
                            (0, common_1.assertParamExists)('createVendorConnectorMapping', 'vendorConnectorMapping', vendorConnectorMapping);
                            localVarPath = "/vendor-connector-mappings";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(vendorConnectorMapping, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Soft deletes a mapping between a SaaS vendor and an IDN connector, removing the established correlation.
         * @summary Delete a vendor connector mapping
         * @param {VendorConnectorMapping} vendorConnectorMapping
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteVendorConnectorMapping: function (vendorConnectorMapping, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'vendorConnectorMapping' is not null or undefined
                            (0, common_1.assertParamExists)('deleteVendorConnectorMapping', 'vendorConnectorMapping', vendorConnectorMapping);
                            localVarPath = "/vendor-connector-mappings";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(vendorConnectorMapping, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.VendorConnectorMappingsApiAxiosParamCreator = VendorConnectorMappingsApiAxiosParamCreator;
/**
 * VendorConnectorMappingsApi - functional programming interface
 * @export
 */
var VendorConnectorMappingsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.VendorConnectorMappingsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a new mapping between a SaaS vendor and an IDN connector to establish correlation paths.
         * @summary Create a vendor connector mapping
         * @param {VendorConnectorMapping} vendorConnectorMapping
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createVendorConnectorMapping: function (vendorConnectorMapping, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createVendorConnectorMapping(vendorConnectorMapping, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Soft deletes a mapping between a SaaS vendor and an IDN connector, removing the established correlation.
         * @summary Delete a vendor connector mapping
         * @param {VendorConnectorMapping} vendorConnectorMapping
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteVendorConnectorMapping: function (vendorConnectorMapping, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteVendorConnectorMapping(vendorConnectorMapping, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.VendorConnectorMappingsApiFp = VendorConnectorMappingsApiFp;
/**
 * VendorConnectorMappingsApi - factory interface
 * @export
 */
var VendorConnectorMappingsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.VendorConnectorMappingsApiFp)(configuration);
    return {
        /**
         * Creates a new mapping between a SaaS vendor and an IDN connector to establish correlation paths.
         * @summary Create a vendor connector mapping
         * @param {VendorConnectorMapping} vendorConnectorMapping
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createVendorConnectorMapping: function (vendorConnectorMapping, axiosOptions) {
            return localVarFp.createVendorConnectorMapping(vendorConnectorMapping, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Soft deletes a mapping between a SaaS vendor and an IDN connector, removing the established correlation.
         * @summary Delete a vendor connector mapping
         * @param {VendorConnectorMapping} vendorConnectorMapping
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteVendorConnectorMapping: function (vendorConnectorMapping, axiosOptions) {
            return localVarFp.deleteVendorConnectorMapping(vendorConnectorMapping, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.VendorConnectorMappingsApiFactory = VendorConnectorMappingsApiFactory;
/**
 * VendorConnectorMappingsApi - object-oriented interface
 * @export
 * @class VendorConnectorMappingsApi
 * @extends {BaseAPI}
 */
var VendorConnectorMappingsApi = /** @class */ (function (_super) {
    __extends(VendorConnectorMappingsApi, _super);
    function VendorConnectorMappingsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a new mapping between a SaaS vendor and an IDN connector to establish correlation paths.
     * @summary Create a vendor connector mapping
     * @param {VendorConnectorMappingsApiCreateVendorConnectorMappingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorConnectorMappingsApi
     */
    VendorConnectorMappingsApi.prototype.createVendorConnectorMapping = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.VendorConnectorMappingsApiFp)(this.configuration).createVendorConnectorMapping(requestParameters.vendorConnectorMapping, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Soft deletes a mapping between a SaaS vendor and an IDN connector, removing the established correlation.
     * @summary Delete a vendor connector mapping
     * @param {VendorConnectorMappingsApiDeleteVendorConnectorMappingRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof VendorConnectorMappingsApi
     */
    VendorConnectorMappingsApi.prototype.deleteVendorConnectorMapping = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.VendorConnectorMappingsApiFp)(this.configuration).deleteVendorConnectorMapping(requestParameters.vendorConnectorMapping, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return VendorConnectorMappingsApi;
}(base_1.BaseAPI));
exports.VendorConnectorMappingsApi = VendorConnectorMappingsApi;
/**
 * WorkItemsApi - axios parameter creator
 * @export
 */
var WorkItemsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem: function (id, approvalItemId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('approveApprovalItem', 'id', id);
                            // verify required parameter 'approvalItemId' is not null or undefined
                            (0, common_1.assertParamExists)('approveApprovalItem', 'approvalItemId', approvalItemId);
                            localVarPath = "/work-items/{id}/approve/{approvalItemId}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)))
                                .replace("{".concat("approvalItemId", "}"), encodeURIComponent(String(approvalItemId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('approveApprovalItemsInBulk', 'id', id);
                            localVarPath = "/work-items/bulk-approve/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('completeWorkItem', 'id', id);
                            localVarPath = "/work-items/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems: function (ownerId, limit, offset, count, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/work-items/completed";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (ownerId !== undefined) {
                                localVarQueryParameter['ownerId'] = ownerId;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems: function (ownerId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/work-items/completed/count";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (ownerId !== undefined) {
                                localVarQueryParameter['ownerId'] = ownerId;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems: function (ownerId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/work-items/count";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (ownerId !== undefined) {
                                localVarQueryParameter['ownerId'] = ownerId;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getWorkItem', 'id', id);
                            localVarPath = "/work-items/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary: function (ownerId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/work-items/summary";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (ownerId !== undefined) {
                                localVarQueryParameter['ownerId'] = ownerId;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems: function (limit, offset, count, ownerId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/work-items";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (ownerId !== undefined) {
                                localVarQueryParameter['ownerId'] = ownerId;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem: function (id, approvalItemId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('rejectApprovalItem', 'id', id);
                            // verify required parameter 'approvalItemId' is not null or undefined
                            (0, common_1.assertParamExists)('rejectApprovalItem', 'approvalItemId', approvalItemId);
                            localVarPath = "/work-items/{id}/reject/{approvalItemId}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)))
                                .replace("{".concat("approvalItemId", "}"), encodeURIComponent(String(approvalItemId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('rejectApprovalItemsInBulk', 'id', id);
                            localVarPath = "/work-items/bulk-reject/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request. Accessible to work-item Owner, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN.
         * @summary Forward a Work Item
         * @param {string} id The ID of the work item
         * @param {WorkItemForward} workItemForward
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendWorkItemForward: function (id, workItemForward, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('sendWorkItemForward', 'id', id);
                            // verify required parameter 'workItemForward' is not null or undefined
                            (0, common_1.assertParamExists)('sendWorkItemForward', 'workItemForward', workItemForward);
                            localVarPath = "/work-items/{id}/forward"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workItemForward, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection: function (id, requestBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('submitAccountSelection', 'id', id);
                            // verify required parameter 'requestBody' is not null or undefined
                            (0, common_1.assertParamExists)('submitAccountSelection', 'requestBody', requestBody);
                            localVarPath = "/work-items/{id}/submit-account-selection"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(requestBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.WorkItemsApiAxiosParamCreator = WorkItemsApiAxiosParamCreator;
/**
 * WorkItemsApi - functional programming interface
 * @export
 */
var WorkItemsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.WorkItemsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem: function (id, approvalItemId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.approveApprovalItem(id, approvalItemId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.approveApprovalItemsInBulk(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.completeWorkItem(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems: function (ownerId, limit, offset, count, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCompletedWorkItems(ownerId, limit, offset, count, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems: function (ownerId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCountCompletedWorkItems(ownerId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems: function (ownerId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCountWorkItems(ownerId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorkItem(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary: function (ownerId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorkItemsSummary(ownerId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems: function (limit, offset, count, ownerId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listWorkItems(limit, offset, count, ownerId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem: function (id, approvalItemId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.rejectApprovalItem(id, approvalItemId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.rejectApprovalItemsInBulk(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request. Accessible to work-item Owner, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN.
         * @summary Forward a Work Item
         * @param {string} id The ID of the work item
         * @param {WorkItemForward} workItemForward
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendWorkItemForward: function (id, workItemForward, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.sendWorkItemForward(id, workItemForward, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection: function (id, requestBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.submitAccountSelection(id, requestBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.WorkItemsApiFp = WorkItemsApiFp;
/**
 * WorkItemsApi - factory interface
 * @export
 */
var WorkItemsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.WorkItemsApiFp)(configuration);
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem: function (id, approvalItemId, axiosOptions) {
            return localVarFp.approveApprovalItem(id, approvalItemId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItemsInBulk: function (id, axiosOptions) {
            return localVarFp.approveApprovalItemsInBulk(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem: function (id, axiosOptions) {
            return localVarFp.completeWorkItem(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedWorkItems: function (ownerId, limit, offset, count, axiosOptions) {
            return localVarFp.getCompletedWorkItems(ownerId, limit, offset, count, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountCompletedWorkItems: function (ownerId, axiosOptions) {
            return localVarFp.getCountCompletedWorkItems(ownerId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCountWorkItems: function (ownerId, axiosOptions) {
            return localVarFp.getCountWorkItems(ownerId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItem: function (id, axiosOptions) {
            return localVarFp.getWorkItem(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItemsSummary: function (ownerId, axiosOptions) {
            return localVarFp.getWorkItemsSummary(ownerId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems: function (limit, offset, count, ownerId, axiosOptions) {
            return localVarFp.listWorkItems(limit, offset, count, ownerId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem: function (id, approvalItemId, axiosOptions) {
            return localVarFp.rejectApprovalItem(id, approvalItemId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItemsInBulk: function (id, axiosOptions) {
            return localVarFp.rejectApprovalItemsInBulk(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request. Accessible to work-item Owner, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN.
         * @summary Forward a Work Item
         * @param {string} id The ID of the work item
         * @param {WorkItemForward} workItemForward
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        sendWorkItemForward: function (id, workItemForward, axiosOptions) {
            return localVarFp.sendWorkItemForward(id, workItemForward, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection: function (id, requestBody, axiosOptions) {
            return localVarFp.submitAccountSelection(id, requestBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.WorkItemsApiFactory = WorkItemsApiFactory;
/**
 * WorkItemsApi - object-oriented interface
 * @export
 * @class WorkItemsApi
 * @extends {BaseAPI}
 */
var WorkItemsApi = /** @class */ (function (_super) {
    __extends(WorkItemsApi, _super);
    function WorkItemsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Approve an Approval Item
     * @param {WorkItemsApiApproveApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.approveApprovalItem = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkItemsApiFp)(this.configuration).approveApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk approve Approval Items
     * @param {WorkItemsApiApproveApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.approveApprovalItemsInBulk = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkItemsApiFp)(this.configuration).approveApprovalItemsInBulk(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API completes a work item. Either an admin, or the owning/current user must make this request.
     * @summary Complete a Work Item
     * @param {WorkItemsApiCompleteWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.completeWorkItem = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkItemsApiFp)(this.configuration).completeWorkItem(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Completed Work Items
     * @param {WorkItemsApiGetCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.getCompletedWorkItems = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.WorkItemsApiFp)(this.configuration).getCompletedWorkItems(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Completed Work Items
     * @param {WorkItemsApiGetCountCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.getCountCompletedWorkItems = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.WorkItemsApiFp)(this.configuration).getCountCompletedWorkItems(requestParameters.ownerId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a count of work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Work Items
     * @param {WorkItemsApiGetCountWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.getCountWorkItems = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.WorkItemsApiFp)(this.configuration).getCountWorkItems(requestParameters.ownerId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
     * @summary Get a Work Item
     * @param {WorkItemsApiGetWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.getWorkItem = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkItemsApiFp)(this.configuration).getWorkItem(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
     * @summary Work Items Summary
     * @param {WorkItemsApiGetWorkItemsSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.getWorkItemsSummary = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.WorkItemsApiFp)(this.configuration).getWorkItemsSummary(requestParameters.ownerId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
     * @summary List Work Items
     * @param {WorkItemsApiListWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.listWorkItems = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.WorkItemsApiFp)(this.configuration).listWorkItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.ownerId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Reject an Approval Item
     * @param {WorkItemsApiRejectApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.rejectApprovalItem = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkItemsApiFp)(this.configuration).rejectApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk reject Approval Items
     * @param {WorkItemsApiRejectApprovalItemsInBulkRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.rejectApprovalItemsInBulk = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkItemsApiFp)(this.configuration).rejectApprovalItemsInBulk(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API forwards a work item to a new owner. Either an admin, or the owning/current user must make this request. Accessible to work-item Owner, ORG_ADMIN, REPORT_ADMIN, ROLE_ADMIN, ROLE_SUBADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN.
     * @summary Forward a Work Item
     * @param {WorkItemsApiSendWorkItemForwardRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.sendWorkItemForward = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkItemsApiFp)(this.configuration).sendWorkItemForward(requestParameters.id, requestParameters.workItemForward, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This API submits account selections. Either an admin, or the owning/current user must make this request.
     * @summary Submit Account Selections
     * @param {WorkItemsApiSubmitAccountSelectionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    WorkItemsApi.prototype.submitAccountSelection = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkItemsApiFp)(this.configuration).submitAccountSelection(requestParameters.id, requestParameters.requestBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return WorkItemsApi;
}(base_1.BaseAPI));
exports.WorkItemsApi = WorkItemsApi;
/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
var WorkflowsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflowExecution: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('cancelWorkflowExecution', 'id', id);
                            localVarPath = "/workflow-executions/{id}/cancel"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {CreateExternalExecuteWorkflowRequest} [createExternalExecuteWorkflowRequest]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createExternalExecuteWorkflow: function (id, createExternalExecuteWorkflowRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('createExternalExecuteWorkflow', 'id', id);
                            localVarPath = "/workflows/execute/external/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createExternalExecuteWorkflowRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow: function (createWorkflowRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'createWorkflowRequest' is not null or undefined
                            (0, common_1.assertParamExists)('createWorkflow', 'createWorkflowRequest', createWorkflowRequest);
                            localVarPath = "/workflows/{id}";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWorkflowRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowExternalTrigger: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('createWorkflowExternalTrigger', 'id', id);
                            localVarPath = "/workflows/{id}/external/oauth-clients"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('deleteWorkflow', 'id', id);
                            localVarPath = "/workflows/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getWorkflow', 'id', id);
                            localVarPath = "/workflows/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
         * @summary Get Workflow Execution
         * @param {string} id Workflow execution ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecution: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getWorkflowExecution', 'id', id);
                            localVarPath = "/workflow-executions/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutionHistory: function (id, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getWorkflowExecutionHistory', 'id', id);
                            localVarPath = "/workflow-executions/{id}/history"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
         * @summary List Workflow Executions
         * @param {string} id Workflow ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **startTime**: *eq, lt, le, gt, ge*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutions: function (id, limit, offset, count, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('getWorkflowExecutions', 'id', id);
                            localVarPath = "/workflows/{id}/executions"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompleteWorkflowLibrary: function (limit, offset, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/workflow-library";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryActions: function (limit, offset, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/workflow-library/actions";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryOperators: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/workflow-library/operators";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryTriggers: function (limit, offset, filters, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/workflow-library/triggers";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            if (offset !== undefined) {
                                localVarQueryParameter['offset'] = offset;
                            }
                            if (filters !== undefined) {
                                localVarQueryParameter['filters'] = filters;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/workflows";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow: function (id, jsonPatchOperation, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('patchWorkflow', 'id', id);
                            // verify required parameter 'jsonPatchOperation' is not null or undefined
                            (0, common_1.assertParamExists)('patchWorkflow', 'jsonPatchOperation', jsonPatchOperation);
                            localVarPath = "/workflows/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PATCH' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonPatchOperation, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBody} workflowBody
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putWorkflow: function (id, workflowBody, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('putWorkflow', 'id', id);
                            // verify required parameter 'workflowBody' is not null or undefined
                            (0, common_1.assertParamExists)('putWorkflow', 'workflowBody', workflowBody);
                            localVarPath = "/workflows/{id}"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequest} [testExternalExecuteWorkflowRequest]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testExternalExecuteWorkflow: function (id, testExternalExecuteWorkflowRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('testExternalExecuteWorkflow', 'id', id);
                            localVarPath = "/workflows/execute/external/{id}/test"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(testExternalExecuteWorkflowRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequest} testWorkflowRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testWorkflow: function (id, testWorkflowRequest, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'id' is not null or undefined
                            (0, common_1.assertParamExists)('testWorkflow', 'id', id);
                            // verify required parameter 'testWorkflowRequest' is not null or undefined
                            (0, common_1.assertParamExists)('testWorkflow', 'testWorkflowRequest', testWorkflowRequest);
                            localVarPath = "/workflows/{id}/test"
                                .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)
                                // authentication UserContextAuth required
                                // oauth required
                            ];
                        case 1:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            // authentication UserContextAuth required
                            // oauth required
                            return [4 /*yield*/, (0, common_1.setOAuthToObject)(localVarHeaderParameter, "UserContextAuth", [], configuration)];
                        case 2:
                            // authentication UserContextAuth required
                            // oauth required
                            _a.sent();
                            localVarHeaderParameter['Content-Type'] = 'application/json';
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(testWorkflowRequest, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.WorkflowsApiAxiosParamCreator = WorkflowsApiAxiosParamCreator;
/**
 * WorkflowsApi - functional programming interface
 * @export
 */
var WorkflowsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.WorkflowsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflowExecution: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.cancelWorkflowExecution(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {CreateExternalExecuteWorkflowRequest} [createExternalExecuteWorkflowRequest]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createExternalExecuteWorkflow: function (id, createExternalExecuteWorkflowRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createExternalExecuteWorkflow(id, createExternalExecuteWorkflowRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow: function (createWorkflowRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createWorkflow(createWorkflowRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowExternalTrigger: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createWorkflowExternalTrigger(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteWorkflow(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorkflow(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
         * @summary Get Workflow Execution
         * @param {string} id Workflow execution ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecution: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorkflowExecution(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutionHistory: function (id, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorkflowExecutionHistory(id, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
         * @summary List Workflow Executions
         * @param {string} id Workflow ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **startTime**: *eq, lt, le, gt, ge*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutions: function (id, limit, offset, count, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getWorkflowExecutions(id, limit, offset, count, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompleteWorkflowLibrary: function (limit, offset, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listCompleteWorkflowLibrary(limit, offset, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryActions: function (limit, offset, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listWorkflowLibraryActions(limit, offset, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryOperators: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listWorkflowLibraryOperators(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryTriggers: function (limit, offset, filters, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listWorkflowLibraryTriggers(limit, offset, filters, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listWorkflows(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow: function (id, jsonPatchOperation, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.patchWorkflow(id, jsonPatchOperation, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBody} workflowBody
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putWorkflow: function (id, workflowBody, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.putWorkflow(id, workflowBody, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequest} [testExternalExecuteWorkflowRequest]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testExternalExecuteWorkflow: function (id, testExternalExecuteWorkflowRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.testExternalExecuteWorkflow(id, testExternalExecuteWorkflowRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequest} testWorkflowRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testWorkflow: function (id, testWorkflowRequest, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.testWorkflow(id, testWorkflowRequest, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.WorkflowsApiFp = WorkflowsApiFp;
/**
 * WorkflowsApi - factory interface
 * @export
 */
var WorkflowsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.WorkflowsApiFp)(configuration);
    return {
        /**
         * Use this API to cancel a running workflow execution.
         * @summary Cancel Workflow Execution by ID
         * @param {string} id The workflow execution ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflowExecution: function (id, axiosOptions) {
            return localVarFp.cancelWorkflowExecution(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
         * @summary Execute Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {CreateExternalExecuteWorkflowRequest} [createExternalExecuteWorkflowRequest]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createExternalExecuteWorkflow: function (id, createExternalExecuteWorkflowRequest, axiosOptions) {
            return localVarFp.createExternalExecuteWorkflow(id, createExternalExecuteWorkflowRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Create a new workflow with the desired trigger and steps specified in the request body.
         * @summary Create Workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow: function (createWorkflowRequest, axiosOptions) {
            return localVarFp.createWorkflow(createWorkflowRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
         * @summary Generate External Trigger OAuth Client
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowExternalTrigger: function (id, axiosOptions) {
            return localVarFp.createWorkflowExternalTrigger(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
         * @summary Delete Workflow By Id
         * @param {string} id Id of the Workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: function (id, axiosOptions) {
            return localVarFp.deleteWorkflow(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get a single workflow by id.
         * @summary Get Workflow By Id
         * @param {string} id Id of the workflow
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow: function (id, axiosOptions) {
            return localVarFp.getWorkflow(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
         * @summary Get Workflow Execution
         * @param {string} id Workflow execution ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecution: function (id, axiosOptions) {
            return localVarFp.getWorkflowExecution(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
         * @summary Get Workflow Execution History
         * @param {string} id Id of the workflow execution
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutionHistory: function (id, axiosOptions) {
            return localVarFp.getWorkflowExecutionHistory(id, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
         * @summary List Workflow Executions
         * @param {string} id Workflow ID.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **startTime**: *eq, lt, le, gt, ge*  **status**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowExecutions: function (id, limit, offset, count, filters, axiosOptions) {
            return localVarFp.getWorkflowExecutions(id, limit, offset, count, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This lists all triggers, actions, and operators in the library
         * @summary List Complete Workflow Library
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompleteWorkflowLibrary: function (limit, offset, axiosOptions) {
            return localVarFp.listCompleteWorkflowLibrary(limit, offset, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This lists the workflow actions available to you.
         * @summary List Workflow Library Actions
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryActions: function (limit, offset, filters, axiosOptions) {
            return localVarFp.listWorkflowLibraryActions(limit, offset, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This lists the workflow operators available to you
         * @summary List Workflow Library Operators
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryOperators: function (axiosOptions) {
            return localVarFp.listWorkflowLibraryOperators(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This lists the workflow triggers available to you
         * @summary List Workflow Library Triggers
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowLibraryTriggers: function (limit, offset, filters, axiosOptions) {
            return localVarFp.listWorkflowLibraryTriggers(limit, offset, filters, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * List all workflows in the tenant.
         * @summary List Workflows
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows: function (axiosOptions) {
            return localVarFp.listWorkflows(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
         * @summary Patch Workflow
         * @param {string} id Id of the Workflow
         * @param {Array<JsonPatchOperation>} jsonPatchOperation
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow: function (id, jsonPatchOperation, axiosOptions) {
            return localVarFp.patchWorkflow(id, jsonPatchOperation, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Perform a full update of a workflow.  The updated workflow object is returned in the response.
         * @summary Update Workflow
         * @param {string} id Id of the Workflow
         * @param {WorkflowBody} workflowBody
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putWorkflow: function (id, workflowBody, axiosOptions) {
            return localVarFp.putWorkflow(id, workflowBody, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
         * @summary Test Workflow via External Trigger
         * @param {string} id Id of the workflow
         * @param {TestExternalExecuteWorkflowRequest} [testExternalExecuteWorkflowRequest]
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testExternalExecuteWorkflow: function (id, testExternalExecuteWorkflowRequest, axiosOptions) {
            return localVarFp.testExternalExecuteWorkflow(id, testExternalExecuteWorkflowRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
         * @summary Test Workflow By Id
         * @param {string} id Id of the workflow
         * @param {TestWorkflowRequest} testWorkflowRequest
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        testWorkflow: function (id, testWorkflowRequest, axiosOptions) {
            return localVarFp.testWorkflow(id, testWorkflowRequest, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.WorkflowsApiFactory = WorkflowsApiFactory;
/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
var WorkflowsApi = /** @class */ (function (_super) {
    __extends(WorkflowsApi, _super);
    function WorkflowsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this API to cancel a running workflow execution.
     * @summary Cancel Workflow Execution by ID
     * @param {WorkflowsApiCancelWorkflowExecutionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.cancelWorkflowExecution = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).cancelWorkflowExecution(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint allows a service outside of IdentityNow to initiate a workflow that uses the \"External Trigger\" step.  The external service will invoke this endpoint with the input data it wants to send to the workflow in the body.
     * @summary Execute Workflow via External Trigger
     * @param {WorkflowsApiCreateExternalExecuteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.createExternalExecuteWorkflow = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).createExternalExecuteWorkflow(requestParameters.id, requestParameters.createExternalExecuteWorkflowRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Create a new workflow with the desired trigger and steps specified in the request body.
     * @summary Create Workflow
     * @param {WorkflowsApiCreateWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.createWorkflow = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).createWorkflow(requestParameters.createWorkflowRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Create OAuth client ID, client secret, and callback URL for use in an external trigger.  External triggers will need this information to generate an access token to authenticate to the callback URL and submit a trigger payload that will initiate the workflow.
     * @summary Generate External Trigger OAuth Client
     * @param {WorkflowsApiCreateWorkflowExternalTriggerRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.createWorkflowExternalTrigger = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).createWorkflowExternalTrigger(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Delete a workflow.  **Enabled workflows cannot be deleted**.  They must first be disabled.
     * @summary Delete Workflow By Id
     * @param {WorkflowsApiDeleteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.deleteWorkflow = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).deleteWorkflow(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get a single workflow by id.
     * @summary Get Workflow By Id
     * @param {WorkflowsApiGetWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.getWorkflow = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).getWorkflow(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to get a single workflow execution. Workflow executions are available for up to 90 days before being archived. If you attempt to access a workflow execution that has been archived, you will receive a \"404 Not Found\" response.
     * @summary Get Workflow Execution
     * @param {WorkflowsApiGetWorkflowExecutionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.getWorkflowExecution = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).getWorkflowExecution(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get a detailed history of a single workflow execution.  Workflow executions are available for up to 90 days before being archived.  If you attempt to access a workflow execution that has been archived, you will receive a 404 Not Found.
     * @summary Get Workflow Execution History
     * @param {WorkflowsApiGetWorkflowExecutionHistoryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.getWorkflowExecutionHistory = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).getWorkflowExecutionHistory(requestParameters.id, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Use this API to list a specified workflow\'s executions. Workflow executions are available for up to 90 days before being archived. By default, you can get a maximum of 250 executions. To get executions past the first 250 records, you can do the following: 1. Use the [Get Workflows](https://developer.sailpoint.com/idn/api/beta/list-workflows) endpoint to get your workflows. 2. Get your workflow ID from the response. 3. You can then do either of the following:    - Filter to find relevant workflow executions.   For example, you can filter for failed workflow executions: `GET /workflows/:workflowID/executions?filters=status eq \"Failed\"`    - Paginate through results with the `offset` parameter.   For example, you can page through 50 executions per page and use that as a way to get to the records past the first 250.   Refer to [Paginating Results](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-results) for more information about the query parameters you can use to achieve pagination.
     * @summary List Workflow Executions
     * @param {WorkflowsApiGetWorkflowExecutionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.getWorkflowExecutions = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).getWorkflowExecutions(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This lists all triggers, actions, and operators in the library
     * @summary List Complete Workflow Library
     * @param {WorkflowsApiListCompleteWorkflowLibraryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.listCompleteWorkflowLibrary = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.WorkflowsApiFp)(this.configuration).listCompleteWorkflowLibrary(requestParameters.limit, requestParameters.offset, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This lists the workflow actions available to you.
     * @summary List Workflow Library Actions
     * @param {WorkflowsApiListWorkflowLibraryActionsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.listWorkflowLibraryActions = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.WorkflowsApiFp)(this.configuration).listWorkflowLibraryActions(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This lists the workflow operators available to you
     * @summary List Workflow Library Operators
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.listWorkflowLibraryOperators = function (axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).listWorkflowLibraryOperators(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This lists the workflow triggers available to you
     * @summary List Workflow Library Triggers
     * @param {WorkflowsApiListWorkflowLibraryTriggersRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.listWorkflowLibraryTriggers = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.WorkflowsApiFp)(this.configuration).listWorkflowLibraryTriggers(requestParameters.limit, requestParameters.offset, requestParameters.filters, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * List all workflows in the tenant.
     * @summary List Workflows
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.listWorkflows = function (axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).listWorkflows(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Partially update an existing Workflow using [JSON Patch](https://tools.ietf.org/html/rfc6902) syntax.
     * @summary Patch Workflow
     * @param {WorkflowsApiPatchWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.patchWorkflow = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).patchWorkflow(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Perform a full update of a workflow.  The updated workflow object is returned in the response.
     * @summary Update Workflow
     * @param {WorkflowsApiPutWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.putWorkflow = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).putWorkflow(requestParameters.id, requestParameters.workflowBody, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Validate a workflow with an \"External Trigger\" can receive input.  The response includes the input that the workflow received, which can be used to validate that the input is intact when it reaches the workflow.
     * @summary Test Workflow via External Trigger
     * @param {WorkflowsApiTestExternalExecuteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.testExternalExecuteWorkflow = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).testExternalExecuteWorkflow(requestParameters.id, requestParameters.testExternalExecuteWorkflowRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Test a workflow with the provided input data.  The input data should resemble the input that the trigger will send the workflow.  See the [event trigger documentation](https://developer.sailpoint.com/idn/docs/event-triggers/available) for an example input for the trigger that initiates this workflow. This endpoint will return an execution ID, which can be used to lookup more information about the execution using the `Get a Workflow Execution` endpoint. **This will cause a live run of the workflow, which could result in unintended modifications to your IDN tenant.**
     * @summary Test Workflow By Id
     * @param {WorkflowsApiTestWorkflowRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    WorkflowsApi.prototype.testWorkflow = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.WorkflowsApiFp)(this.configuration).testWorkflow(requestParameters.id, requestParameters.testWorkflowRequest, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return WorkflowsApi;
}(base_1.BaseAPI));
exports.WorkflowsApi = WorkflowsApi;
//# sourceMappingURL=api.js.map